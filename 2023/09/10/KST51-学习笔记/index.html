<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>KST51-学习笔记 | null</title><meta name="author" content="被窝理想家"><meta name="copyright" content="被窝理想家"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="开发板介绍  这个板子是KST-51的开发板，芯片是STC89C52RC   新建工程 对于单片机程序来说，每个功能程序，都必须要有一个配套的工程（Project）,先在文件夹创建一个工程，如图所示：  接着打开 Keil 软件，点击：Project–&gt;New uVision Project…然后会出现一个新建工程的界面，如图所示：  给这个工程起一个名字叫做 temple,如图所示：  保">
<meta property="og:type" content="article">
<meta property="og:title" content="KST51-学习笔记">
<meta property="og:url" content="https://huangchux.github.io/2023/09/10/KST51-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
<meta property="og:site_name">
<meta property="og:description" content="开发板介绍  这个板子是KST-51的开发板，芯片是STC89C52RC   新建工程 对于单片机程序来说，每个功能程序，都必须要有一个配套的工程（Project）,先在文件夹创建一个工程，如图所示：  接着打开 Keil 软件，点击：Project–&gt;New uVision Project…然后会出现一个新建工程的界面，如图所示：  给这个工程起一个名字叫做 temple,如图所示：  保">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangchux.github.io/img/num3.webp">
<meta property="article:published_time" content="2023-09-10T03:10:11.000Z">
<meta property="article:modified_time" content="2023-10-16T06:13:57.448Z">
<meta property="article:author" content="被窝理想家">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangchux.github.io/img/num3.webp"><link rel="shortcut icon" href="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/v2-50aa75835d2f370adadf52d12009f034_720w.jpg"><link rel="canonical" href="https://huangchux.github.io/2023/09/10/KST51-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdn.staticfile.org/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'KST51-学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-16 14:13:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="preconnect" href="https://s1.hdslb.com/" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css" media="all" onload="this.media='all'" /><link rel="stylesheet" href="//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css" media="all" onload="this.media='all'" /><link href="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/butterfly/css/all.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/my.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css" ><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://cdn.bootcdn.net/ajax/libs/css-doodle/0.32.2/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/v2-50aa75835d2f370adadf52d12009f034_720w.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/%E5%85%B6%E4%BB%96/light.png"/></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">KST51-学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-10T03:10:11.000Z" title="发表于 2023-09-10 11:10:11">2023-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-16T06:13:57.448Z" title="更新于 2023-10-16 14:13:57">2023-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/51%E7%B3%BB%E5%88%97/">51系列</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h2 id="开发板介绍">开发板介绍</h2>
<blockquote>
<p>这个板子是KST-51的开发板，芯片是STC89C52RC</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926142732.webp" style="zoom: 67%;" />
<h2 id="新建工程">新建工程</h2>
<p>对于单片机程序来说，每个功能程序，都必须要有一个配套的工程（Project）,先在文件夹创建一个工程，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-10%20113004.webp" style="zoom:80%;" />
<p>接着打开 Keil 软件，点击：Project–&gt;New uVision Project…然后会出现一个新建工程的界面，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910113636.jpg" style="zoom:50%;" />
<p>给这个工程起一个名字叫做 temple,如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910114200.webp" style="zoom: 40%;" />
<p>保存之后会弹出一个对话框，这个对话框让我们选择单片机型号。因为 Keil 软件是外国人开发的，所以我们国内的 STC89C52 并没有上榜，但是只要选择同类型号就可以了。这里我们直接选择 <code>Intel</code> 公司名下的 <code>80/87C52</code> 来代替，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910115852.webp" style="zoom:45%;" />
<p>点击 OK 之后，会弹出一个对话框，如图所示，每个工程都需要一段启动代码，如果点“否”编译器会自动处理这个问题，如果点“是”，这部分代码会提供给我们用户，我们就可以按需要自己去处理这部分代码，那这部分代码在我们初学 51 的这段时间内，一般是不需要去修改的，但是随着技术的提高和知识的扩展，我们就有可能会需要了解这块内容，所以这里先点“否”</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910120246.jpg" style="zoom:33%;" />
<p>这样工程就建立好了，我们现在工程文件下先新建两个文件，一个是<code>USER</code>,存放main.c文件，一个是<code>APP</code>,存放一些外设文件，因为一个工程里面肯定会包括很多外设，这样子方便管理，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910121414%20(1).webp" style="zoom:40%;" />
<p>工程有了之后，我们要建立编写代码的文件，点击 File–&gt;New，新建一个文件，也就是我们编写程序的平台。然后点 File–&gt;Save，可以保存文件，也可以用键盘上的快捷键<code>Ctrl + N</code>,新建文件，<code>Ctrl + S</code>保存文件，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910123223.jpg" style="zoom:50%;" />
<p>文件夹保存在我们刚刚新建的USER目录下，命名为main.c，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910123519.webp" style="zoom:50%;" />
<p>我们每做一个功能程序，必须要新建一个工程，一个工程代表了单片机要实现的一个功能。但是一个工程，有时候可以把我们的程序分多个文件写，所以每写一个文件，我们都要添加到我们所建立的工程中去</p>
<p>1、点击三色正方形</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910124142.jpg" style="zoom:80%;" />
<p>2、在Groups那里同样建立USER和APP文件夹</p>
<p>3、接着在USER中添加我们刚才建立的main.c文件</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910124408.webp" style="zoom:50%;" />
<p>接着我们还要来配置一些选项</p>
<p>点击这个<code>魔法棒</code>,接着点击<code>Output</code>,把这个<code>HEX</code>文件勾选上，这样子编译才可以找到这个HEX文件，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910124903.webp" style="zoom:50%;" />
<p><code>这样子这个工程就配置好啦</code></p>
<p>如果之后还要添加一些外设也是这个步骤，外设建立一个.c文件和一个.h文件（头文件），不过外设文件可以放在我们自己建立的<code>APP</code>目录下，例如要新建LED外设，先在APP目录下新建LED文件，接着建立LED.c和LED.h文件，然后把LED.c文件添加到这个LED文件中</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910125748.webp" style="zoom:50%;" />
<p>要保证编译时可以找到我们建立的.h文件，我们要把<code>头文件的路径</code>给包含进来，这样子才可以识别到.h文件</p>
<p>点击这个<code>魔法棒</code>,接着点击<code>C51</code>,在<code>Include Paths</code>这里点击那三个点，把头文件路径包含进来，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910130026.webp" style="zoom: 33%;" />
<p>头文件里面有固定的模板，跟着敲就行，后面的内容就是我们建立头文件的名字，不过要用大写，这个主要是<code>防止重复定义</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内容写在这里面，主要是写一些宏定义，定义变量，函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<h2 id="单片机的内部资源">单片机的内部资源</h2>
<p>这里的单片机内部资源，是指作为单片机用户，单片机提供给我们可使用的东西。总结起来，主要是三大资源：</p>
<p>Flash——<code>程序存储空间</code>，早期单片机是 OTPROM</p>
<p>RAM——<code>数据存储空间</code></p>
<p>SFR——<code>特殊功能寄存器</code></p>
<p>这个STC89C52RC 的资源情况：Flash 程序空间是 8K 字节(1K=1024，1 字节= 8 位)，RAM 数据空间是 512 字节，SFR 我们后边会逐一提到并且应用。</p>
<h2 id="单片机最小系统">单片机最小系统</h2>
<p>单片机最小系统，也叫做单片机最小应用系统，是指用最少的原件组成单片机可以工作的系统。单片机最小系统的三要素就是<code>电源、晶振、复位电路</code>，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910135423.webp" style="zoom:40%;" />
<h3 id="电源">电源</h3>
<p>我们所选用的 STC89C52，它需要 5V 的供电系统，我们的开发板是使用 USB 口输出的 5V 直流直接供电的。供电电路在 40 脚 和 20 脚的位置上，40 脚接的是 +5V，通常也称为 VCC 或 VDD，代表的是电源正极，20 脚接的是 GND，代表的是电源的负极。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910140010.webp" style="zoom:40%;" />
<h3 id="晶振">晶振</h3>
<p>晶振，又叫晶体振荡器，作用是为单片机系统提供基准时钟信号，单片机内部所有的工作都是以这个时钟信号为步调基准来进行工作的。STC89C52 单片机的 18 脚 和 19 脚是晶振引脚，我们接了一个 <code>11.0592M</code> 的晶振（它每秒钟振荡 11,059,200 次），外加 两个 20pF 的电容，电容的作用是帮助晶振起振，并维持振荡信号的稳定。</p>
<h3 id="复位电路">复位电路</h3>
<p>复位电路，接到了单片机的 9 脚 RST(Reset)复位引脚上，单片机复位一般是 3 种情况：<code>上电复位、手动复位、程序自动复位</code></p>
<h2 id="基础知识点">基础知识点</h2>
<h3 id="三极管">三极管</h3>
<h4 id="三极管的初步认识">三极管的初步认识</h4>
<p>三极管是一种很常用的控制和驱动器件，主要用来 <code>控制电流的大小</code>，箭头方向表示 <code>电流的流向</code>，同时表示了三极管的极性，常用的三极管根据材料分有<code>硅管</code>和<code>锗管</code>两种， 三极管有 2 种类型，分别是 <code>PNP 型</code>和 <code>NPN 型</code>, <code>箭头朝外的表示为NPN型、箭头方向朝里的表示为PNP型</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926145148.jpg" style="zoom: 70%;" />
<p>三极管一共有 3 个极，横向左侧的引脚叫做<code>基极b</code>，中间有一个箭头， 一头连接基极，另外一头连接的是<code>发射极 e</code>，那剩下的一个引脚就是<code>集电极 c</code></p>
<h4 id="三极管的原理">三极管的原理</h4>
<p>三极管有<code>截止、放大、饱和</code>三种工作状态。放大状态主要应用于模拟电路中，而数字电路主要使用的是<code>三极管的开关特性</code>，只用到了<code>截止与饱和</code>两种状态。</p>
<ul>
<li><code>三极管饱和</code>-----实现电子开关的“开”功能</li>
<li><code>三极管截止</code>-----实现电子开关的“关”功能</li>
</ul>
<p>口诀：<code>导通电压顺箭头过，电压导通，电流控制</code></p>
<p>三极管用法特点：</p>
<p>关键点在于 b 极（基极）和 e 极（发射极）之间的电压情况， <code>对于PNP 而言，e 极电压只要高于 b 极 0.7V 以上，这个三极管 e 极和 c 极之间就可以顺利导通。</code>也就是说，控制端在 b 和 e 之间，被控制端是 e 和 c 之间。 <code>同理，NPN 型三极管的导通电压是 b 极比 e 极高 0.7V</code>，总之是箭头的始端比末端高 0.7V 就可以导通三极管的 e 极和 c 极</p>
<p><code>b作为控制端，NPN型三极管，高电平导通，低电平关断；PNP型三极管，高电平关断，低电平导通</code></p>
<p>NPN和PNP三极管的接法有些不同， <code>NPN型三极管当下管使用，控制灯泡的负极；PNP型三极管当上管使用，控制灯泡的正极</code>。</p>
<h3 id="逻辑运算">逻辑运算</h3>
<h4 id="逻辑运算符">逻辑运算符</h4>
<p>以下逻辑运算符都是按照变量整体值进行运算的，通常就叫做逻辑运算符</p>
<table>
<thead>
<tr>
<th style="text-align:center">&amp;&amp; 逻辑与</th>
<th style="text-align:center">两个为真才为真，一个为假就是假</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">|| 逻辑或</td>
<td style="text-align:center">一个为真就是真，两个为假才是假</td>
</tr>
<tr>
<td style="text-align:center">! 逻辑非</td>
<td style="text-align:center">F = ! A，当 A 值为假时，其结果 F 为真；当 A 值为真时，结果 F 为假</td>
</tr>
</tbody>
</table>
<h4 id="位运算符">位运算符</h4>
<p>以下逻辑运算符都是按照变量内的每一个位来进行运算的，通常就叫做位运算符</p>
<table>
<thead>
<tr>
<th style="text-align:center">&amp; 按位与</th>
<th style="text-align:center">F = A &amp; B，将 A、B 两个字节中的每一位都进行与运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">|  按位或</td>
<td style="text-align:center">将 A、B 两个字节中的每一位都进行或运算</td>
</tr>
<tr>
<td style="text-align:center">~ 按位取反</td>
<td style="text-align:center">F = ~A，将 A 字节内的每一位进行非运算（就是取反）</td>
</tr>
<tr>
<td style="text-align:center">^ 按位异或</td>
<td style="text-align:center">如果运算双方的值不同（即相异）则结果为真，双方值相同则结果为假（相同为0，不同为1）</td>
</tr>
</tbody>
</table>
<p>F = A ^ B，A = 0b11001100，B = 0b11110000，F = 0b00111100</p>
<h4 id="逻辑电路符号">逻辑电路符号</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-12%20143439.webp" style="zoom:80%;" />
<h3 id="不同数据类型间的相互转换">不同数据类型间的相互转换</h3>
<p>当不同数据类型之间混合运算的时候，不同类型的数据首先会转换为同一类型，转换的主要原则是：<code>短字节的数据向长字节数据转换</code></p>
<p>比如：unsigned char a; unsigned int b; unsigned int c; c = a *b; 在运算的过程中，程序会自动全部按照 <code>unsigned int</code> 型来计算，c 的数据类型是 <code>unsigned int</code> 型，取值范围是 <code>0~65535</code>，而 70000 超过 65535 了，其结果会<code>溢出</code>，最终 c 的结果是 <code>(70000 - 65536) = 4464</code></p>
<p>不同类型变量之间的相互赋值，<code>短字节类型变量向长字节类型变量赋值时，其值保持不变</code>。比如 unsigned char a=100; unsigned int b=700; b=a;那么最终 b 的值就是 100 了。但是如果我们的程序是 unsigned char a=100; unsigned int b=700; a=b;那么 a 的值仅仅是取了 b 的低 8 位，我们首先要把 700 变成一个 16 位的二进制数据，然后取它的低 8 位出来，也就 是 188，这就是<code>长字节类型给短字节类型赋值</code>的结果，会从<code>长字节类型的低位开始截取刚好等于短字节类型长度的位，然后赋给短字节类型</code></p>
<p>C 语言不同类型运算的时候数值会转换同一类型运算，但是每一步运算都会进行识别判断，不会进行一个总的分析判断，避免这类问题 的产生可以采用<code>强制类型转换</code>的方法</p>
<p>在一个<code>变量前边</code>加上一个<code>数据类型名</code>，并且这个类型名用<code>小括号括起来</code>，就表示<code>把这个变量强制转换成括号里的类型</code>。如 <code>c = (unsigned long)a * b</code> ;由于<code>强制类型转换运算符优先级高于*</code>，所以这个地方的运算是先把 a 转换成一个 unsigned long 型的变量，而后与 b 相乘， 根据 C 语言的规则 b 会自动转换成一个 unsigned long 型的变量，而后运算完毕结果也是一个 unsigned long 型的，最终赋值给了 c</p>
<p>在 51 单片机里边，有一种特殊情况，就是 <code>bit</code> 类型的变量，这个 bit 类型的强制类型转换，是不符合上边讲的这个原则的，比如 bit a=0; unsigned char b; a=(bit)b;这个地方要特别注意，使用 bit 做强制类型转换，<code>不是取 b 的最低位</code>，而是它会判断 b 这个变量是 0 还是非 0 的值，<code>如果 b 是 0，那么 a 的结果就是 0，如果 b 是任意非 0 的其它值，那么 a 的结果都是 1</code></p>
<h3 id="51-单片机-RAM-区域的划分">51 单片机 RAM 区域的划分</h3>
<p>51 单片机的 RAM 分为两个部分，一块是片内 RAM，一块是片外 RAM，片内 RAM 和片外 RAM 的地址不是连起来的， 片内是从 0x00 开始，片外是从 0x0000 开始的</p>
<p>以下是几个 Keil C51 语言中的<code>关键字</code>，代表了 RAM 不同区域的划分</p>
<ol>
<li>
<p>data：片内 RAM 从 0x00~0x7F</p>
</li>
<li>
<p>idata：片内 RAM 从 0x00~0xFF</p>
</li>
<li>
<p>pdata：片外 RAM 从 0x00~0xFF</p>
</li>
<li>
<p>xdata：片外 RAM 从 0x0000~0xFFFF</p>
</li>
</ol>
<p>data 是 idata 的一部分，pdata 是 xdata 的一部分，在 Keil 默认设置下，<code>data 是可以省略的</code>，即什么都不加的时候变量就是定义到 <code>data</code> 区域中的。data 区域 RAM 的访问在汇编语言中用的是直接寻址，<code>执行速度是最快的</code>。如果定义成 idata，不仅仅可以访问 data 区域，还可以访问 0x80H~0xFF 的范围，但加了 idata 关键字后，访问的时候 51 单片机用的是通用寄存器<code>间接寻址</code>，速度较 data 会慢一些，而且我们平时大多数情况下不太希望访问到 0x80H~0xFF，因为这块通常用于中断与函数调用的堆栈，所以在绝大多数情况下，我们使用内部 RAM 的时候，只用 data 就可以了</p>
<h3 id="指针">指针</h3>
<p>变量 a 的地址就是 0x00，它的地址的表达方式可以写成：&amp;a，这样就代表了相应变量的地址，C 语言中变量前加一个&amp;表示取这个变量的地址，&amp;在这里就叫做“取址符”</p>
<p>在 C 语言中，我们要访问一个变量，有两种方式：一种是通过<code>变量名</code>来访问， 另一种就是通过<code>变量的地址</code>来访问。在 C 语言中，<code>地址就等同于指针，变量的地址就是变量的指针</code>。保存指针的变量，称之为指针变量，简称为指针，而通常我们说的<code>指针就是指针变量</code></p>
<h4 id="指针变量的声明">指针变量的声明</h4>
<p>在 C 语言中，变量的地址往往都是编译系统自动分配的，我们是不知道某个变量的具体地址的。所以我们定义一个<code>指针变量 p</code>，把普通变量 a 的地址直接送给指针变量 p</p>
<blockquote>
<p>指针变量 p 的定义和初始化，有两种方式：</p>
</blockquote>
<p>方法 1：<code>定义时直接进行初始化赋值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = &amp;a; <span class="comment">//普通变量 a 的地址直接送给指针变量 p </span></span><br></pre></td></tr></table></figure>
<p>方法 2：<code>定义后再进行赋值</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a; </span><br><span class="line"><span class="comment">//这个指针指向的变量类型是 unsigned char 型的， p 本身，是指针变量，不可以给它赋普通的值或者变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p; <span class="comment">//*p代表了这个 p 是个指针变量，专门用来存放变量地址的</span></span><br><span class="line">p = &amp;a;           <span class="comment">//普通变量 a 的地址直接送给指针变量 p</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义指针变量 *p 和取值运算 *p 的区别</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同样是*p，放在定义的位置就是定义指针变量，放在执行代码中就是取值运算</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p; <span class="comment">// * 代表的意思是 p 是一个指针变量，而非普通的变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">p = &amp;a;  <span class="comment">// &amp;a 表示取 a 这个变量的地址，把这个地址送给 p</span></span><br><span class="line">b = *p;  <span class="comment">// *p 运算表示的是取指针变量 p 指向的地址的变量的值，把这个值送给了 b，最终的结果相当于 b = a</span></span><br></pre></td></tr></table></figure>
<h4 id="指向数组元素的指针">指向数组元素的指针</h4>
<p>指向数组元素的指针，其本质还是变量的指针。因为数组中的每个元素，其实都可以直接看成是一个变量，所以指向数组元素的指针，也就是变量的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> number[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">p = &amp;number[<span class="number">0</span>]; <span class="comment">//表示指针 p 指向了 number 的第 0 号元素，也就是把number[0]的地址赋值给了 p</span></span><br><span class="line">p = &amp;number[<span class="number">1</span>]; <span class="comment">//表示指针 p 指向了数组 number 的第 1号元素</span></span><br><span class="line">p = p + <span class="number">1</span>;      <span class="comment">//表示指针 p 指向了 number[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果</span></span><br><span class="line">p = &amp;number[<span class="number">0</span>];</span><br><span class="line">q = &amp;number[<span class="number">9</span>];</span><br><span class="line"><span class="comment">// q - p 的结果就是 9，这个 9 代表的是元素的个数，而不是真正的地址差值</span></span><br></pre></td></tr></table></figure>
<p>数组元素指针还有一种情况，就是<code>数组名字其实就代表了数组元素的首地址</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这两种表达方式是等价的</span></span><br><span class="line">p = &amp;number[<span class="number">0</span>]; </span><br><span class="line">p = number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *(p+x) 和 *(number+x) 都表示 number[x]</span></span><br><span class="line"><span class="comment">//指向数组元素的指针也可以表示成数组的形式，也就是说，允许指针变量带下标，即 p[i]和*(p+i)是等价的</span></span><br><span class="line"><span class="comment">//不过一般采用后者的写法</span></span><br></pre></td></tr></table></figure>
<p>二维数组元素的指针和一维数组类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> number[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//它的地址的表达方式为</span></span><br><span class="line">p = &amp;number[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//数组名代表了数组元素的首地址，也就是说 p 和 number 都是指数组的首地址</span></span><br><span class="line"><span class="comment">//对二维数组来说，number[0]，number[1]，number[2]都可以看成是一维数组的数组名字</span></span><br><span class="line">number[<span class="number">0</span>] 等价于 &amp;number[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">number[<span class="number">1</span>] 等价于 &amp;number[<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>在 C 语言里边，<code>sizeof()</code> 可以用来获取括号内的对象所占用的内存字节数，sizeof() 括号中可以是变量名，也可以是变量类型名，其结果是等效的</p>
<h3 id="复合数据类型">复合数据类型</h3>
<h4 id="结构体数据类型">结构体数据类型</h4>
<p>结构体本身不是一个基本的数据类型，而是构造的，它每个成员可以是一个基本的数据类型或者是一个构造类型。结构体既然是一种构造而成的数据类型，那么在使用之前必须先<code>定义</code>它</p>
<p>声明结构体变量的一般格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    类型 <span class="number">1</span> 变量名 <span class="number">1</span>；</span><br><span class="line">    类型 <span class="number">2</span> 变量名 <span class="number">2</span>；</span><br><span class="line">    ……</span><br><span class="line">    类型 n 变量名 n；</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 结构体变量名 1, 结构体变量名 2, ... 结构体变量名 <span class="title">n</span>;</span></span><br></pre></td></tr></table></figure>
<p>我们来构造一个实际的表示日期时间的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//日期时间结构体定义</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> year; <span class="comment">//年</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mon; <span class="comment">//月</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> day; <span class="comment">//日</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hour; <span class="comment">//时</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> min; <span class="comment">//分</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sec; <span class="comment">//秒</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> week; <span class="comment">//星期</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span> <span class="title">bufTime</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//struct 是结构体类型的关键字，sTime 是这个结构体的名字，bufTime 就是定义了一个具体的结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要给结构体变量的成员赋值</span></span><br><span class="line">bufTime.year = <span class="number">0x2023</span>;</span><br><span class="line">bufTime.mon = <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>
<p>一个<code>指针变量</code>如果指向了一个<code>结构体变量</code>的时候，称之为<code>结构指针变量</code>。结构指针变量是指向的<code>结构体变量的首地址</code>，通过结构体指针也可以访问到这个结构变量</p>
<p>结构指针变量声明的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sTime</span> *<span class="title">pbufTime</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用结构体指针对结构体成员的访问，和使用结构体变量名对结构体成员的访问，其表达式有所不同</span></span><br><span class="line"><span class="comment">//结构体指针对结构体成员的访问表达式为：</span></span><br><span class="line">pbufTime-&gt;year = <span class="number">0x2013</span>; </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">(*pbufTime).year = <span class="number">0x2013</span>;</span><br><span class="line"><span class="comment">//一般使用前者</span></span><br></pre></td></tr></table></figure>
<h4 id="共用体数据类型">共用体数据类型</h4>
<p>共用体也称之为<code>联合体</code>，共用体定义和结构体十分类似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    数据类型 <span class="number">1</span> 成员名 <span class="number">1</span>；</span><br><span class="line">    数据类型 <span class="number">2</span> 成员名 <span class="number">2</span>；</span><br><span class="line">    ……</span><br><span class="line">    数据类型 n 成员名 n；</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> 共用体名 共用体变量;</span></span><br></pre></td></tr></table></figure>
<p>共用体表示的是<code>几个变量共用一个内存位置</code>，也就是成员 1、成员 2……成员 n 都用一个内存位置。共用体成员的访问方式和结构体是一样的，成员访问的方式是：<code>共用体名.成员名</code>，使用指针来访问的方式是：<code>共用体名-&gt;成员名</code></p>
<p>共用体和结构体的主要区别如下：</p>
<ol>
<li>
<p>结构体和共用体都是由多个不同的数据类型成员组成，但在任何一个时刻，共用体只能存放一个被选中的成员，而结构体所有的成员都存在。</p>
</li>
<li>
<p>对于共同体的不同成员的赋值，将会改变其它成员的值，而对于结构体不同成员的赋值是相互之间不影响的</p>
</li>
</ol>
<h4 id="枚举数据类型">枚举数据类型</h4>
<p>在实际问题中，有些变量的取值被限定在一个有限的范围内。例如，一个星期从周一到周日有 7 天，一年从 1 月到 12 月有 12 个月，蜂鸣器有响和不响两种状态等等。如果把这些变量定义成整型或者字符型不是很合适，因为这些变量都有自己的范围。C 语言提供了一种 称为“枚举”的类型，在枚举类型的定义中列举出所有可能的值，并可以为每一个值取一个 形象化的名字，它的这一特性可以提高程序代码的可读性</p>
<p>枚举的说明形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    标识符 <span class="number">1</span>[ = 整型常数],</span><br><span class="line">    标识符 <span class="number">2</span>[ = 整型常数],</span><br><span class="line">    ……</span><br><span class="line">    标识符 n[ = 整型常数]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 枚举变量;</span></span><br></pre></td></tr></table></figure>
<p>枚举的说明形式中，如果没有被初始化，那么<code>“=整型常数”</code>是可以被省略的，如果是默认值的话，从第一个标识符顺序赋值 0、1、2……，但是当枚举中任何一个成员被赋值后， 它后边的成员按照<code>依次加 1</code> 的规则确定数值</p>
<p>枚举的使用，有几点要注意：</p>
<ol>
<li>
<p>枚举中每个成员结束符是<code>逗号</code>，而不是分号，最后一个成员可以省略逗号</p>
</li>
<li>
<p>枚举成员的初始化值可以是负数，但是后边的成员依然依次加 1</p>
</li>
<li>
<p>枚举变量只能取枚举结构中的某个标识符常量，不可以在范围之外</p>
</li>
</ol>
<h3 id="转义字符">转义字符</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-03%20183438.webp" style="zoom: 33%;" />
<p>字符串常量在内存中按顺序逐个存储字符串中的字符的 ASCII 码值，并且特别注意，最后还有一个字符 <code>\0</code>，‘\0’ 字符的 ASCII 码值是 0， 它是<code>字符串结束标志</code>，在写字符串的时候，这个‘\0’是<code>隐藏</code>的，但是实际是存在的</p>
<h2 id="LED模块">LED模块</h2>
<h3 id="点亮LED用到的原理图">点亮LED用到的原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910161933.jpg" style="zoom:116%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926220254.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910162108.jpg" style="zoom: 78%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910162236.jpg" style="zoom:78%;" />
<p>三极管基极通过一个 <code>1K</code> 的电阻接到了单片机的 <code>74HC138芯片</code>上的 <code>LEDS6</code>端口上， <code>发射极直接接到 5V 的电源上</code>，集电极上分别连了8个 LED 小灯，8个LED小灯分别连了 <code>330Ω电阻</code>。如果 <code>LEDS6</code> 由我们的程序给一个 <code>高电平 1</code>，那么 <code>基极 b 和发射极 e 都是 5V</code>，也就是说 <code>e到 b 不会产生一个 0.7V 的压降，这个时候，发射极和集电极也就不会导通，LED 小灯也就不会亮。</code>如果程序给 <code>LEDS6</code> <code>一个低电平 0</code>，这时 <code>e 极还是 5V，于是 e 和 b 之间产生了压差，三极管 e 和 b 之间也就导通了</code>，三极管 e 和 b 之间大概有 0.7V 的压降，那还有（5-0.7）V 的电压会在电阻 R47 上；这时候根据二极管特性只要负极加个 <code>低电平0</code> 就可以点亮LED 小灯了。</p>
<h3 id="74HC245芯片">74HC245芯片</h3>
<p><code>原理图</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910163642.webp" style="zoom: 40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910171504.jpg" style="zoom:50%;" />
<p>74HC245 是个 <code>双向缓冲器</code>(DIR 是方向引脚，当它高电平时：右侧B编号电压等于左侧A编号对应电压；当 DIR低电平：左侧A编号电压等于右侧B编号对应电压)；作用是<code>电流驱动缓冲</code>，不起到任何逻辑控制的效果，稳定工作在 <code>70mA</code> 电流是没有问题的，比单片机的 8 个 IO 口大多了，所以我们可以把他接在 <code>小灯和 IO 口之间做缓冲</code>，这个地方 <code>控制端是左侧接的是 P0 口，我 们要求 B 等于 A 的状态，所以 1 脚我们直接接的 5V 电源，即高电平</code></p>
<p>问：已经在电源 VCC 那地方加了一个三极管驱动了， 为何还要再加 245 驱动芯片呢？</p>
<p>从电源正极到负极的电流水管的粗细都要满足要求，任何一个位置的管子过细，都会出现瓶颈效应，电流在整个通路中细管处会受到限制而降低，所以在电路通路的每个位置上，都要保证通道足够畅通，这个 74HC245 的作用就是消除单片机 IO 这一环节的瓶颈</p>
<h3 id="74HC138芯片">74HC138芯片</h3>
<p>三八译码器，就是把 3 种输入状态翻译成 8 种输出状态</p>
<p>想让这个 74HC138 正常工作，<code>ENLED</code> 那个输入位置必须输入<code>低电平</code>，<code>ADDR3</code> 位置必须输入<code>高电平</code></p>
<p><code>原理图</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910164814.webp" style="zoom: 50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910173603.jpg" style="zoom:50%;" />
<p><code>头上有一横表示在低电平时有效</code><br>
真值：<br>
L：<strong>表示低电平0</strong><br>
H：<strong>表示高电平1</strong><br>
X：<strong>表示无论是高电平还是低电平都不影响真值</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926204759.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230911143700.jpg" style="zoom:50%;" />
<p>从上面的管脚图及真值表可以知道该芯片使用方法很简单，给 <code>G1(E3) 使能管脚高电平，G2(ENLED) 管脚为低电平</code>，至于哪个管脚输出有效电平（低电平），要看 C B A 输入管脚的电平状态。如果 <code>C B A 都为低电平，则 Y0 输出有效电平（低电平）</code>，其他管脚均输出高电平。</p>
<blockquote>
<p>方法：C B A 输入就相当于 3 位 2 进制数，A 是低位，B 是次高位，C 是高位。而 Y0-Y7 具体哪一个输出有效电平，就看输入二进制对应的十进制数值。比如输入是 110（C，B，A），其对应的十进制数是 6，所以Y6输出有效电平（低电平）。</p>
<p><code>C对应A2，B对应A1，A对应A0，则A2为高位，A0为低位</code></p>
</blockquote>
<p>前面我们知道需要给 <code>LEDS6</code> 一个 <code>低电平 0</code>才能点亮LED，所以需要设置 Y6，则需要看真值表</p>
<p>由真值表可知，想让 Y6为低电平，则需要设置：</p>
<ul>
<li>ADDR3(E3)：1</li>
<li>ADDR2(A2)：1</li>
<li>ADDR1(A1)：1</li>
<li>ADDR0(A0)：0</li>
<li>ENLED(E1+E2)：0</li>
</ul>
<h3 id="LED小灯整体电路图">LED小灯整体电路图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230911144140.webp" style="zoom: 40%;" />
<p>我们来看下点亮 LED 小灯的过程，首先看 <code>74HC138</code>，我们要让 <code>LEDS6</code> 为<code>低电平</code>才能导通<code>三极管 Q16</code>，所以 <code>ENLED = 0，ADDR3 = 1</code>；保证 74HC138 <code>使能</code>。然后 <code>ADDR2 =  1; ADDR1 = 1; ADDR0 = 0</code>;这样保证了<code>三极管 Q16 这个开关开通</code>，5V 电源加到 LED 上。 而 <code>74HC245</code> 左侧是通过 <code>P0</code> 口控制，我们让 <code>P0.0 引脚等于 0</code>，就是 <code>DB_0 等于 0</code>，而右侧 DB0 等于 DB_0 的状态，也是 0，那么这样在这一排共 8 个 LED 小灯当中，只有最右侧的小灯和 5V 之间有压差，有<code>压差</code>就会有电流通过，有电流通过我们的 LED2 就会<code>发光</code>了。 74HC245 左侧我们可以看出来，是直接接到 P0 口上的，而 74HC138 的 ADDR0 ~ ADDR3 接在何处呢？来看下面的图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230910162108.jpg" style="zoom: 78%;" />
<p>从图中可以看出，把跳线帽右侧和中间的针连到了一 起，这样实现的就是图中的 <code>P1.0 和 ADDR0</code> 连接到一起、P1.1 和 ADDR1 接一起、P1.2 和 ADDR2 接一起、P1.3 和 ADDR3 接一起，这样子就可以很清晰地知道为什么小灯点亮了</p>
<h3 id="LED程序">LED程序</h3>
<blockquote>
<h4 id="点亮一个LED">点亮一个LED</h4>
</blockquote>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED2 = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>; <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">1</span>; <span class="comment">//A2到A0的值为110，则使Y6为低电平，则LEDS6为低电平，使三极管导通，点亮LED灯</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LED2 = <span class="number">0</span>; <span class="comment">//点亮LED2</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="LED灯闪烁">LED灯闪烁</h4>
</blockquote>
<p>这里我另外新建了Delay文件，里面存放延时函数，方便管理，要用的时候直接调用头文件就好</p>
<p><code>Dealy.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @从STC-ISP生成复制延时函数</span></span><br><span class="line"><span class="comment">  * @函数名:  Delay_ms</span></span><br><span class="line"><span class="comment">  * @参数1 : 需要延时多少毫秒</span></span><br><span class="line"><span class="comment">  * @返回值: 无</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">    <span class="keyword">while</span>(xms--)</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        j = <span class="number">190</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> (--j);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dealy.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DELAY_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DELAY_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>; <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED2 = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;</span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    ADDR2 = <span class="number">1</span>;</span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED2 = <span class="number">0</span>; <span class="comment">//点亮LED2</span></span><br><span class="line">        Delay_ms(<span class="number">20</span>); <span class="comment">//延时20毫秒</span></span><br><span class="line">        LED2 = <span class="number">1</span>; <span class="comment">//熄灭LED2</span></span><br><span class="line">        Delay_ms(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="LED左右流水">LED左右流水</h4>
</blockquote>
<p><code>Dealy.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @从STC-ISP生成复制延时函数</span></span><br><span class="line"><span class="comment">  * @函数名:  Delay_ms</span></span><br><span class="line"><span class="comment">  * @参数1 : 需要延时多少毫秒</span></span><br><span class="line"><span class="comment">  * @返回值: 无</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> data i, j;</span><br><span class="line">  <span class="keyword">while</span>(xms--)</span><br><span class="line">  &#123;</span><br><span class="line">    i = <span class="number">11</span>;</span><br><span class="line">    j = <span class="number">190</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (--j);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dealy.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DELAY_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DELAY_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>; <span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT  	P0 <span class="comment">//定义LED端口为 P0 </span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    u8 dir = <span class="number">0</span>;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>; <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">1</span>; <span class="comment">//A2到A0的值为110，则使Y6为低电平，则LEDS6为低电平，使三极管导通，点亮LED灯</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>) <span class="comment">//如果dir为0，则流水灯向左移动</span></span><br><span class="line">            &#123;</span><br><span class="line">                LED_PORT = ~(<span class="number">0x01</span> &lt;&lt; i); <span class="comment">//0000 0001 左移i位 按位取反变成 1111 1110 （点亮第一个灯）以此类推循环8次</span></span><br><span class="line">                Delay_ms(<span class="number">20</span>); <span class="comment">//延时20毫秒</span></span><br><span class="line">                <span class="keyword">if</span>(LED_PORT == <span class="number">0x7f</span>) <span class="comment">//0x7f --&gt; 0111 1111 ,如果第八个灯点亮</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">1</span>) <span class="comment">//如果dir为1，则流水灯向右移动</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">//循环八次</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LED_PORT = ~(<span class="number">0x80</span> &gt;&gt; i); <span class="comment">//1000 0000 右移i位 按位取反变成 0111 1111 （点亮第八个灯）以此类推循环8次</span></span><br><span class="line">                    Delay_ms(<span class="number">20</span>); <span class="comment">//延时20毫秒</span></span><br><span class="line">                    <span class="keyword">if</span>(LED_PORT == <span class="number">0xfe</span>) <span class="comment">//0xfe --&gt; 1111 1110 ,如果第一个灯点亮</span></span><br><span class="line">                        dir = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时器">定时器</h2>
<h3 id="定时器的初步认识">定时器的初步认识</h3>
<p>①振荡周期：石英晶体振荡器的工作频率的倒数，为单片机提供定时信号的振荡源的周期（晶振周期或外加振荡周期）。</p>
<p>②时钟周期：<code>2 个振荡周期为 1 个时钟周期</code></p>
<p>③机器周期：<code>单片机完成一个操作的最短时间</code>。<code>1 个机器周期含 6 个时钟周期，12 个振荡周期</code>。</p>
<p>④指令周期：完成 1 条指令所占用的全部时间，它以机器周期为单位。</p>
<p>例如：外接晶振为 12MHz 时，51 单片机相关周期的具体值为：</p>
<p>振荡周期=1/12us;<br>
时钟周期=1/6us;<br>
机器周期=1us;<br>
指令周期=1~4us</p>
<h3 id="定时器介绍">定时器介绍</h3>
<p>①51 单片机有两组定时器/计数器，因为<code>既可以定时，又可以计数</code>，故称之为定时器/计数器。<br>
②定时器/计数器和单片机的 CPU 是<code>相互独立</code>的。定时器/计数器工作的过程是自动完成的，<code>不需要 CPU 的参与</code>。<br>
③51 单片机中的定时器/计数器是根据机器内部的时钟或者是外部的脉冲信号对寄存器中的数据加 1。<br>
有了定时器/计数器之后，可以增加单片机的效率，一些简单的重复加 1 的工作可以交给定时器/计数器处理。CPU 转而处理一些复杂的事情。同时可以实现精确定时作用。</p>
<h3 id="定时器原理">定时器原理</h3>
<p>STC89C5X 单片机内有两个可编程的定时/计数器 <code>T0、T1</code> 和一个特殊功能定时器 <code>T2</code>。定时/计数器的实质是加 1 计数器（16 位），<code>由高 8 位和低 8 位两个寄存器 THx 和 TLx 组成</code>。它随着计数器的输入脉冲进行<code>自加 1</code>，也就是每来一个脉冲，计数器就自动加 1，当加到计数器为全 1 时，再输入一个脉冲就使计数器回零，且<code>计数器的溢出使相应的中断标志位置 1</code>，向 CPU 发出中断请求（定时 /计数器中断允许时）。如果定时/计数器工作于<code>定时模式</code>，则表示<code>定时时间已到</code>； 如果工作于<code>计数模式</code>，则表示<code>计数值已满</code>。可见，由溢出时计数器的值减去计数初值才是加 1 计数器的计数值。</p>
<p>定时器就是用来进行定时的，定时器内部有一个<code>寄存器</code>，我们让它开始计数后，这个寄存器的值每经过<code>一个机器周期</code>就会<code>自动加 1</code>，因此，我们可以把<code>机器周期理解为定时器的计数周期</code>。就像我们的钟表，每经过一秒，数字自动加 1，而这个定时器就是每过一个机器周期的时间，也就是 <code>12/11059200</code> 秒，数字自动加 1。还有一个特别注意的地方， 就是钟表是加到 60 后，秒就自动变成 0 了，这种情况在单片机或计算机里我们称之为<code>溢出</code>。 假如是 16 位的定时器，也就是 2 个字节，最大值就是 65535， 那么加到 65535 后，再加 1 就算溢出，对于 51 单片机来说，溢出后，这个值会直接变成 0。<code>从某一个初始值开始，经过确定的时间后溢出，这个过程就是定时的含义</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221011200836.jpg" style="zoom:80%;" />
<p><strong>51 单片机定时器/计数器内部结构图：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/fb0cd3e8d3a94f9a9ab09347715105a3.webp" style="zoom:40%;" />
<h3 id="定时器的寄存器">定时器的寄存器</h3>
<p>标准的 51 单片机内部有 <code>T0 和 T1</code> 这两个定时器，对于单片机 的每一个功能模块，都是由它的 <code>SFR</code>，也就是<code>特殊功能寄存器</code>来控制。与定时器有关的特殊功能寄存器，有以下几个,以下表的寄存器是存储定时器的计数值的。<code>TH0/TL0 用于 T0，TH1/TL1 用于 T1</code></p>
<p><strong>计数器的工作由两个特殊功能寄存器控制</strong></p>
<p><strong>TCON</strong> 是<code>控制寄存器</code>，控制 <code>T0、T1</code> 的<code>启动</code>和<code>停止</code>及设置<code>溢出标志</code></p>
<p><strong>TMOD</strong> 是定时/计数器的<code>工作方式寄存器</code>，确定<code>工作方式和功能</code></p>
<p>TCON 是“可位寻址”，TMOD 是“不可位寻址”；<code>可位寻址</code>就是可以直接操作其中<code>一个位</code>，<code>不可位寻址</code>只能操作<code>整个字节</code></p>
<h4 id="控制寄存器-TCON">控制寄存器 TCON</h4>
<p>TCON 的<code>低 4 位用于控制外部中断</code>。TCON 的<code>高 4 位用于控制定时/计数器的启动和中断申请</code>。</p>
<p>其格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/1c5374397e7b4c6d876b5019c2615205.webp" style="zoom:40%;" />
<p>TF1（TCON.7）：<code>T1（定时器1） 溢出中断请求标志位</code>。T1 计数溢出时由硬件自动置 TF1 为 1。CPU 响应中断后 TF1 由硬件自动清 0。T1 工作时，CPU 可随时查询 TF1 的状态。所以，TF1 可用作查询测试的标志。TF1 也可以用软件置 1 或清 0，同硬件置 1 或清 0 的效果一样。</p>
<p>TR1（TCON.6）：<code>T1（定时器1） 运行控制位</code>。TR1 置 1 时，T1 开始工作；TR1 置 0 时， T1 停止工作。TR1 由软件置 1 或清 0。所以，软件置位/清零来进行启动/停止定时器。</p>
<p>TF0（TCON.5）：<code>T0 溢出中断请求标志位</code>，其功能与 TF1 类同。</p>
<p>TR0（TCON.4）：<code>T0 运行控制位</code>，其功能与 TR1 类同。</p>
<p>当我们程序中写 <code>TR1 = 1</code> 以后，定时器值就会每经过<code>一个机器周期自动加 1</code>，当我们程序中写 <code>TR1 = 0</code> 以后，定时器就会<code>停止加 1</code>，其值会保持不变化。<code>TF1是一个标志位</code>，他的作用是告诉我们<code>定时器溢出</code>了。比如我们的定时器设置成 16 位的模式，那么每经过一个机器周期，TL1 加 1 一次，当 TL1 加到 255 后，再加 1，TL1 变成 0，TH1 会加 1 一次，如此一直加到 TH1 和 TL1 都是 255（即 TH1 和 TL1 组成的 16 位整型数为 65535）以后，再加 1 一次，就会溢出了，TH1 和 TL1 同时都变为 0，<code>只要一溢出，TF1 马上自动变成 1</code>，告诉我们定时器溢出了，仅仅是提供给我们一个信号，让我们知道定时器溢出了，它不会对定时器是否继续运行产生任何影响</p>
<h4 id="工作方式寄存器-TMOD">工作方式寄存器 TMOD</h4>
<p>工作方式寄存器 <code>TMOD</code> 用于设置定时/计数器的<code>工作方式</code>，<code>低四位用于 T0，高四位用于 T1</code>。</p>
<p>其格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/bad22bf466c545af8d2eb9d6e977b683.webp" style="zoom: 40%;" />
<p>GATE 是门控位, <code>GATE=0</code> 时，用于控制定时器的启动是否受外部中断源信号的影响。只要用软件使 <code>TCON 中的 TR0 或 TR1 为 1</code>，就可以启动定时/计数器工作；</p>
<p><strong>GATE＝1</strong> 时，要用软件使 <code>TR0 或 TR1 为 1</code>，<code>同时外部中断引脚 INT0/1 也为高电平</code>时，才能启动定时/计数器工作。即此时定时器的启动条件，加上了 INT0/1 引脚为高电平这一条件。</p>
<p>C/T ：定时/计数模式选择位。<code>C/T ＝0 为定时模式;C/T =1 为计数模式</code>。</p>
<p>M1M0：工作方式设置位。定时/计数器有<code>四种</code>工作方式。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f3041f95b92f45feb455a46a17682209.webp" style="zoom:40%;" />
<h3 id="定时-计数器的工作方式">定时/计数器的工作方式</h3>
<p><strong>（1）方式 0</strong></p>
<p>方式 0 为 <code>13 位计数</code>，由 TL0 的低 5 位（高 3 位未用）和 TH0 的 8 位组成。 TL0 的低 5 位溢出时向 TH0 进位，<code>TH0 溢出</code>时，<code>置位</code> TCON 中的 <code>TF0</code> 标志</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/84729d51b33f49749d78a5b7ec7d9517.webp" style="zoom:37%;" />
<p>门控位 GATE 具有特殊的作用。当 <code>GATE=0</code> 时，经<code>反相</code>后使或门<code>输出为 1</code>，此时仅由 TR0 控制与门的开启，与门输出 1 时，控制开关接通，计数开始；</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/afc3484e045f49f39ac3ba1eb16b2c30.webp" style="zoom:40%;" />
<p>当<code>GATE=1</code> 时，由外中断引脚信号控制或门的输出，此时<code>控制与门的开启由外部中断引脚信号和 TR0 共同控制</code>。当 <code>TR0=1</code> 时，外部中断引脚信号引脚的<code>高电平启动计数</code>，外部中断引脚信号引脚的<code>低电平停止计数</code>。这种方式常用来测量外中断引脚上正脉冲的宽度。计数模式时，计数脉冲是 T0 引脚上的外部脉冲。</p>
<p>当 <code>GATE =  0</code> 时，经过 &quot;<code>非门</code>&quot;变成 1，然后再到 “<code>或门</code>”(只要一个为真，都为真)，这时候不管 INTO 引脚是否为真，然后来到 “与门”，这时候取决于 TR0,当 TR0 为1(真) 开关才会闭合工作。计数初值与计数个数的关系为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mn>2</mn><mn>13</mn></msup><mo>−</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">X=2^{13}-N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p><strong>（2）方式 1</strong></p>
<p>方式 1 的计数位数是 <code>16 位</code>，由 <code>TL0 作为低 8 位，TH0 作为高 8 位</code>，组成了 16 位加 1 计数器</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/626289c8ef6045489409f9e52e1b1dc6.webp" style="zoom:40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220927141344%20(1).jpg" style="zoom:67%;" />
<p>OSC框：表示<code>时钟频率</code>，因为 1 个机器周期等于 12 个时钟周期，所以那个 d 就等于 12</p>
<p>● 在 GATE 位为 1 的情况下，经过一个非门变成 0，或门电路结果要想是 1 的话，那 INT0 即 <code>P3.2</code> 引脚必须是 <code>1</code> 的情况下，这个时候定时器才会工作，而 INT0 引脚是 0 的情况下，定时器不工作，这就是 GATE 位的作用<br>
● 当 <code>GATE 位为 0</code> 的时候，经过一个<code>非门会变成 1</code>，那么不管 INT0 引脚是什么电平，经过或门电路后都肯定是 1，定时器就会工作<br>
● 要想让定时器工作，就是自动加 1，从图上看有两种方式，第一种方式是那个开关打到上边的箭头，就是 <code>C/T = 0</code> 的时候，一个<code>机器周期 TL 就会加 1</code> 一次，当开关打到下边的箭头，即 <code>C/T =1</code> 的时候，<code>T0</code> 引脚即 P3.4 引脚来一个<code>脉冲</code>，TL 就加 1 一次，这也就是计数器功能。</p>
<p>原理跟方式 0 差不多唯一不同的就是计数方式不同， 计数初值与计数个数的关系为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">X=2^{16}-N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p><strong>（3）方式 2</strong></p>
<p>方式 2 为自动重装初值的 <code>8 位</code>计数方式。工作方式 2 特别适合于用作较精确的脉冲信号发生器</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/3f5f24a5a236470387e536ed931e6950.webp" style="zoom:36%;" />
<p>计数初值与计数个数的关系为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">X=2^8-N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p><strong>（4）方式 3</strong></p>
<p>方式 3 只适用于<code>定时/计数器 T0</code>，定时器 T1 处于方式 3 时相当于 TR1=0， 停止计数。工作方式 3 将 T0 分成为两个独立的 8 位计数器 TL0 和 TH0。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/dcabfeb938774517bc5816db315b6200.png" style="zoom:40%;" />
<p>这几种工作方式中应用较多的是<code>方式 1 和方式 2</code>。<code>定时器</code>中通常使用定时器<code>方式 1</code>，<code>串口通信</code>中通常使用<code>方式 2</code></p>
<h3 id="计算定时-计数器初值"><strong>计算定时/计数器初值</strong></h3>
<p>12MHz晶振情况下，1个机器周期=1us，假如需要定时1ms则</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>1</mn><mi>m</mi><mi>s</mi><mi mathvariant="normal">/</mi><mn>1</mn><mi>u</mi><mi>s</mi><mo>=</mo><mn>1000</mn><mtext>次</mtext></mrow><annotation encoding="application/x-tex">1ms/1us=1000\text{次}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord">/1</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">1000</span><span class="mord text"><span class="mord cjk_fallback">次</span></span></span></span></span></span></p>
<p>溢出是65536，则用</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>65536</mn><mo>−</mo><mn>1000</mn><mo>=</mo><mn>64536</mn><mo>=</mo><mi>F</mi><mi>C</mi><mn>18</mn><mi>H</mi></mrow><annotation encoding="application/x-tex">65536-1000=64536=FC18H
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">65536</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64536</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">FC</span><span class="mord">18</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span></span></span></span></span></p>
<p>所以初值为  <code>THx=0XFC，TLx=0X18</code></p>
<p>开发板上使用的外部晶振不同，换算的初值是不一样的</p>
<p>我们开发板的晶振是 <code>11.0592M</code>，<code>时钟周期</code>就是 1/11059200，<code>机器周期</code>是 12/11059200，假如要定时 20ms，就是 0.02 秒，要经过 x 个机器周期得到 0.02 秒，我们来算一下 x*12/11059200=0.02，得到 x= 18432<br>
先给 <code>TH0 和 TL0 一个初始值</code>，让它们经过 18432 个机器周期后刚好达到 65536，也就是溢出，溢出后可以通过检测 TF0 的值得知，就刚好是 0.02 秒。那么初值 y = 65536 - 18432 = 47104，转成 16 进制就是 0xB800，也就是 TH0 = 0xB8，TL0 = 0x00</p>
<p><strong>小工具</strong></p>
<p>使用小工具进行换算不用手动算</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/72d9b4a4851f443bb4f9dde0978e6f2a.webp" style="zoom:33%;" />
<p><strong>也可以使用STC-ISP里面的定时器计算器</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/b51de9b5ea7647c199769bb9987671c8.webp" style="zoom: 50%;" />
<p>如果要实现很长时间的定时，比如定时 1 秒钟。可以通过初值设置定时 1ms，每当定时 1ms 结束后又重新赋初值，并且设定一个全局变量累计定时 1ms 的次数，当累计到 1000 次，表示已经定时 1 秒了。需要其他定时时间类似操作，这样我们就可以使用定时器来实现精确延时来替代之前的 delay 函数。</p>
<h3 id="定时器配置">定时器配置</h3>
<p>在使用定时器时，应该如何配置使其工作？其步骤如下（各步骤顺序可任意）：</p>
<ol>
<li>
<p>对 TMOD 赋值，以确定 T0 和 T1 的工作方式，如果使用定时器 0 即对 T0 配 置，如果使用定时器 1 即对 T1 配置</p>
</li>
<li>
<p>根据所要定时的时间计算初值,并将其写入 TH0、TL0 或 TH1、TL1</p>
</li>
<li>
<p>如果使用中断，则对 EA 赋值，开放定时器中断</p>
</li>
<li>
<p>使 TR0 或 TR1 置位，启动定时/计数器定时或计数</p>
</li>
<li>
<p>判断 TCON 寄存器的 TF0 位，监测定时器溢出情况</p>
</li>
</ol>
<h3 id="定时器程序">定时器程序</h3>
<blockquote>
<h4 id="定时器0控制LED-0-5-秒闪烁一次">定时器0控制LED 0.5 秒闪烁一次</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit LED2 = P0 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//记录T0溢出次数</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">1</span>;    <span class="comment">//A2到A0的值为110，则使Y6为低电平，则LEDS6为低电平，使三极管导通，点亮LED灯</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//选择为定时器0模式，工作方式1(为了不干扰T1定时器所以用|);如果是定时器1则把0x01改成0x10</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;		<span class="comment">//给定时器赋初值，定时1ms(使用STC-ISP里面的定时器计算器);如果是定时器1则把TH0改成TH1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;		<span class="comment">//如果是定时器1则把TL0改成TL1</span></span><br><span class="line">    TR0 = <span class="number">1</span>;			<span class="comment">//定时器0开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>)        <span class="comment">//如果溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;          <span class="comment">//清除溢出标志位</span></span><br><span class="line">            TL0 = <span class="number">0x66</span>;		<span class="comment">//重新赋值</span></span><br><span class="line">            TH0 = <span class="number">0xFC</span>;		<span class="comment">//重新赋值</span></span><br><span class="line">            count++;          <span class="comment">//TF0溢出一次计数次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">500</span>)   <span class="comment">//如果count = 500则代表溢出500次，500ms = 0.5s</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;      <span class="comment">//溢出次数归0</span></span><br><span class="line">            LED2 = !LED2;   <span class="comment">//LED2状态取反</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用定时器定时0-5秒控制LED流水灯流动">使用定时器定时0.5秒控制LED流水灯流动</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0 <span class="comment">//设置LED端口为P0</span></span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//记录T0溢出次数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> led_state  = <span class="number">0x01</span>; <span class="comment">//LED状态</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">1</span>;    <span class="comment">//A2到A0的值为110，则使Y6为低电平，则LEDS6为低电平，使三极管导通，点亮LED灯</span></span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//选择为定时器0模式，工作方式1(为了不干扰T1定时器所以用|);如果是定时器1则把0x01改成0x10</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;		<span class="comment">//给定时器赋初值，定时1ms(使用STC-ISP里面的定时器计算器);如果是定时器1则把TH0改成TH1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;		<span class="comment">//如果是定时器1则把TL0改成TL1</span></span><br><span class="line">    TR0 = <span class="number">1</span>;			<span class="comment">//定时器0开始计时</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>)        <span class="comment">//如果溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;          <span class="comment">//清除溢出标志位</span></span><br><span class="line">            TL0 = <span class="number">0x66</span>;				<span class="comment">//重新赋值</span></span><br><span class="line">            TH0 = <span class="number">0xFC</span>;				<span class="comment">//重新赋值</span></span><br><span class="line">            count++;          <span class="comment">//TF0溢出一次计数次数+1</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">500</span>) <span class="comment">//如果count = 500则代表溢出500次，500ms = 0.5s</span></span><br><span class="line">            &#123;</span><br><span class="line">                count = <span class="number">0</span>;             <span class="comment">//溢出次数归0</span></span><br><span class="line">                LED_PORT = ~led_state; <span class="comment">// LED按照led_state的状态取反输出</span></span><br><span class="line">                led_state &lt;&lt;= <span class="number">1</span>;       <span class="comment">// 左移一位</span></span><br><span class="line">                <span class="keyword">if</span>(led_state == <span class="number">0</span>)     <span class="comment">// 到达最高位后将 led_state 置 1</span></span><br><span class="line">                &#123;</span><br><span class="line">                    led_state = <span class="number">0x01</span>;    <span class="comment">//重新设置为第一个LED灯</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断">中断</h2>
<p>标准 51 单片机中控制中断的寄存器有两个，一个是<code>中断使能寄存器</code>，另一个是<code>中断优先级寄存器</code></p>
<h3 id="中断概念">中断概念</h3>
<p>中断是为使单片机具有对外部或内部随机发生的事件实时处理而设置的， 中断功能的存在，很大程度上提高了单片机处理外部或内部事件的能力。对于单片机来讲，<code>中断是指 CPU 在处理某一事件 A 时，发生了另一事件 B， 请求 CPU 迅速去处理(中断发生)；CPU 暂时停止当前的工作(中断响应)， 转去处理事件 B(中断服务)；待 CPU 将事件 B 处理完毕后，再回到原来事件 A 被中断的地方继续处理事件 A(中断返回)</code>，这一过程称为中断。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/9c2562e62936441092e66ef8c5496eb5.webp" style="zoom:50%;" />
<p>单片机在执行程序时其程序流程图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/316f45862e5f451c92e0c28a49143ede.webp" style="zoom:50%;" />
<p>引起 CPU 中断的根源称为<code>中断源</code>。中断源向 CPU 提出中断请求，CPU 暂时中断原来的事务 A，转去处理事件 B，对事件 B 处理完毕后，再回到原来被中断的地方(即断点)，称为中断返回。实现上述中断功能的部件称为<code>中断系统</code>(中断机构)。</p>
<p>CPU总是先响应<code>优先级别最高</code>的中断请求。如果 CPU 能够暂停对原来中断源的服务程序，转而去处理优先级更高的中断请求源，处理完以后，再回到原低级中断服务程序，这样的过程称为 <code>中断嵌套</code>。这样的中断系统称为 <code>多级中断系统</code>，没有中断嵌套功能的中断系统称为<code>单级中断系统</code>。</p>
<p><code>中断优点：</code></p>
<p><strong>1、分时操作</strong><br>
CPU 可以分时为多个I/O 设备服务，提高了计算机的利用率;</p>
<p><strong>2、实时响应</strong><br>
CPU 能够及时处理应用系统的随机事件，系统的实时性大大增强;</p>
<p><strong>3、可靠性高</strong><br>
CPU具有处理设备故障及掉电等突发性事件能力，从而使系统可靠性提高</p>
<h3 id="中断结构">中断结构</h3>
<p>STC89C5X 系列单片机提供了 8 个中断请求源，它们分别是：<code>外部中断 0(INT0)、外部中断 1(INT1)、外部中断 2(INT2)、外部中断 3(INT3)、定时器 0 中断、定时器 1 中断、定时器 2 中断、串口(UART)中断</code>。</p>
<p>注意：51 系列单片机一定有基本的 5 个中断，但不全有 8 个中断，需要查看芯片手册，通常我们使用的都是基本的 5 个中断：<code>INT0、INT1、定时器 0/1，串口中断</code>。所有的中断都具有四个中断优先级（基本型只有两个）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高优先级的中断请求可以打断低优先级的中断，反之，低优先级的中断请求不可以打断高优先级及同优先级的中断。</span><br><span class="line">当两个相同优先级的中断同时产生时，将由查询次序来决定系统先响应哪个中断。</span><br><span class="line">中断查询次序即为中断号，这个中断号在编程时非常重要，当中断来临时，只有中断号正确才能进入中断。</span><br></pre></td></tr></table></figure>
<p>STC89C5X 系列单片机的各个中断查询次序表如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/36dab1667f8d46f88828ce9c834ce12a.webp" style="zoom:40%;" />
<p>下面是51单片机均有的5个基本中断：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/1605ecbc927f44d9b5570deb7f43b446.webp" style="zoom:40%;" />
<p>①<code>INT0</code> 对应的是 <code>P3.2</code> 口的附加功能，可由 <code>IT0</code>(TCON.0)选择其为<code>低电平有效还是下降沿有效</code>。当 CPU 检测到 <code>P3.2</code> 引脚上出现<code>有效的中断信号</code>时，中断标志<code>IE0(TCON.1)置 1</code>，向 CPU 申请中断。</p>
<p>②<code>INT1</code> 对应的是 <code>P3.3</code> 口的附加功能，可由 <code>IT1</code>(TCON.2)选择其为<code>低电平有效还是下降沿有效</code>。当 CPU 检测到 <code>P3.3</code> 引脚上出现<code>有效的中断信号</code>时，中断标志 <code>IE1(TCON.3)置 1</code>,向 CPU 申请中断。</p>
<p>③<code>T0</code> 对应的是 <code>P3.4</code> 口的附加功能，<code>TF0</code>（TCON.5）,片内<code>定时/计数器 T0 溢出中断请求标志</code>。当定时/计数器 <code>T0 发生溢出</code>时，<code>置位 TF0</code>，并向 CPU 申请中断。</p>
<p>④<code>T1</code> 对应的是 <code>P3.5</code> 口的附加功能，<code>TF1</code>（TCON.7），片内<code>定时/计数器 T1 溢出中断请求标志</code>。当定时/计数器 <code>T1 发生溢出</code>时，<code>置位 TF1</code>，并向 CPU 申请中断。</p>
<p>⑤<code>RXD 和 TXD</code> 对应的是 <code>P3.0 和 P3.1</code> 口的附加功能，<code>RI</code>（SCON.0）或 <code>TI</code> （SCON.1），<code>串行口中断请求标志</code>。当串行口<code>接收</code>完一帧串行数据时<code>置位 RI</code> 或当串行口<code>发送</code>完一帧串行数据时<code>置位 TI</code>，向 CPU 申请中断。</p>
<h3 id="中断相关寄存器">中断相关寄存器</h3>
<h4 id="中断允许控制">中断允许控制</h4>
<p>CPU 对中断系统所有中断以及某个中断源的开放和屏蔽是由<code>中断允许寄存器 IE</code> 控制的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/1d7123008257414596c7d8446488be4a.webp" style="zoom: 33%;" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EX0(IE.0)：外部中断 0 允许位； </span><br><span class="line">ET0(IE.1)：定时/计数器 T0 中断允许位； </span><br><span class="line">EX1(IE.2)：外部中断 1 允许位； </span><br><span class="line">ET1(IE.3)：定时/计数器 T1 中断允许位； </span><br><span class="line">ES（IE.4)：串行口中断允许位； </span><br><span class="line">EA (IE.7)：CPU 中断允许（总允许）位。</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220927224910.jpg" style="zoom: 80%;" />
<h4 id="中断请求标志-TCON">中断请求标志 TCON</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/df5b77b6551c4296a21effebcfd29e1d.webp" style="zoom: 33%;" />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IT0（TCON.0），外部中断 0 触发方式控制位。 当 IT0=0 时，为电平触发方式。 当 IT0=1 时，为边沿触发方式（下降沿有效）。 </span><br><span class="line">IE0（TCON.1），外部中断 0 中断请求标志位。 </span><br><span class="line">IT1（TCON.2），外部中断 1 触发方式控制位。 </span><br><span class="line">IE1（TCON.3），外部中断 1 中断请求标志位。 </span><br><span class="line">TF0（TCON.5），定时/计数器 T0 溢出中断请求标志位。 </span><br><span class="line">TF1（TCON.7），定时/计数器 T1 溢出中断请求标志位。</span><br></pre></td></tr></table></figure>
<h4 id="中断优先级">中断优先级</h4>
<p>同一优先级中的中断申请不止一个时，则有中断优先权排队问题。同一优先级的中断优先权排队，由中断系统硬件确定的自然优先级形成，其排列如所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/e057d83d053f4ec89faec54d843cf66f.webp" style="zoom: 33%;" />
<h4 id="中断号">中断号</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/893408ff7c3145bd81e9ab5c4660791b.webp" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220927231958.jpg" style="zoom:80%;" />
<p>问：单片机又怎样找到这个中断函数呢？</p>
<p>靠的就是中断向量地址，所以 interrupt 后面中断函数编号的数字 x 就是根据中断向 量得出的，它的计算方法是 <code>x*8+3=向量地址</code></p>
<p>中断优先级有两种，一种是 <code>抢占优先级</code>，一种是 <code>固有优先级</code></p>
<p>抢占优先级寄存器：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221019095308.jpg" style="zoom:70%;" />
<h4 id="中断响应条件">中断响应条件</h4>
<p>①中断源有中断请求；<br>
②此中断源的中断允许位为 1；<br>
③CPU 开中断（即 EA=1）。<br>
以上三条同时满足时，CPU 才有可能响应中断。</p>
<p><strong>在使用中断时我们需要做什么呢？</strong></p>
<p>①你想使用的中断是哪个？选择相应的中断号；<br>
②你所希望的触发条件是什么？<br>
③你希望在中断之后干什么？</p>
<h3 id="外部中断配置">外部中断配置</h3>
<p>以外部中断 0 为例，如下：</p>
<p>主程序中需要有以下代码</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/35cf194db4594c2a93ed46b48f4dbd14.webp" style="zoom:50%;" />
<p>如果要配置的是<code>外部中断 1</code>，只需将 <code>EX0</code> 改为 <code>EX1</code>，<code>IT0</code> 改为 <code>IT1</code>，通常使用外部中断都是配置为<code>下降沿触发</code>，即 IT0=1</p>
<p>当触发中断后即会进入<code>中断服务函数</code>，外部中断 0 中断服务函数如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/3e5f950116a846f5934f389134371781.png" style="zoom:50%;" />
<p>在中断函数中 exti0 是函数名，可自定义，但必须符合 C 语言标识符定义规则，<code>interrupt 是一个关键字</code>，表示 51 单片机中断。后面的 <code>0 是中断号</code>，外部中断 0 中断号为 0，如果是外部中断 1，则中断号为 2</p>
<h2 id="数码管">数码管</h2>
<h3 id="数码管简介">数码管简介</h3>
<p>数码管是一种半导体发光器件，其基本单元是<code>发光二极管</code>。按发光二极管单元连接方式可分为<code>共阳极数码管</code>和<code>共阴极数码管</code></p>
<p><strong>共阳数码管</strong> 是指将<code>所有发光二极管的阳极接到一起形成公共阳极</code>(COM)的数码管，共阳数码管在应用时应将公共极 COM 接到+5V，当某一字段发光二极管的<code>阴极为低电平</code>时，相应字段就<code>点亮</code>，当某一字段的<code>阴极为高电平</code>时，相应字段就<code>不亮</code></p>
<p><strong>共阴数码管</strong> 是指将<code>所有发光二极管的阴极接到一起形成公共阴极</code>(COM)的数码管，共阴数码管在应用时应将公共极 COM 接到地线 GND 上，当某一字段发光二极管的<code>阳极为高电平</code>时，相应字段就<code>点亮</code>，当某一字段的<code>阳极为低电平</code>时，相应字段就<code>不亮</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/217fcff413b741fe9d84596889d3677f.webp" style="zoom: 50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f4eded5159394b4a88d68b28d11aec0f.webp" style="zoom: 50%;" />
<h3 id="数码表">数码表</h3>
<h4 id="共阴数码管码表">共阴数码管码表</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/bb3dbfeacf05457cbe25386d414f03e5.webp" style="zoom:67%;" />
<h4 id="共阳数码管码表">共阳数码管码表</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/940a73e91bda42df9689fd4e348bd0e6.webp" style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f2ae309462ea43f0853818fd6966fd66.webp" style="zoom:67%;" />
<p>从上述共阳和共阴码表中不难发现，它们的数据正好是<code>相互取反</code>的值。比如共阴数码管数字 0 段码：0x3f，其二进制是：0011 1111，取反后为：1100 0000， 转换成 16 进制即为 0XC0。其他段码依此类推。该段码数据由来，是将 a 段作为最低位，b 段作为次低位，其他按顺序类推，dp 段为最高位，共 8 位，正好和 51 单片机的一组端口数一样，因此可以直接使用某一组端口控制数码管的段选数据口，比如 P0 口</p>
<h3 id="数码管原理图">数码管原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230913172616.webp" style="zoom: 40%;" />
<p>我们开发板的所用的数码管都是<code>共阳数码管</code>，一共有 6 个</p>
<p>6 个数码管的 com 都是接到了正极上，和 LED 小灯电路一样，也是由 <code>74HC138</code> 控制三极管的导通来控制整个数码管的使能。先来看最右边的 DS1 这个数码管，原理图上可 以看出，控制 DS1 的三极管是 <code>Q17</code>，控制 Q17 的引脚是 <code>LEDS0</code>，对应到 74HC138 上边就是 U3 的 <code>Y0</code> 输出，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230913173247.webp" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926220312.jpg" style="zoom:80%;" />
<p>问：为什么数码管上边有 2 个 com 呢？</p>
<p>一方面是 2 个可以起到对称的效果，刚好是 10 个引脚，另外一个方面，公共端通过的电流较大，并联电路电流之和等于总电流，用2 个 com 可以把公共电流平均到 2 个引脚上去，降低单条线路承受的电流</p>
<p>数码管的 8 个段，我们直接当成 8 个 LED 小灯来控制，那就是 <code>a、b、c、d、e、f、g、dp</code></p>
<h3 id="数码管显示">数码管显示</h3>
<p><strong>静态显示</strong>：多位数码管依然可以静态显示，但是<code>显示时要么只显示一位数码管，要么多位同时显示相同内容</code>。当多位数码管应用于某一系统时，它们的“位选”是可独立控制的，而“段选”是连接在一起的，我们可以通过位选信号控制哪几个数码管亮，而在同一时刻，位选选通的所有数码管上显示的数字始终都是一样的，因为它们的段选是连接在一起的，送入所有数码管的段选信号都是相同的，所以它们显示的数字必定一样，数码管的这种显示方法叫做<code>静态显示</code>。</p>
<p><strong>动态显示</strong>：就是利用<code>减少段选线，分开位选线</code>，利用位选线不同时选择通断，改变段选数据来实现的。比如在第一次选中第一位数码管时，给段选数据 0， 下一次位选中第二位数码管时显示 1。为了在显示 1 的时候，0 不会消失（当然实际上是消失了），必须在人肉眼观察不到的时间里再次点亮第一次点亮的 0。 而这时就需要记住，人的肉眼正常情况下只能分辨变化超过 24ms 间隔的运动。 也就是说，在下一次点亮 0 这个数字的时间差不得大于 24ms。这时就会发现， 数码管点亮是在向右或者向左一位一位点亮，形成了动态效果。如果把间隔时间改长就能直接展现这一现象。</p>
<h3 id="静态数码管程序">静态数码管程序</h3>
<blockquote>
<h4 id="最右边的数码管显示0">最右边的数码管显示0</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">0</span>;    <span class="comment">//A2到A0的值为000，则使Y0为低电平，则LEDS0为低电平，使三极管导通，点亮最右边的数码管</span></span><br><span class="line">    ADDR1 = <span class="number">0</span>;    <span class="comment">//选择数码管 DS1</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LED_SMG_PORT = <span class="number">0xc0</span>;  <span class="comment">//点亮数码管段 a b c d e f 段，显示数字0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="最右边的数码管显示0-F">最右边的数码管显示0~F</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line">u8 code gsmg[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">&#125;; <span class="comment">//数码管段码0~F</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 count = <span class="number">0</span>;<span class="comment">//记录TF0溢出次数</span></span><br><span class="line">    u8 sec = <span class="number">0</span>;   <span class="comment">//记录经过的秒数</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">0</span>;    <span class="comment">//A2到A0的值为000，则使Y0为低电平，则LEDS0为低电平，使三极管导通，点亮最右边的数码管</span></span><br><span class="line">    ADDR1 = <span class="number">0</span>;    <span class="comment">//选择数码管 DS1</span></span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//选择为定时器0模式，工作方式1(为了不干扰T1定时器所以用|);如果是定时器1则把0x01改成0x10</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;		<span class="comment">//给定时器赋初值，定时1ms(使用STC-ISP里面的定时器计算器);如果是定时器1则把TH0改成TH1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;		<span class="comment">//如果是定时器1则把TL0改成TL1</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//定时器0开始计时</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(TF0 == <span class="number">1</span>)  <span class="comment">//如果溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            TF0 = <span class="number">0</span>;    <span class="comment">//清除溢出标志位</span></span><br><span class="line">            TL0 = <span class="number">0x66</span>; <span class="comment">//重新赋值</span></span><br><span class="line">            TH0 = <span class="number">0xFC</span>;</span><br><span class="line">            count++;     <span class="comment">//TF0溢出一次计数次数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1000</span>) <span class="comment">//如果count = 1000则代表溢出1000次，1000ms = 1s</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;      <span class="comment">//溢出次数归0</span></span><br><span class="line">            LED_SMG_PORT = gsmg[sec]; <span class="comment">//数码管端口输出数码管段码0~F</span></span><br><span class="line">            sec++;          <span class="comment">//秒数记录自加 1</span></span><br><span class="line">            <span class="keyword">if</span>(sec &gt;= <span class="number">16</span>)   <span class="comment">//当秒数超过 0x0F(15)后，重新从 0 开始</span></span><br><span class="line">            &#123;</span><br><span class="line">                sec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外一种写法</p>
</blockquote>
<p>将中断写成一个函数，这样子就不需要清除溢出标志位（TF0 = 0)，因为定时器<code>中断服务函数</code>会自动清除标志位，得加上ET0或者ET1 = 1，使能定时器中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line"></span><br><span class="line">u8 code gsmg[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">&#125;; <span class="comment">//数码管段码0~F</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;     <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ADDR2 = <span class="number">0</span>;      <span class="comment">//选择数码管 DS1</span></span><br><span class="line">    ADDR1 = <span class="number">0</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//为 T0 赋初值 0xFC66 ，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1 <span class="comment">//定时器0中断服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>; <span class="comment">//记录溢出次数</span></span><br><span class="line">    <span class="type">static</span> u8 sec = <span class="number">0</span>;    <span class="comment">//记录经过的秒数</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;           <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    count++;              <span class="comment">//溢出一次计数次数+1</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1000</span>)     <span class="comment">//如果count = 1000则代表溢出1000次，1000ms = 1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;           <span class="comment">//溢出次数归0</span></span><br><span class="line">        LED_PORT = gsmg[sec];<span class="comment">//数码管端口输出数码管段码0~F</span></span><br><span class="line">        sec++;                <span class="comment">//秒数记录自加 1</span></span><br><span class="line">        <span class="keyword">if</span>(sec &gt; <span class="number">15</span>)          <span class="comment">//当秒数超过 0x0F(15)后，重新从 0 开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            sec = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态数码管程序">动态数码管程序</h3>
<blockquote>
<h4 id="数码管计数，从0到999999">数码管计数，从0到999999</h4>
</blockquote>
<p>解决数码管抖动的方法就是用<code>中断</code></p>
<p>中断函数写好后， <code>每当满足中断条件而触发中断后，系统就会自动来调用中断函数</code>。比如平时一直在主程序 while(1)的循环中执行，假如程序有 100 行，当执 行到 50 行时，定时器溢出了，那么单片机就会立刻跑到中断函数中执行中断程序，中断程序执行完毕后再自动返回到刚才的第 50 行处继续执行下面的程序，这样 <code>就保证了动态显示间隔是固定的 1ms，不会因为程序执行时间不一致的原因导致数码管显示的抖动了</code></p>
<p>还有一点需要注意：<code>程序应该尽量减少全局变量的使用，能用局部变量代替尽量代替</code><br>
<code>全局变量在其定义后所有函数都能用，但是静态局部变量只能在一个函数里面用</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line">u8 code gsmg[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">&#125;; <span class="comment">//数码管段码0~F</span></span><br><span class="line"></span><br><span class="line">u8 Led_Buff[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管显示缓冲区，初值 0xFF 确保启动时都不亮</span></span><br><span class="line"></span><br><span class="line">u32 sec = <span class="number">0</span>;   <span class="comment">//记录经过的秒数(注意用long(u32)，因为999999超出int类型范围)</span></span><br><span class="line">u8 flag = <span class="number">0</span>;   <span class="comment">//1s定时标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//选择为定时器0模式，工作方式1(为了不干扰T1定时器所以用|);如果是定时器1则把0x01改成0x10</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;		<span class="comment">//给定时器赋初值，定时1ms(使用STC-ISP里面的定时器计算器);如果是定时器1则把TH0改成TH1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;		<span class="comment">//如果是定时器1则把TL0改成TL1</span></span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动定时器0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)  <span class="comment">//判断1s定时标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;    <span class="comment">//清除中断标志</span></span><br><span class="line">            sec++;</span><br><span class="line">            <span class="keyword">if</span>(sec &lt;= <span class="number">0</span>) <span class="comment">//如果秒数小于0则清0</span></span><br><span class="line">            &#123;</span><br><span class="line">                sec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Led_Buff[<span class="number">0</span>] = gsmg[sec % <span class="number">10</span>];           <span class="comment">//个位</span></span><br><span class="line">            Led_Buff[<span class="number">1</span>] = gsmg[sec / <span class="number">10</span> % <span class="number">10</span>];      <span class="comment">//十位</span></span><br><span class="line">            Led_Buff[<span class="number">2</span>] = gsmg[sec / <span class="number">100</span> % <span class="number">10</span>];     <span class="comment">//百位</span></span><br><span class="line">            Led_Buff[<span class="number">3</span>] = gsmg[sec / <span class="number">1000</span> % <span class="number">10</span>];    <span class="comment">//千位</span></span><br><span class="line">            Led_Buff[<span class="number">4</span>] = gsmg[sec / <span class="number">10000</span> % <span class="number">10</span>];   <span class="comment">//万位</span></span><br><span class="line">            Led_Buff[<span class="number">5</span>] = gsmg[sec / <span class="number">100000</span> % <span class="number">10</span>];  <span class="comment">//十万位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0</span><span class="params">()</span> interrupt 1  <span class="comment">//定时器0中断服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>;<span class="comment">//记录TF0溢出次数(注意不要使用u8类型否则数码管不会亮) 使用静态变量static,使计数次数不会清0</span></span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;     <span class="comment">//动态扫描的索引(同样使用静态变量)</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;		       <span class="comment">//重新加载初值</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;		       <span class="comment">//重新加载初值</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1000</span>)    <span class="comment">//中断1000次相当于 1000*1ms=1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;         <span class="comment">//溢出计数清0；</span></span><br><span class="line">        flag = <span class="number">1</span>;          <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只显示有效位</span></span><br><span class="line">    <span class="keyword">if</span>(sec &lt;= <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_Buff[<span class="number">1</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">2</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">3</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">4</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sec &lt;= <span class="number">99</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_Buff[<span class="number">2</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">3</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">4</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sec &lt;= <span class="number">999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_Buff[<span class="number">3</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">4</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sec &lt;= <span class="number">9999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_Buff[<span class="number">4</span>] = <span class="number">0xFF</span>;</span><br><span class="line">        Led_Buff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sec &lt;= <span class="number">99999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_Buff[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下代码完成数码管动态扫描刷新</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;  <span class="comment">//消影</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//switch语句那部分可以拿下面的代替，更加简洁</span></span><br><span class="line"><span class="comment">//以下代码完成数码管动态扫描刷新</span></span><br><span class="line"></span><br><span class="line">    SMG_PORT = <span class="number">0xFF</span>;	<span class="comment">//显示消影</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;	<span class="comment">//0xF8:1111 1000，低3位对应ADDR0~ADDR2，跟i又是对应关系</span></span><br><span class="line"><span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">	LED_SMG_PORT = LedBuff[i];</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">        i++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用定时器做一个时钟">使用定时器做一个时钟</h4>
</blockquote>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0</span></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 Led_Buff[<span class="number">6</span>] = &#123;<span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF,确保启动时都不亮</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;       <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="comment">//以下代码完成数码管动态刷新</span></span><br><span class="line">    SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SMG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SMG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_PORT	P0  <span class="comment">//宏定义数码管P0端口</span></span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 gsmg[<span class="number">10</span>];     <span class="comment">//前面加extern让函数可以在外部使用</span></span><br><span class="line"><span class="keyword">extern</span> u8 Led_Buff[<span class="number">6</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">()</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数名:  Time0_Init</span></span><br><span class="line"><span class="comment">  * @功能 : 定时器0中断配置函数，通过设置 TH 和 TL 即可确定定时时间(使用工具可确定TH 与TL的值)</span></span><br><span class="line"><span class="comment">  * @返回值: 无                                                   晶振频率为11.0592</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//开启总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;  <span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//定时器模式1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//定时1毫秒</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动定时器0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>;<span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line">u8 flag = <span class="number">0</span>; <span class="comment">//标志位</span></span><br><span class="line">u8 hour, min, sec; <span class="comment">//时分秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;  <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    Time0_Init(); <span class="comment">//调用定时器初始化函数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="comment">//判断1s定时标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;   <span class="comment">//清除中断标志</span></span><br><span class="line">            sec++;</span><br><span class="line">            <span class="keyword">if</span>(sec &gt;= <span class="number">60</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sec = <span class="number">0</span>;</span><br><span class="line">                min++;</span><br><span class="line">                <span class="keyword">if</span>(min &gt;= <span class="number">60</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = <span class="number">0</span>;</span><br><span class="line">                    hour++;</span><br><span class="line">                    <span class="keyword">if</span>(hour &gt;= <span class="number">24</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hour = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Led_Buff[<span class="number">0</span>] = gsmg[sec % <span class="number">10</span>]; <span class="comment">//秒个位</span></span><br><span class="line">        Led_Buff[<span class="number">1</span>] = gsmg[sec / <span class="number">10</span>]; <span class="comment">//秒十位</span></span><br><span class="line">        Led_Buff[<span class="number">2</span>] = gsmg[min % <span class="number">10</span>]; <span class="comment">//分个位</span></span><br><span class="line">        Led_Buff[<span class="number">3</span>] = gsmg[min / <span class="number">10</span>]; <span class="comment">//分十位</span></span><br><span class="line">        Led_Buff[<span class="number">4</span>] = gsmg[hour % <span class="number">10</span>];<span class="comment">//小时个位</span></span><br><span class="line">        Led_Buff[<span class="number">5</span>] = gsmg[hour / <span class="number">10</span>];<span class="comment">//时十位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1 <span class="comment">//定时器0中断服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>;  <span class="comment">//记录T0中断次数</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    count++;    <span class="comment">//中断计数+1</span></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1000</span>) <span class="comment">//中断1000次相当于1秒 (1000ms = 1s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;   <span class="comment">//溢出中断清0</span></span><br><span class="line">        flag = <span class="number">1</span>;    <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    smg_display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用定时器做一个秒表">使用定时器做一个秒表</h4>
</blockquote>
<p>第一个数码管显示毫秒的十位，第二个数码管显示百位，第三数码管显示秒的个位，第四个数码管显示秒的十位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>  u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_PORT	P0 <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 Led_Buff[<span class="number">4</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF</span></span><br><span class="line">u8 flag = <span class="number">0</span>;   <span class="comment">//标志位</span></span><br><span class="line">u8 sec = <span class="number">0</span>;    <span class="comment">//秒</span></span><br><span class="line">u16 msec = <span class="number">0</span>;  <span class="comment">//毫秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;       <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;       <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    EA = <span class="number">1</span>;          <span class="comment">//开启总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;    <span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;    <span class="comment">//定时器模式1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;      <span class="comment">//定时1毫秒</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;         <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;         <span class="comment">//启动定时器0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)  <span class="comment">//判断1ms定时标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;    <span class="comment">//清除中断标志</span></span><br><span class="line">            msec++;</span><br><span class="line">            <span class="keyword">if</span>(msec == <span class="number">1000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                msec = <span class="number">0</span>;</span><br><span class="line">                sec++;</span><br><span class="line">                <span class="keyword">if</span>(sec &gt;= <span class="number">60</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sec = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Led_Buff[<span class="number">0</span>] = gsmg[msec / <span class="number">10</span> % <span class="number">10</span>];  <span class="comment">//毫秒十位</span></span><br><span class="line">        Led_Buff[<span class="number">1</span>] = gsmg[msec / <span class="number">100</span> % <span class="number">10</span>]; <span class="comment">//毫秒百位</span></span><br><span class="line">        Led_Buff[<span class="number">2</span>] = gsmg[sec % <span class="number">10</span>];        <span class="comment">//秒个位</span></span><br><span class="line">        Led_Buff[<span class="number">3</span>] = gsmg[sec / <span class="number">10</span>];        <span class="comment">//秒十位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器0中断服务函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>; <span class="comment">//动态扫描的索引</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;</span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//以下代码完成数码管动态刷新</span></span><br><span class="line">    SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        SMG_PORT = Led_Buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        SMG_PORT = Led_Buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        SMG_PORT = Led_Buff[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        SMG_PORT = Led_Buff[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用定时器做一个秒表倒计时">使用定时器做一个秒表倒计时</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 Led_Buff[<span class="number">6</span>] = &#123;<span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF,确保启动时都不亮</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 flag = <span class="number">0</span>; <span class="comment">//定义标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;     <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    Time0_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == flag)   <span class="comment">//判断定时标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;   <span class="comment">//清除中断标志</span></span><br><span class="line">            SMG_Show(); <span class="comment">//调用数码管显示函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开启总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD |= <span class="number">0x02</span>; <span class="comment">//定时器0模式2</span></span><br><span class="line">    TH0 = <span class="number">0xA4</span>;   <span class="comment">//100us</span></span><br><span class="line">    TL0 = <span class="number">0xA4</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动定时器0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">()</span> <span class="comment">//数码管显示函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 min = <span class="number">1</span>;   <span class="comment">//定义初始值</span></span><br><span class="line">    <span class="type">static</span> u8 sec = <span class="number">30</span>;</span><br><span class="line">    <span class="type">static</span> u8 msec = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    Led_Buff[<span class="number">0</span>] = gsmg[msec % <span class="number">10</span>]; <span class="comment">//毫秒个位</span></span><br><span class="line">    Led_Buff[<span class="number">1</span>] = gsmg[msec / <span class="number">10</span>]; <span class="comment">//毫秒十位</span></span><br><span class="line">    Led_Buff[<span class="number">2</span>] = gsmg[sec % <span class="number">10</span>];  <span class="comment">//秒个位</span></span><br><span class="line">    Led_Buff[<span class="number">3</span>] = gsmg[sec / <span class="number">10</span>];  <span class="comment">//秒十位</span></span><br><span class="line">    Led_Buff[<span class="number">4</span>] = gsmg[min % <span class="number">10</span>];  <span class="comment">//分个位</span></span><br><span class="line">    Led_Buff[<span class="number">5</span>] = gsmg[min / <span class="number">10</span>];  <span class="comment">//分十位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msec &gt; <span class="number">0</span>) <span class="comment">//如果毫秒大于0</span></span><br><span class="line">    &#123;</span><br><span class="line">        msec--;    <span class="comment">//毫秒-1</span></span><br><span class="line">        <span class="keyword">if</span>((msec == <span class="number">0</span>) &amp;&amp; (sec &gt; <span class="number">0</span>)) <span class="comment">//在秒大于0的情况下毫秒才能在等于0的时候重新赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            msec = <span class="number">99</span>;</span><br><span class="line">            sec--; <span class="comment">//秒-1</span></span><br><span class="line">            <span class="keyword">if</span>((sec == <span class="number">0</span>) &amp;&amp; (min &gt; <span class="number">0</span>)) <span class="comment">//在分钟大于0的情况下秒才能在等于0的时候重新赋值</span></span><br><span class="line">            &#123;</span><br><span class="line">                sec = <span class="number">59</span>;</span><br><span class="line">                min--;</span><br><span class="line">                <span class="keyword">if</span>(min == <span class="number">0</span>) <span class="comment">//分=0</span></span><br><span class="line">                &#123;</span><br><span class="line">                    min = <span class="number">0</span>;   <span class="comment">//清零</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;  <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="comment">//以下代码完成数码管动态刷新</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 count = <span class="number">0</span>; <span class="comment">//记录中断次数</span></span><br><span class="line">    TH0 = <span class="number">0xA4</span>;  <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0xA4</span>;</span><br><span class="line">    count++;     <span class="comment">//中断计数+1</span></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">//溢出中断清0</span></span><br><span class="line">        flag = <span class="number">1</span>;  <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    SMG_Scan();    <span class="comment">//数码管扫描函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="数码管显示时钟，设置LED左右流水">数码管显示时钟，设置LED左右流水</h4>
</blockquote>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 Led_Buff[<span class="number">7</span>] = &#123;<span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF,确保启动时都不亮</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*时钟计数函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;       <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="comment">//以下代码完成数码管动态刷新</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = Led_Buff[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//点亮LED需要使能LEDS6</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*动态数码管显示函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 hour, min, sec; <span class="comment">//时分秒</span></span><br><span class="line">    Led_Buff[<span class="number">0</span>] = gsmg[sec % <span class="number">10</span>]; <span class="comment">//秒个位</span></span><br><span class="line">    Led_Buff[<span class="number">1</span>] = gsmg[sec / <span class="number">10</span>]; <span class="comment">//秒十位</span></span><br><span class="line">    Led_Buff[<span class="number">2</span>] = gsmg[min % <span class="number">10</span>]; <span class="comment">//分个位</span></span><br><span class="line">    Led_Buff[<span class="number">3</span>] = gsmg[min / <span class="number">10</span>]; <span class="comment">//分十位</span></span><br><span class="line">    Led_Buff[<span class="number">4</span>] = gsmg[hour % <span class="number">10</span>];<span class="comment">//小时个位</span></span><br><span class="line">    Led_Buff[<span class="number">5</span>] = gsmg[hour / <span class="number">10</span>];<span class="comment">//时十位</span></span><br><span class="line">    sec++;</span><br><span class="line">    <span class="keyword">if</span>(sec &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">        min++;</span><br><span class="line">        <span class="keyword">if</span>(min &gt;= <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min = <span class="number">0</span>;</span><br><span class="line">            hour++;</span><br><span class="line">            <span class="keyword">if</span>(hour &gt;= <span class="number">24</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hour = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SMG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SMG_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管P0端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 gsmg[<span class="number">10</span>];    <span class="comment">//前面加extern让函数可以在外部使用</span></span><br><span class="line"><span class="keyword">extern</span> u8 Led_Buff[<span class="number">7</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_show</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>LED.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Contral</span><span class="params">(u8 dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == dir)           <span class="comment">//左移 如果遇到==符号，要写成常量==变量，防止漏写了一个=，这样子容易找出bug（因为编译会报错）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x01</span>; <span class="comment">//LED状态</span></span><br><span class="line">       <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">        Led_Buff[<span class="number">6</span>] = ~Led_state;   <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &lt;&lt;= <span class="number">1</span>;            <span class="comment">//左移一位</span></span><br><span class="line">        <span class="keyword">if</span>(Led_state == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x01</span>;         <span class="comment">//左移到最高位后重新设置为第一个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == dir)                  <span class="comment">//右移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x80</span>;</span><br><span class="line">        Led_Buff[<span class="number">6</span>] = ~Led_state;   <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &gt;&gt;= <span class="number">1</span>;            <span class="comment">//右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(Led_state == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x80</span>;         <span class="comment">//右移到最低位后重新设置为第八个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LED.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Contral</span><span class="params">(u8 dir)</span>; <span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数名:  Time0_Init</span></span><br><span class="line"><span class="comment">  * @功能 : 定时器0中断配置函数，通过设置 TH 和 TL 即可确定定时时间(使用工具可确定TH 与TL的值)</span></span><br><span class="line"><span class="comment">  * @返回值: 无                                                   晶振频率为11.0592</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//开启总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;  <span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//定时器模式1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//定时1毫秒</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动定时器0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>;<span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line">u8 flag1 = <span class="number">0</span>; <span class="comment">//标志位</span></span><br><span class="line">u8 flag2 = <span class="number">0</span>; <span class="comment">//标志位</span></span><br><span class="line">u8 hour, min, sec; <span class="comment">//时分秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;  <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    Time0_Init(); <span class="comment">//调用定时器初始化函数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag1 == <span class="number">1</span>) <span class="comment">//判断1s定时标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag1 = <span class="number">0</span>;   <span class="comment">//清除中断标志</span></span><br><span class="line">            smg_show();  <span class="comment">//时钟计数函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag2 == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag2 = <span class="number">0</span>;</span><br><span class="line">            LED_Contral(<span class="number">1</span>); <span class="comment">//LED流水灯函数(0代表左移，1代表右移)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1 <span class="comment">//定时器0中断服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count1 = <span class="number">0</span>;  <span class="comment">//记录T0中断次数</span></span><br><span class="line">    <span class="type">static</span> u16 count2 = <span class="number">0</span>;  <span class="comment">//记录T0中断次数</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    count1++;    <span class="comment">//中断计数+1</span></span><br><span class="line">    <span class="keyword">if</span>(count1 == <span class="number">1000</span>) <span class="comment">//中断1000次相当于1秒 (1000ms = 1s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count1 = <span class="number">0</span>;   <span class="comment">//溢出中断清0</span></span><br><span class="line">        flag1 = <span class="number">1</span>;    <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    count2++;</span><br><span class="line">    <span class="keyword">if</span>(count2  == <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        flag2 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    smg_display(); <span class="comment">//动态数码管显示函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="红绿灯">红绿灯</h4>
</blockquote>
<p>左边 LED8 和 LED9 一起亮作为绿灯，中间 LED5 和 LED6 一起亮作为黄灯，右边 LED2 和 LED3 一起亮作为红灯，用数码管的低 2 位做倒计时，让 LED 和数码管同时参与工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管+独立LED显示缓冲区，初值0xFF</span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>;  <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;  <span class="comment">//T0 重载值的低字节</span></span><br><span class="line">bit flag = <span class="number">1</span>; <span class="comment">//1 秒定时标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Traffic_Refresh</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//使能数码管和 LED</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Config_Time0(<span class="number">1</span>); <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="comment">//每秒执行一次交通灯刷新</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            Traffic_Refresh(); <span class="comment">//调用交通灯显示刷新函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 交通灯显示刷新函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Traffic_Refresh</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 color = <span class="number">2</span>; <span class="comment">//颜色索引：0-绿色  1-黄色  2-红色</span></span><br><span class="line">    <span class="type">static</span> u8 time = <span class="number">0</span>;  <span class="comment">//倒计时定时器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == time) <span class="comment">//倒计时到 0 时，切换交通灯</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(color) <span class="comment">//LED8/9 代表绿灯，LED5/6 代表黄灯，LED2/3 代表红灯</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            color = <span class="number">1</span>;</span><br><span class="line">            time = <span class="number">5</span>;</span><br><span class="line">            SMG_BUFF[<span class="number">6</span>] = <span class="number">0xE7</span>;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//切换到黄色，亮5秒，LED5、6亮(1110 0111 --&gt; 0xE7)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            color = <span class="number">2</span>;</span><br><span class="line">            time = <span class="number">30</span>;</span><br><span class="line">            SMG_BUFF[<span class="number">6</span>] = <span class="number">0xFC</span>;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//切换到红色，亮30秒，LED2、3亮(1111 1100 --&gt; 0xFC)</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            color = <span class="number">0</span>;</span><br><span class="line">            time = <span class="number">15</span>;</span><br><span class="line">            SMG_BUFF[<span class="number">6</span>] = <span class="number">0x3F</span>;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//切换到绿色，亮15秒，LED8、9亮(0011 1111 --&gt; 0x3F)</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//倒计时未到 0 时，递减其计数值</span></span><br><span class="line">        time--;</span><br><span class="line">    SMG_BUFF[<span class="number">0</span>] = gsmg[time % <span class="number">10</span>]; <span class="comment">//倒计时数值个位显示</span></span><br><span class="line">    SMG_BUFF[<span class="number">1</span>] = gsmg[time / <span class="number">10</span>]; <span class="comment">//倒计时数值十位显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//缓冲区中索引位置的数据送到数码管端口</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">6</span>)  <span class="comment">//索引递增循环，遍历整个缓冲区，由于加了LED显示，点亮LED需要使能LEDS6,所以i小于6不是小于5</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，完成 LED 扫描和秒定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>; <span class="comment">//1 秒定时计数</span></span><br><span class="line">    TH0 = T0RH;           <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Smg_Scan();           <span class="comment">//LED 扫描显示</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">1000</span>)     <span class="comment">//1秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="number">1</span>;         <span class="comment">//1秒定时标志置1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点阵">点阵</h2>
<p>点阵 LED 显示屏作为一种现代电子媒体，具有灵活的显示面积（可任意分割和拼装）、 高亮度、长寿命、数字化、实时性等特点，应用非常广泛，一个 8*8 的点阵就是由 64 个 LED 小灯组成</p>
<p>点阵 LED 最小单元如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20213349.webp" style="zoom: 33%;" />
<h3 id="LED点阵原理图">LED点阵原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20214620.webp" style="zoom:50%;" />
<p>在图中大方框外侧的就是 <code>点阵 LED</code> 的引脚号，<code>左侧</code>的 8 个引脚是接的内部 <code>LED 的阳极</code>，<code>上侧</code>的 8 个引脚接的是内部 <code>LED 的阴极</code>。那么如果我们把 9 脚置成高电平、13 脚置成低电平的话，左上角的那个 LED 小灯就会亮了。特别注意，控制点阵左侧引脚的 <code>74HC138</code> 是原理图上的 <code>U4</code>，8 个引脚自上而下依次由 U4 的 Y0～Y7 输出来控制</p>
<h3 id="74HC138原理图">74HC138原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20213926.webp" style="zoom:50%;" />
<p>由于<code>ENLED</code>接的是<code>5号</code>管脚，<code>低电平使能</code>，<code>ADDR3</code>接在<code>4号</code>管脚，同样也是<code>低电平使能</code>，所以要<code>驱动U4</code>的话，得让<code>ENLED和ADDR3都为0</code>，这样子芯片才能正常工作，这样子不会使U3驱动，所以各个功能模块互不打扰</p>
<h3 id="取字模软件">取字模软件</h3>
<p>双击打开该软件，首先选择“基本操作-&gt;新建图像”，设置图像的宽度和高度为8，点击确定后将在显示窗口出现一个8x8的白色格子，这个就类似于8x8LED 点阵，具体操作如下</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/22f71d4269a245639a8558f79e1fb483.webp" style="zoom: 30%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/39ebc5e1da884edf8e8f58586a5692f7.webp" style="zoom: 30%;" />
<p>可以看到上图 8*8 点阵区域非常小，我们可以将其放大，选择“模拟动画”， 后点击“放大格点”，<br>
如下所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/5d802ea9148c4d8e91cb3c05156f65d8.webp" style="zoom:30%;" />
<p>由于取模软件是把<code>黑色取为 1，白色取为 0</code>，但我们点阵是 <code>1 对应 LED 熄灭，0 对应 LED 点亮</code>，所以我们要选“<code>修改图像</code>”菜单里的“<code>黑白反显图像</code>”这个选项，再点击“基本操作”菜单里边的“保存图像”可以把我们设计好的图片进行保存</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20222517.webp" style="zoom:36%;" />
<p>然后设置取模数据的取模方式等内容，选择“参数设置”后点击“其他 选项”，具体操作如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20222737.webp" style="zoom:36%;" />
<p>这里的选项，要结合原理图，可以看到 <code>P0</code> 口控制的是<code>一行</code>，所以用“<code>横向取模</code>”，如果控制的是一列，就要选“纵向取模”。选中“字节倒序”这个选项，是因为原理图<code>左边是低位 DB0，右边是高位 DB7</code>，所以是<code>字节倒序</code>，点确定后，选择“取模方式”这个菜单，点一下“<code>C51 格式</code>”后，在“<code>点阵生成区</code>”自动产生了 8 个字节的数据，这 8 个字节的数据就是取出来的“模”，如图所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-17%20223115.webp" style="zoom:36%;" />
<p>在这个图片里，<code>黑色</code>的一个格子表示一位<code>二进制的 1</code>，<code>白色</code>的一个格子表示一位<code>二进制的 0</code>。第一个字节是0xFF，其实就是这个 8*8 图形的第一行，全黑就是 0xFF；第二个字节是 0x99，<code>低位在左边，高位在右边</code></p>
<h3 id="程序">程序</h3>
<blockquote>
<h4 id="点亮一个点">点亮一个点</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E1</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E2</span></span><br><span class="line">sbit LED = P0 ^ <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;</span><br><span class="line">    ADDR3 = <span class="number">0</span>;  <span class="comment">//使能U4使之正常输出</span></span><br><span class="line">    ADDR2 = <span class="number">0</span>;</span><br><span class="line">    ADDR1 = <span class="number">0</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    LED = <span class="number">0</span>;   <span class="comment">//向P0.0写入0来点亮左上角的一个点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="点亮一行">点亮一行</h4>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接操作 P0=0x00 即可</span></span><br></pre></td></tr></table></figure>
<p>一个数码管就是 8 个 LED 小灯，一个点阵是 64 个 LED 小灯。同样的道理，我们还可以把一个点阵理解成是 8 个数码管。 我们可以利用<code>定时器中断和数码管动态显示</code>的原理来把这个点阵全部点亮</p>
<blockquote>
<h4 id="点亮全部">点亮全部</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E1</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//使能 U4，选择 LED 点阵</span></span><br><span class="line">    ADDR3 = <span class="number">0</span>;     <span class="comment">//使能U4使之正常输出</span></span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//为 T0 赋初值 0xFC67，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);      <span class="comment">//程序停在这里，等待定时器中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;  <span class="comment">//动态扫描的索引</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;       <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="comment">//以下代码完成 LED 点阵动态扫描刷新</span></span><br><span class="line">    LED_PORT = <span class="number">0xFF</span>;  <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_PORT = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="显示爱心">显示爱心</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line">u8 code image[] = &#123;<span class="number">0xFF</span>, <span class="number">0x99</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>, <span class="number">0xE7</span>&#125;; <span class="comment">//显示爱心的字模表</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E1</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//使能 U4，选择 LED 点阵</span></span><br><span class="line">    ADDR3 = <span class="number">0</span>;     <span class="comment">//使能U4使之正常输出</span></span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//为 T0 赋初值 0xFC66 ，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);      <span class="comment">//程序停在这里，等待定时器中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;  <span class="comment">//动态扫描的索引</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;       <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="comment">//以下代码完成 LED 点阵动态扫描刷新</span></span><br><span class="line">    LED_PORT = <span class="number">0xFF</span>;  <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_PORT = image[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点阵的动画显示">点阵的动画显示</h3>
<p>点阵的动画显示，就是对多张图片分别进行取模，使用程序算法巧妙的切换图片， 多张图片组合起来就成了一段动画了，我们所看到的动画片、游戏等等，它们的基本原理也都是这样的</p>
<h4 id="点阵的纵向移动（向上移动）">点阵的纵向移动（向上移动）</h4>
<p>我们要让点阵显示一个 I ❤ U 的动画，首先我们要把这个图形用取模软件画出来，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-18%20000337.webp" style="zoom:40%;" />
<p>这张图片共有 <code>40</code> 行，<code>每 8 行</code>组成一张点阵图片，并且每向上移动一行就出现了一张新图片，一共组成了 <code>32</code> 张图片</p>
<p>用一个变量 <code>index</code> 来代表每张图片的<code>起始位置</code>，每次从 index 起始<code>向下数 8 行</code>代表了<code>当前的图片</code>，<code>250ms</code> 改变一张图片，然后不停的<code>动态刷新</code>，这样图片就变成动画了。首先我们要对显示的图片进行<code>横向取模</code>，虽然这是 <code>32</code> 张图片，由于我们每一张图片都是和下一行连续的，所以实际的取模值只需要 <code>40</code> 个字节就可以完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向上移动是默认的，刷新索引是++的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0	<span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line">u8 code image[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0xC3</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xC3</span>, <span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0x99</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>, <span class="number">0xE7</span>, <span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>, <span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span></span><br><span class="line">&#125;; <span class="comment">//图片的字模表</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>; <span class="comment">//A0</span></span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>; <span class="comment">//A1</span></span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>; <span class="comment">//A2</span></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>; <span class="comment">//E3</span></span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>; <span class="comment">//E1 + E2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//使能 U4，选择 LED 点阵</span></span><br><span class="line">    ADDR3 = <span class="number">0</span>;     <span class="comment">//使能U4使之正常输出</span></span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//为 T0 赋初值 0xFC66 ，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);      <span class="comment">//程序停在这里，等待定时器中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器 0 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;     <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="type">static</span> u8 tmr = <span class="number">0</span>; <span class="comment">//250ms软件定时器</span></span><br><span class="line">    <span class="type">static</span> u8 index = <span class="number">0</span>; <span class="comment">//图片刷新索引</span></span><br><span class="line"></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;       <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="comment">//以下代码完成 LED 点阵动态扫描刷新</span></span><br><span class="line">    LED_PORT = <span class="number">0xFF</span>;  <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_PORT = image[index + <span class="number">6</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_PORT = image[index + <span class="number">7</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下代码完成每250ms改变一帧图像</span></span><br><span class="line">    tmr++;</span><br><span class="line">    <span class="keyword">if</span>(tmr &gt;= <span class="number">250</span>)  <span class="comment">//达到250ms时改变一次图片索引</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmr = <span class="number">0</span>;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">32</span>) <span class="comment">//图片索引达到32后归零</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向下移动-纵向">向下移动(纵向)</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向下移的话只需改数组顺序即可(即U放第一I放最后中间不用动)</span></span><br><span class="line"><span class="comment">//然后使图片刷新索引--即可</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> code image[] = &#123;  <span class="comment">//图片的字模表</span></span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x81</span>,<span class="number">0xC3</span>,<span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0x99</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,<span class="number">0xC3</span>,<span class="number">0xE7</span>,<span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0xC3</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xC3</span>,<span class="number">0xFF</span>,</span><br><span class="line">    <span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> index = <span class="number">31</span>;  <span class="comment">//图片刷新索引</span></span><br><span class="line"> <span class="keyword">if</span> (tmr &gt;= <span class="number">250</span>)  <span class="comment">//达到250ms时改变一次图片索引</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>)  <span class="comment">//图片索引31~0递减循环</span></span><br><span class="line">            index = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            index--;	<span class="comment">//注意这里要判断了再--防止内存溢出</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="向左移动-横向">向左移动(横向)</h4>
<p>我们在进行硬件电路设计的时候，也得充分考虑软件编程的方便性。因为我们的程序是用 P0 来控制点阵的整行，所以对于我们这样的电路设计，上下移动程序是比较好编写的。那如果我们设计电路的时候知道我们的图形要左右移动，那我们设计电路画板子的时候就要尽可能的把点阵横过来放，有利于我们编程方便，减少软件工作量</p>
<p>利用<code>二维数组</code>实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220928211407.png" alt=""></p>
<p>最上面的图形是横向连在一起的效果，而实际上我们要把它分解为 <code>30 个帧</code>， 每帧图片单独取模，取出来都是 <code>8</code> 个字节的数据，一共就是 <code>30*8</code> 个数据，我们用一个二维数组来存储它们(取模软件里还是选横向，字节倒序)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>  u8;  <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT	P0	     <span class="comment">//宏定义LED和数码管的端口为P0</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">     u8 code image[<span class="number">30</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>&#125;,  <span class="comment">//动画帧1</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x7F</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0xFF</span>,<span class="number">0x7F</span>&#125;,  <span class="comment">//动画帧2</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x3F</span>,<span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0x7F</span>,<span class="number">0x3F</span>&#125;,  <span class="comment">//动画帧3</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x1F</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x1F</span>&#125;,  <span class="comment">//动画帧4</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x0F</span>,<span class="number">0x9F</span>,<span class="number">0x9F</span>,<span class="number">0x9F</span>,<span class="number">0x9F</span>,<span class="number">0x9F</span>,<span class="number">0x0F</span>&#125;,  <span class="comment">//动画帧5</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x87</span>,<span class="number">0xCF</span>,<span class="number">0xCF</span>,<span class="number">0xCF</span>,<span class="number">0xCF</span>,<span class="number">0xCF</span>,<span class="number">0x87</span>&#125;,  <span class="comment">//动画帧6</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xC3</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xE7</span>,<span class="number">0xC3</span>&#125;,  <span class="comment">//动画帧7</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xE1</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0xF3</span>,<span class="number">0xF3</span>,<span class="number">0xE1</span>&#125;,  <span class="comment">//动画帧8</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x70</span>,<span class="number">0x39</span>,<span class="number">0x39</span>,<span class="number">0x39</span>,<span class="number">0x79</span>,<span class="number">0xF9</span>,<span class="number">0xF0</span>&#125;,  <span class="comment">//动画帧9</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x38</span>,<span class="number">0x1C</span>,<span class="number">0x1C</span>,<span class="number">0x1C</span>,<span class="number">0x3C</span>,<span class="number">0x7C</span>,<span class="number">0xF8</span>&#125;,  <span class="comment">//动画帧10</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x9C</span>,<span class="number">0x0E</span>,<span class="number">0x0E</span>,<span class="number">0x0E</span>,<span class="number">0x1E</span>,<span class="number">0x3E</span>,<span class="number">0x7C</span>&#125;,  <span class="comment">//动画帧11</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xCE</span>,<span class="number">0x07</span>,<span class="number">0x07</span>,<span class="number">0x07</span>,<span class="number">0x0F</span>,<span class="number">0x1F</span>,<span class="number">0x3E</span>&#125;,  <span class="comment">//动画帧12</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x67</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x07</span>,<span class="number">0x0F</span>,<span class="number">0x9F</span>&#125;,  <span class="comment">//动画帧13</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x33</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x03</span>,<span class="number">0x87</span>,<span class="number">0xCF</span>&#125;,  <span class="comment">//动画帧14</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x99</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,<span class="number">0xC3</span>,<span class="number">0xE7</span>&#125;,  <span class="comment">//动画帧15</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xCC</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xC0</span>,<span class="number">0xE1</span>,<span class="number">0xF3</span>&#125;,  <span class="comment">//动画帧16</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xE6</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0xE0</span>,<span class="number">0xF0</span>,<span class="number">0xF9</span>&#125;,  <span class="comment">//动画帧17</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x73</span>,<span class="number">0x60</span>,<span class="number">0x60</span>,<span class="number">0x60</span>,<span class="number">0x70</span>,<span class="number">0x78</span>,<span class="number">0xFC</span>&#125;,  <span class="comment">//动画帧18</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x39</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x38</span>,<span class="number">0x3C</span>,<span class="number">0x7E</span>&#125;,  <span class="comment">//动画帧19</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x9C</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x9C</span>,<span class="number">0x1E</span>,<span class="number">0x3F</span>&#125;,  <span class="comment">//动画帧20</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xCE</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xCE</span>,<span class="number">0x0F</span>,<span class="number">0x1F</span>&#125;,  <span class="comment">//动画帧21</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x67</span>,<span class="number">0x66</span>,<span class="number">0x66</span>,<span class="number">0x66</span>,<span class="number">0x67</span>,<span class="number">0x07</span>,<span class="number">0x0F</span>&#125;,  <span class="comment">//动画帧22</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0x33</span>,<span class="number">0x03</span>,<span class="number">0x87</span>&#125;,  <span class="comment">//动画帧23</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x99</span>,<span class="number">0x81</span>,<span class="number">0xC3</span>&#125;,  <span class="comment">//动画帧24</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xCC</span>,<span class="number">0xC0</span>,<span class="number">0xE1</span>&#125;,  <span class="comment">//动画帧25</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xE6</span>,<span class="number">0xE6</span>,<span class="number">0xE6</span>,<span class="number">0xE6</span>,<span class="number">0xE6</span>,<span class="number">0xE0</span>,<span class="number">0xF0</span>&#125;,  <span class="comment">//动画帧26</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xF3</span>,<span class="number">0xF3</span>,<span class="number">0xF3</span>,<span class="number">0xF3</span>,<span class="number">0xF3</span>,<span class="number">0xF0</span>,<span class="number">0xF8</span>&#125;,  <span class="comment">//动画帧27</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xF9</span>,<span class="number">0xF9</span>,<span class="number">0xF9</span>,<span class="number">0xF9</span>,<span class="number">0xF9</span>,<span class="number">0xF8</span>,<span class="number">0xFC</span>&#125;,  <span class="comment">//动画帧28</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xFC</span>,<span class="number">0xFC</span>,<span class="number">0xFC</span>,<span class="number">0xFC</span>,<span class="number">0xFC</span>,<span class="number">0xFC</span>,<span class="number">0xFE</span>&#125;,  <span class="comment">//动画帧29</span></span><br><span class="line">    &#123;<span class="number">0xFF</span>,<span class="number">0xFE</span>,<span class="number">0xFE</span>,<span class="number">0xFE</span>,<span class="number">0xFE</span>,<span class="number">0xFE</span>,<span class="number">0xFE</span>,<span class="number">0xFF</span>&#125;   <span class="comment">//动画帧30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//使能U4，选择LED点阵</span></span><br><span class="line">    ADDR3 = <span class="number">0</span>;</span><br><span class="line">    TMOD = <span class="number">0x01</span>;  <span class="comment">//设置T0为模式1</span></span><br><span class="line">    TH0  = <span class="number">0xFC</span>;  <span class="comment">//为T0赋初值0xFC67，定时1ms</span></span><br><span class="line">    TL0  = <span class="number">0x66</span>;</span><br><span class="line">    ET0  = <span class="number">1</span>;     <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0  = <span class="number">1</span>;     <span class="comment">//启动T0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InterruptTimer0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;  <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="type">static</span> u8 tmr = <span class="number">0</span>;  <span class="comment">//250ms软件定时器</span></span><br><span class="line">    <span class="type">static</span> u8 index = <span class="number">0</span>;  <span class="comment">//图片刷新索引</span></span><br><span class="line"></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;  <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="comment">//以下代码完成LED点阵动态扫描刷新</span></span><br><span class="line">    LED_PORT = <span class="number">0xFF</span>;   <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">0</span>; i++; LED_PORT=image[index][<span class="number">0</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">1</span>; i++; LED_PORT=image[index][<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">0</span>; i++; LED_PORT=image[index][<span class="number">2</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: ADDR2=<span class="number">0</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">1</span>; i++; LED_PORT=image[index][<span class="number">3</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">0</span>; i++; LED_PORT=image[index][<span class="number">4</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">0</span>; ADDR0=<span class="number">1</span>; i++; LED_PORT=image[index][<span class="number">5</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">0</span>; i++; LED_PORT=image[index][<span class="number">6</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: ADDR2=<span class="number">1</span>; ADDR1=<span class="number">1</span>; ADDR0=<span class="number">1</span>; i=<span class="number">0</span>; LED_PORT=image[index][<span class="number">7</span>]; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下代码完成每250ms改变一帧图像</span></span><br><span class="line">    tmr++;</span><br><span class="line">    <span class="keyword">if</span> (tmr &gt;= <span class="number">250</span>)  <span class="comment">//达到250ms时改变一次图片索引</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmr = <span class="number">0</span>;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">30</span>)  <span class="comment">//图片索引达到30后归零</span></span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向右移动-横向">向右移动(横向)</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码跟左移一样，只需把模的数组生成时把 <span class="string">&quot;字节倒序&quot;</span> 关闭了重新生成即可</span><br></pre></td></tr></table></figure>
<h3 id="0-9的模">0~9的模</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> code image[<span class="number">11</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x99</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字0</span></span><br><span class="line">    &#123;<span class="number">0xEF</span>, <span class="number">0xE7</span>, <span class="number">0xE3</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字1</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0x9D</span>, <span class="number">0x87</span>, <span class="number">0xC3</span>, <span class="number">0xF9</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>&#125;,  <span class="comment">//数字2</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0x9D</span>, <span class="number">0xC7</span>, <span class="number">0xC7</span>, <span class="number">0x9D</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字3</span></span><br><span class="line">    &#123;<span class="number">0xCF</span>, <span class="number">0xC7</span>, <span class="number">0xC3</span>, <span class="number">0xC9</span>, <span class="number">0xC9</span>, <span class="number">0x81</span>, <span class="number">0xCF</span>, <span class="number">0xCF</span>&#125;,  <span class="comment">//数字4</span></span><br><span class="line">    &#123;<span class="number">0x81</span>, <span class="number">0xC1</span>, <span class="number">0xF9</span>, <span class="number">0xC3</span>, <span class="number">0x87</span>, <span class="number">0x9D</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字5</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0xF9</span>, <span class="number">0xC1</span>, <span class="number">0x81</span>, <span class="number">0x99</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字6</span></span><br><span class="line">    &#123;<span class="number">0x81</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0xCF</span>, <span class="number">0xCF</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>, <span class="number">0xE7</span>&#125;,  <span class="comment">//数字7</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0x99</span>, <span class="number">0xC3</span>, <span class="number">0xC3</span>, <span class="number">0x99</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>&#125;,  <span class="comment">//数字8</span></span><br><span class="line">    &#123;<span class="number">0xC3</span>, <span class="number">0x81</span>, <span class="number">0x99</span>, <span class="number">0x81</span>, <span class="number">0x83</span>, <span class="number">0x9F</span>, <span class="number">0x83</span>, <span class="number">0xC1</span>&#125;,  <span class="comment">//数字9</span></span><br><span class="line">    &#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;,  <span class="comment">//全亮</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="按键">按键</h2>
<p>常用的按键电路有两种形式，<code>独立式按键</code>和<code>矩阵式按键</code></p>
<h3 id="独立按键">独立按键</h3>
<p>原理图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20122513.webp" style="zoom: 40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20122737.webp" style="zoom:40%;" />
<p>当按键 K1 按下时，+5V 通过电阻 R1 然后再通过按键 K1 最终进入 GND 形成一条<code>通路</code>，那么这条线路的全部电压都加到了 R1 这个电阻上， KeyIn1 这个引脚就是个<code>低电平</code>。当松开按键后，线路断开，就不会有电流通过，那么 KeyIn1 和+5V 就应该是等电位，是一个<code>高电平</code>。我们就可以通过 KeyIn1 这个 IO 口的<code>高低电平</code>来判断是否有按键按下。<code>低电平代表按键按下，高电平代表按键弹起 </code></p>
<p>按键是接到了 <code>P2</code> 口上，P2 口上电默认是<code>准双向 IO 口</code>\</p>
<p>准双向 IO 口的电路，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20124143.webp" style="zoom:33%;" />
<p>我们要读取外部按键信号的时候，单片机必须先给该引脚写“1”，也就是<code>高电平</code>，这样我们才能正确读取到外部按键信号，这种具有上拉的准双向 IO 口，如果要正常读取外部信号的状态，必须首先得保证自己<code>内部输出的是 1</code>，如果内部输出 0，则无论外部信号是 1 还是 0，这个引脚读进来的都是 0</p>
<h3 id="矩阵按键">矩阵按键</h3>
<p>如果需要使用很多的按键时，做成独立按键会大量占用 IO 口， 所以一般都会引入矩阵按键</p>
<p>原理图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20124615.webp" style="zoom:40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20122737.webp" style="zoom:50%;" />
<p>如果 KeyOut1 输出一个<code>低电平</code>，KeyOut1 就相当于是 GND，这时候 KeyOut2、 KeyOut3、KeyOut4 都必须输出<code>高电平</code>，<code>它们都输出高电平才能保证与它们相连的三路按键不会对这一路产生干扰</code></p>
<p>按键消抖</p>
<p>通常按键所用的开关都是机械弹性开关，当机械触点断开、闭合时，由于机械触点的弹性作用，一个按键开关在闭合时不会马上就稳定的接通，在断开时也不会一下子彻底断开， 而是在闭合和断开的瞬间伴随了一连串的抖动</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20144910.webp" style="zoom:33%;" />
<p>抖动时间是由按键的机械特性决定的，一般都会在 10ms 以内，为了确保程序对按键的一次闭合或者一次断开只响应一次，必须进行按键的<code>消抖处理</code>。 当检测到按键状态变化时，不是立即去响应动作，而是先等待闭合或断开稳定后再进行处理。 按键消抖可分为<code>硬件消抖</code>和<code>软件消抖</code>。在绝大多数情况下，我们是用软件即程序来实现消抖的。最简单的消抖原理，就是当检测到按键状态变化后，先等待一个 <code>10ms 左右的延时时间</code>，让抖动消失后再进行一次按键状 检测，如果与刚才检测到的状态相同，就可以确认按键已经稳定的动作</p>
<h3 id="程序-2">程序</h3>
<blockquote>
<h4 id="按键按一次，数码管数值-1（使用Delay函数消抖）">按键按一次，数码管数值+1（使用Delay函数消抖）</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0 <span class="comment">//宏定义LED与数码管端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_PORT	P2     <span class="comment">//宏定义按键端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KeyIn2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 code gsmg[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                  <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">                 &#125;; <span class="comment">//数码管显示字符转换表</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit backup = <span class="number">1</span>; <span class="comment">//按键值备份，保存前一次的扫描值（bit 型是 1 位数据，51单片机特殊的变量类型）</span></span><br><span class="line">    bit keybuf = <span class="number">1</span>; <span class="comment">//按键值暂存，临时保存按键的扫描值</span></span><br><span class="line">    u8 count = <span class="number">0</span>;   <span class="comment">//按键计数，记录按键按下的次数</span></span><br><span class="line"></span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//选择数码管 DS1 进行显示</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    ADDR2 = <span class="number">0</span>;</span><br><span class="line">    ADDR1 = <span class="number">0</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    KEY_PORT = <span class="number">0xF7</span>; <span class="comment">//P2.3 置 0，即 KeyOut1 输出低电平</span></span><br><span class="line">    LED_SMG_PORT = gsmg[count]; <span class="comment">//显示按键次数初值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        keybuf = KeyIn1;  <span class="comment">//把当前扫描值暂存</span></span><br><span class="line">        <span class="keyword">if</span>(keybuf != backup) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            Delay_ms(<span class="number">10</span>);      <span class="comment">//延时大约 10ms，按键消抖</span></span><br><span class="line">            <span class="keyword">if</span>(keybuf == KeyIn1) <span class="comment">//判断扫描值有没有发生改变，即按键抖动</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup == <span class="number">0</span>)   <span class="comment">//如果前次值为 0，则说明当前是弹起动作</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count++;        <span class="comment">//按键次数+1</span></span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">10</span>) <span class="comment">//只用 1 个数码管显示，所以加到 10 就清零重新开始</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    LED_SMG_PORT = gsmg[count]; <span class="comment">//计数值显示到数码管上</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup = keybuf; <span class="comment">//更新备份为当前值，以备进行下次比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际做项目开发的时候，程序量往往很大，各种状态值也很多，如果使用Delay的话，会影响主函数的运行，所以我们可以采用<code>定时器中断进行按键消抖</code></p>
<p>我们启用一个定时中断，每 2ms 进一次中断，扫描一次按键状态并且存储起来，连续扫描 8 次后，看看这连续 8 次的按键状态<code>是否是一致</code>的。 8 次按键的时间大概是 16ms，这 16ms 内如果按键<code>状态一直保持一致</code>，那就可以确定现在<code>按键处于稳定</code>的阶段，假如左边时间是起始 0 时刻，每经过 2ms 左移一次，每移动一次，判断当前连续的 8 次按键状态是不是全 1 或者全 0，如果是<code>全 1 则判定为弹起，如果是全 0 则判定为按下，如果 0 和 1 交错，就认为是抖动</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-23%20174240.webp" style="zoom: 33%;" />
<blockquote>
<h4 id="按键按一次，数码管数值-1（使用定时器中断消抖）">按键按一次，数码管数值+1（使用定时器中断消抖）</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0 <span class="comment">//宏定义LED与数码管端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_PORT	P2     <span class="comment">//宏定义按键端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KeyIn2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">u8 code gsmg[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                  <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">                 &#125;; <span class="comment">//数码管显示字符转换表</span></span><br><span class="line">bit key_state = <span class="number">1</span>; <span class="comment">//当前按键状态（因为后面定时器中断服务函数有用到该变量，所以定义为全局变量）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit backup = <span class="number">1</span>; <span class="comment">//按键值备份，保存前一次的扫描值</span></span><br><span class="line">    u8 count = <span class="number">0</span>;   <span class="comment">//按键计数，记录按键按下的次数</span></span><br><span class="line"></span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//选择数码管 DS1 进行显示</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    ADDR2 = <span class="number">0</span>;</span><br><span class="line">    ADDR1 = <span class="number">0</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xF8</span>;    <span class="comment">//定时 2ms</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    KEY_PORT = <span class="number">0xF7</span>; <span class="comment">//P2.3 置 0，即 KeyOut1 输出低电平</span></span><br><span class="line">    LED_SMG_PORT = gsmg[count]; <span class="comment">//显示按键次数初值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key_state != backup) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup == <span class="number">0</span>)       <span class="comment">//如果前次值为 0，则说明当前是弹起动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                count++;            <span class="comment">//按键次数+1</span></span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">10</span>)     <span class="comment">//只用 1 个数码管显示，所以加到 10 就清零重新开始</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LED_SMG_PORT = gsmg[count]; <span class="comment">//计数值显示到数码管上</span></span><br><span class="line">            &#125;</span><br><span class="line">            backup = key_state;           <span class="comment">//更新备份为当前值，以备进行下次比较</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器中断服务函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_buf = <span class="number">0xFF</span>; <span class="comment">//扫描缓冲区，保存一段时间内的扫描值</span></span><br><span class="line">    TH0 = <span class="number">0xF8</span>;               <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    key_buf = (key_buf &lt;&lt; <span class="number">1</span>) | KeyIn1; <span class="comment">//缓冲区左移一位，并将当前扫描值移入最低位</span></span><br><span class="line">    <span class="comment">//1111 1111 &lt;&lt; 1 --&gt; 1111 1110 | KeyIn1 --&gt; 1111 1111</span></span><br><span class="line">    <span class="keyword">if</span>(key_buf == <span class="number">0x00</span>) <span class="comment">//0000 0000</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//连续 8 次扫描值都为 0，即 16ms 内都只检测到按下状态时，可认为按键已按下</span></span><br><span class="line">        key_state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key_buf == <span class="number">0xFF</span>) <span class="comment">//1111 1111</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//连续 8 次扫描值都为 1，即 16ms 内都只检测到弹起状态时，可认为按键已弹起</span></span><br><span class="line">        key_state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;&#125; <span class="comment">//其它情况则说明按键状态尚未稳定，则不对 KeySta 变量值进行更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵按键相当于 4 组每组各 4 个独立按键，一共是 16 个按键，在按键扫描中断中，我们每次让矩阵按键的一个 KeyOut 输出低电平，其它三个输出高电平，判断当前所有 KeyIn 的状态，下次中断时再让下一个 KeyOut 输出低电平，其它三个输出高电平，再次判断所有 KeyIn，通过 速的中断不停的循环进行判断，就可以最终确定哪个按键按下了，现在有 4 个 KeyOut 输出，要中断 4 次才能完成一次全部按键的扫描，显然再采用 2ms 中断判断 8 次扫描值的方式时间就太长了 <code>(2*4*8=64ms)</code>，那么我们就改用 1ms 中断判断 4 次采样值( <code>即只判断低4位0000 xxxx</code> )，这样消抖时间还是 16ms<code>(1*4*4)</code></p>
<blockquote>
<h4 id="矩阵按键的扫描，并且将按键值显示在第一个数码管上">矩阵按键的扫描，并且将按键值显示在第一个数码管上</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0 <span class="comment">//宏定义LED与数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KeyOut4 = P2 ^ <span class="number">0</span>;</span><br><span class="line">sbit KeyOut3 = P2 ^ <span class="number">1</span>;</span><br><span class="line">sbit KeyOut2 = P2 ^ <span class="number">2</span>;</span><br><span class="line">sbit KeyOut1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KeyIn1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KeyIn2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">u8 code gsmg[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                  <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">                 &#125;; <span class="comment">//数码管显示字符转换表</span></span><br><span class="line">u8 key_state[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//全部矩阵按键的当前状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的扫描值</span></span><br><span class="line"></span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//选择数码管 DS1 进行显示</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    ADDR2 = <span class="number">0</span>;</span><br><span class="line">    ADDR1 = <span class="number">0</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;</span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;    <span class="comment">//定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动 T0</span></span><br><span class="line">    LED_SMG_PORT = gsmg[<span class="number">0</span>]; <span class="comment">//默认显示0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测4*4的矩阵按键</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != key_state[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)             <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        LED_SMG_PORT = gsmg[i * <span class="number">4</span> + j]; <span class="comment">//将编号显示到数码管</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    backup[i][j] = key_state[i][j];   <span class="comment">//更新前一次的备份值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器中断服务函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>;  <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 key_buf[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">                                &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">                              &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;               <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="comment">//将一行的4个按键值移入缓冲区</span></span><br><span class="line">    key_buf[KeyOut][<span class="number">0</span>] = (key_buf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    key_buf[KeyOut][<span class="number">1</span>] = (key_buf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    key_buf[KeyOut][<span class="number">2</span>] = (key_buf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    key_buf[KeyOut][<span class="number">3</span>] = (key_buf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行4个按键，所以循环4次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((key_buf[KeyOut][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x00</span>) <span class="comment">//只判断低4位即可</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续4次扫描值为0，即4*4ms内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            key_state[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((key_buf[KeyOut][i] &amp; <span class="number">0x0F</span>) == <span class="number">0x0F</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续4次扫描值为1，即4*4ms内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            key_state[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++;       <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span>(KeyOut == <span class="number">4</span>) <span class="comment">//也可以写成 keyout = keyout &amp; 0x03;  //索引值加到4即归零</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚，P2口默认高电平，而且只要不去改变它它状态是不会改变所以不必重新设置</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="行列式扫描法-–-在数码管上显示对应键值（01-16）">行列式扫描法 – 在数码管上显示对应键值（01 ~ 16）</h4>
</blockquote>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key1 = NO_KEY, key2, key3; <span class="comment">//定义三个按键值，key1一开始先初始化为 按键未按下</span></span><br><span class="line">    <span class="type">static</span> u8 time = <span class="number">0</span>; <span class="comment">//计算三个按键传递的次数</span></span><br><span class="line">    u8 key_sta = <span class="number">1</span>;   <span class="comment">//允许识别按键</span></span><br><span class="line">    u8 Key_value;     <span class="comment">//按键键值</span></span><br><span class="line">    u8 temp;          <span class="comment">//中间变量</span></span><br><span class="line"></span><br><span class="line">    key3 = key2;      <span class="comment">//把第二个按键值传给第三个按键值</span></span><br><span class="line">    key2 = key1;      <span class="comment">//把第一个按键值传给第二个按键值</span></span><br><span class="line">    time++;           <span class="comment">//三个按键传递的次数累加</span></span><br><span class="line">    KEY_PORT = <span class="number">0xF0</span>;  <span class="comment">//矩阵按键列全为1，行全为0</span></span><br><span class="line">    <span class="keyword">if</span>((key_sta == <span class="number">1</span>) &amp;&amp; ((KEY_PORT &amp; <span class="number">0xF0</span>) != <span class="number">0xF0</span>)) <span class="comment">//如果允许识别按键且按键与原来键值不一样则表示有按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KEY_PORT = <span class="number">0xF7</span>; <span class="comment">// 第一行某个按键按下按下</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xF7</span>) != <span class="number">0xF7</span>)      <span class="comment">//按键发生变化表示第一行有按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">0x07</span> | (KEY_PORT &amp; <span class="number">0xF0</span>); <span class="comment">//把按键值赋给中间变量(例如第一个按键按下, 0x07 | (0xE7 &amp; 0xF0) --&gt; 0x07 | 0xE0 --&gt; 0xE7)</span></span><br><span class="line">            key1 = temp;                     <span class="comment">//再把中间变量的按键值赋给第一个按键值</span></span><br><span class="line">        &#125;                                  <span class="comment">//按键值会传递到三个按键值都一样表示按键按下(这个过程可以把抖动给过滤掉)</span></span><br><span class="line">        KEY_PORT = <span class="number">0xFB</span>; <span class="comment">// 第二行某个按键按下</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xFB</span>) != <span class="number">0xFB</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">0x0B</span> | (KEY_PORT &amp; <span class="number">0xF0</span>);</span><br><span class="line">            key1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        KEY_PORT = <span class="number">0xFD</span>; <span class="comment">// 第三行某个按键按下按下</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xFD</span>) != <span class="number">0xFD</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">0x0D</span> | (KEY_PORT &amp; <span class="number">0xF0</span>);</span><br><span class="line">            key1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        KEY_PORT = <span class="number">0xFE</span>; <span class="comment">// 第四行某个按键按下按下</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xFE</span>) != <span class="number">0xFE</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="number">0x0E</span> | (KEY_PORT &amp; <span class="number">0xF0</span>);</span><br><span class="line">            key1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">3</span>) <span class="comment">//三个按键传递的次数等于3表示三个按键值传递到都一样了</span></span><br><span class="line">        &#123;</span><br><span class="line">            time = <span class="number">0</span>;   <span class="comment">//次数清0</span></span><br><span class="line">            <span class="keyword">if</span>((key1 == key2) &amp;&amp; (key1 == key3) &amp;&amp; (key1 != NO_KEY)) <span class="comment">//如果按键值1 2 3都相等且按下的话</span></span><br><span class="line">            &#123;</span><br><span class="line">                Key_value = key1;</span><br><span class="line">                key_sta = <span class="number">0</span>; <span class="comment">//不允许识别按键(按键按下所以不允许识别按键)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xF0</span>) == <span class="number">0xF0</span>) <span class="comment">//如果按键列全为高电平表示没有按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_sta = <span class="number">1</span>; <span class="comment">//允许识别按键</span></span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Key_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_KEY 0XFF   <span class="comment">//表示按键未按下</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_PORT	P2  <span class="comment">//宏定义按键端口</span></span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0 <span class="comment">//定义LED和数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 code KeyCode[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0xE7</span>, <span class="number">0xD7</span>, <span class="number">0xB7</span>, <span class="number">0x77</span>,</span><br><span class="line">    <span class="number">0xEB</span>, <span class="number">0xDB</span>, <span class="number">0xBB</span>, <span class="number">0x7B</span>,</span><br><span class="line">    <span class="number">0xED</span>, <span class="number">0xDD</span>, <span class="number">0xBD</span>, <span class="number">0x7D</span>,</span><br><span class="line">    <span class="number">0xEE</span>, <span class="number">0xDE</span>, <span class="number">0xBE</span>, <span class="number">0x7E</span></span><br><span class="line">&#125;; <span class="comment">//对应某一个按键按下的键值(按键键值表)</span></span><br><span class="line"></span><br><span class="line">u8 code SMG_Char[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管段码0~9</span></span><br><span class="line">u8 SMG_buff[<span class="number">2</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓冲区</span></span><br><span class="line">u8 num = NO_KEY;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Dispaly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_num = NO_KEY; <span class="comment">//按键未按下</span></span><br><span class="line">    u8 i;</span><br><span class="line">    ADDR3 = <span class="number">1</span>;    <span class="comment">//G1(E3) 使能管脚高电平</span></span><br><span class="line">    ENLED = <span class="number">0</span>;    <span class="comment">//E1 E2低电平有效</span></span><br><span class="line">    Time0_Init(); <span class="comment">//定时器0初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key_num = Key_Scan();  <span class="comment">//接收键值</span></span><br><span class="line">        <span class="keyword">if</span>(key_num != NO_KEY)  <span class="comment">//如果按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(key_num == KeyCode[i]) <span class="comment">//表示某一个按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num = i; <span class="comment">//把按键键值表中对应的位置取出来赋给num</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SMG_buff[<span class="number">0</span>] = SMG_Char[(num + <span class="number">1</span>) % <span class="number">10</span>]; <span class="comment">//按键值与数码管上显示的数相对应(所以要num + 1)</span></span><br><span class="line">        SMG_buff[<span class="number">1</span>] = SMG_Char[(num + <span class="number">1</span>) / <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//开启总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;  <span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;  <span class="comment">//定时器模式1</span></span><br><span class="line">    TH0 = <span class="number">0XFC</span>;    <span class="comment">//定时1毫秒</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;       <span class="comment">//使能定时器0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;       <span class="comment">//启动定时器0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Dispaly</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>; <span class="comment">//动态扫描的索引</span></span><br><span class="line">    <span class="comment">//以下代码完成数码管动态刷新</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_buff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = SMG_buff[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = <span class="number">0xFC</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    <span class="keyword">if</span>(num != NO_KEY) <span class="comment">//按键按下才在数码管上表示数值</span></span><br><span class="line">        SMG_Dispaly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="线翻转扫描法-在数码管上显示对应键值（01-16）">线翻转扫描法-- 在数码管上显示对应键值（01 ~ 16）</h4>
</blockquote>
<p>使所有列为 <code>高电平</code> 时，检测所有行是否有 <code>低电平</code> ，如果有，就<code>记录行线值</code>；然后再<code>翻转</code>，使所有行都为 <code>高电平</code>，检测所有列的值，由于有按键按下，列的值也会有变化，记录列的值，将行与列的键值拼接起来，从而就可以检测到全部按键。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key1 = NO_KEY, key2, key3; <span class="comment">//定义三个按键值，key1一开始先初始化为 按键未按下</span></span><br><span class="line">    <span class="type">static</span> u8 time = <span class="number">0</span>; <span class="comment">//计算三个按键传递的次数</span></span><br><span class="line">    u8 key_sta = <span class="number">1</span>;   <span class="comment">//允许识别按键</span></span><br><span class="line">    u8 Key_value;     <span class="comment">//按键键值</span></span><br><span class="line">    u8 temp;          <span class="comment">//中间变量</span></span><br><span class="line"></span><br><span class="line">    key3 = key2;      <span class="comment">//把第二个按键值传给第三个按键值</span></span><br><span class="line">    key2 = key1;      <span class="comment">//把第一个按键值传给第二个按键值</span></span><br><span class="line">    time++;           <span class="comment">//三个按键传递的次数累加</span></span><br><span class="line">    KEY_PORT = <span class="number">0xF0</span>;  <span class="comment">//矩阵按键列全为1，行全为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((key_sta == <span class="number">1</span>) &amp;&amp; ((KEY_PORT &amp; <span class="number">0xF0</span>) != <span class="number">0xF0</span>)) <span class="comment">//如果允许识别按键且按键与原来键值不一样则表示有按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KEY_PORT = <span class="number">0xF0</span>; <span class="comment">//获取列的编号</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xF0</span>) != <span class="number">0xF0</span>) <span class="comment">//如果按键值发生变化则表示按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = KEY_PORT &amp; <span class="number">0xF0</span>;     <span class="comment">//取出列对应的按键值</span></span><br><span class="line">        &#125;</span><br><span class="line">        KEY_PORT = <span class="number">0x0F</span>; <span class="comment">//获取行的编号</span></span><br><span class="line">        <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0x0F</span>) != <span class="number">0x0F</span>) <span class="comment">//如果按键值发生变化则表示按键按下</span></span><br><span class="line">        &#123;</span><br><span class="line">            key1 = temp | (KEY_PORT &amp; <span class="number">0x0F</span>); <span class="comment">//将列的键值与行的键值拼接在一起获取按下按键的键值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(time == <span class="number">3</span>) <span class="comment">//三个按键传递的次数等于3表示三个按键值传递到都一样了</span></span><br><span class="line">        &#123;</span><br><span class="line">            time = <span class="number">0</span>;   <span class="comment">//次数清0</span></span><br><span class="line">            <span class="keyword">if</span>((key1 == key2) &amp;&amp; (key1 == key3) &amp;&amp; (key1 != NO_KEY)) <span class="comment">//如果按键值1 2 3都相等且按下的话</span></span><br><span class="line">            &#123;</span><br><span class="line">                Key_value = key1;</span><br><span class="line">                key_sta = <span class="number">0</span>; <span class="comment">//不允许识别按键(按键按下所以不允许识别按键)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((KEY_PORT &amp; <span class="number">0xF0</span>) == <span class="number">0xF0</span>) <span class="comment">//如果按键列全为高电平表示没有按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_sta = <span class="number">1</span>; <span class="comment">//允许识别按键</span></span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Key_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="简单加减法计算器">简单加减法计算器</h4>
</blockquote>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 code gsmg[] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">                  <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">                 &#125;; <span class="comment">//数码管显示字符转换表</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管显示缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>; <span class="comment">//动态扫描的索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一个无符号长整型的数字显示到数码管上，num-待显示数字 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">(u32 num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> i;</span><br><span class="line">    u8 sign = <span class="number">0</span>;</span><br><span class="line">    u8 buf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) <span class="comment">//首先提取并暂存符号位</span></span><br><span class="line">    &#123;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sign = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="comment">//把长整型数转换为 6 位十进制的数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) <span class="comment">//从最高位起，遇到 0 转换为空格，遇到非 0 则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == buf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i] = <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sign == <span class="number">1</span>) <span class="comment">//负数时，需在最前面添加负号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">5</span>)   <span class="comment">//当有效位数小于6位时添加负号，否则显示结果将是错的</span></span><br><span class="line">        &#123;</span><br><span class="line">            SMG_BUFF[i + <span class="number">1</span>] = <span class="number">0xBF</span>; <span class="comment">//负号的数码管值为0xBF</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        SMG_BUFF[i] = gsmg[buf[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SMG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SMG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0</span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1^<span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1^<span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1^<span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1^<span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">(u32 num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 code gsmg[];</span><br><span class="line"><span class="keyword">extern</span> u8 SMG_BUFF[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//矩阵按键编号到标准键盘键码的映射表</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span> &#125;, <span class="comment">//数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123; <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span> &#125;, <span class="comment">//数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123; <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span> &#125;, <span class="comment">//数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span> &#125; <span class="comment">//数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 key_sate[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//全部矩阵按键的当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i][j] != key_sate[i][j]) <span class="comment">//检测按键动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)           <span class="comment">//按键按下时执行动作</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]); <span class="comment">//调用按键动作函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = key_sate[i][j]; <span class="comment">//刷新前一次的备份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> oprt = <span class="number">0</span>;    <span class="comment">//用于保存加减运算符</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> result = <span class="number">0</span>;  <span class="comment">//用于保存运算结果</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> addend = <span class="number">0</span>;  <span class="comment">//用于保存输入的加数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((keycode &gt;= <span class="number">0x30</span>) &amp;&amp; (keycode &lt;= <span class="number">0x39</span>)) <span class="comment">//输入 0-9 的数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        addend = (addend * <span class="number">10</span>) + (keycode - <span class="number">0x30</span>);  <span class="comment">//整体十进制左移，新数字进入个位</span></span><br><span class="line">        SMG_Show(addend); <span class="comment">//运算结果显示到数码管</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x26</span> == keycode) <span class="comment">//向上键用作加号，执行加法或连加运算</span></span><br><span class="line">    &#123;</span><br><span class="line">        oprt = <span class="number">0</span>;        <span class="comment">//设置运算符变量</span></span><br><span class="line">        result = addend; <span class="comment">//运算数存到结果中，准备进行加减</span></span><br><span class="line">        addend = <span class="number">0</span>;      <span class="comment">//清零运算数，准备接收下一个运算数</span></span><br><span class="line">        SMG_Show(addend);<span class="comment">//刷新数码管显示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x28</span> == keycode) <span class="comment">//向下键用作减号</span></span><br><span class="line">    &#123;</span><br><span class="line">        oprt = <span class="number">1</span>;              <span class="comment">//设置运算符变量</span></span><br><span class="line">        result = addend;       <span class="comment">//运算数存到结果中，准备进行加减</span></span><br><span class="line">        addend = <span class="number">0</span>;            <span class="comment">//清零运算数，准备接收下一个运算数</span></span><br><span class="line">        SMG_Show(addend);      <span class="comment">//刷新数码管显示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0D</span> == keycode)  <span class="comment">//回车键，执行加减运算</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == oprt)</span><br><span class="line">        &#123;</span><br><span class="line">            result += addend; <span class="comment">//进行加法运算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result -= addend; <span class="comment">//进行减法运算</span></span><br><span class="line">        &#125;</span><br><span class="line">        addend = <span class="number">0</span>;</span><br><span class="line">        SMG_Show(result);   <span class="comment">//运算结果显示到数码管</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x1B</span> == keycode) <span class="comment">//Esc 键，清零结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        addend = <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        SMG_Show(addend); <span class="comment">//运算结果显示到数码管</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用，推荐调用间隔 1ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            key_sate[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            key_sate[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++; <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span> (KeyOut &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	KeyOut = KeyOut &amp; 0x03; //索引值加到 4 即归零</span></span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;</span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">extern</span> u8 key_sate[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;   <span class="comment">//为 T0 赋初值，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动 T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//选择数码管进行显示</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Time_Init(); <span class="comment">//定时器初始化</span></span><br><span class="line">    SMG_BUFF[<span class="number">0</span>] = gsmg[<span class="number">0</span>]; <span class="comment">//上电显示 0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver(); <span class="comment">//调用按键驱动函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，用于数码管显示扫描与按键扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = <span class="number">0xFC</span>; <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    SMG_Scan(); <span class="comment">//调用数码管显示扫描函数</span></span><br><span class="line">    Key_Scan(); <span class="comment">//调用按键扫描函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="按键1实现流水灯，按键2数码管显示0到99，按键3数码管显示时钟">按键1实现流水灯，按键2数码管显示0到99，按键3数码管显示时钟</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义LED和数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">sbit KeyOut1 = P2 ^ <span class="number">3</span>;</span><br><span class="line">sbit KeyIn1 = P2 ^ <span class="number">4</span>;</span><br><span class="line">sbit KeyIn2 = P2 ^ <span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2 ^ <span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2 ^ <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">u8 code gsmg[<span class="number">10</span>] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管显示字符转换表(0到9）</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">7</span>] = &#123;<span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0XFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管显示缓冲区</span></span><br><span class="line">u8 key_state[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//全部矩阵按键的当前状态</span></span><br><span class="line"></span><br><span class="line">u8 flag1 = <span class="number">0</span>; <span class="comment">//0.5s标志位</span></span><br><span class="line">u8 flag2 = <span class="number">0</span>; <span class="comment">//1s标志位</span></span><br><span class="line"></span><br><span class="line">u8 KeyDown_State;		<span class="comment">//按键按下状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================函数声明区============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_show</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Contrl</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_count</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Handler</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Parameter_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//使能74HC138芯片</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    time0_Init(); <span class="comment">//定时器初始化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver();  <span class="comment">//按键驱动函数</span></span><br><span class="line">        Key_Handler(); <span class="comment">//按键处理函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================定时器初始化============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;   <span class="comment">//为 T0 赋初值，定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键驱动============================*/</span></span><br><span class="line"><span class="comment">//按键驱动函数，检测按键动作，调度相应动作函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i , j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(key_state[i][j] != backup[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>) <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Test();  <span class="comment">//调用按键检测函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = key_state[i][j]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键检测============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Test</span><span class="params">()</span> <span class="comment">//按键检测函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == KeyIn1)       <span class="comment">//如果按键1按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parameter_Init(); <span class="comment">//调用参数初始化函数</span></span><br><span class="line">        KeyDown_State = <span class="number">1</span>;    <span class="comment">//按键按下状态为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == KeyIn2)  <span class="comment">//如果按键2按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parameter_Init(); <span class="comment">//调用参数初始化函数</span></span><br><span class="line">        KeyDown_State = <span class="number">2</span>;    <span class="comment">//按键按下状态为2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == KeyIn3)  <span class="comment">//如果按键3按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parameter_Init(); <span class="comment">//调用参数初始化函数</span></span><br><span class="line">        KeyDown_State = <span class="number">3</span>;    <span class="comment">//按键按下状态为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键处理函数============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Handler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == KeyDown_State)   <span class="comment">//如果按键按下状态为1，则表示按键1按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == flag1)   <span class="comment">//如果标志位为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag1 = <span class="number">0</span>;   <span class="comment">//标志位清0</span></span><br><span class="line">            LED_Contrl();<span class="comment">//调用LED流水灯函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == KeyDown_State)   <span class="comment">//如果按键按下状态为2，则表示按键2按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == flag2)   <span class="comment">//如果标志位为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag2 = <span class="number">0</span>;   <span class="comment">//标志位清0</span></span><br><span class="line">            SMG_count(); <span class="comment">//调用数码管计数函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span> == KeyDown_State)   <span class="comment">//如果按键按下状态为3，则表示按键3按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == flag2)   <span class="comment">//如果标志位为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag2 = <span class="number">0</span>;   <span class="comment">//标志位清0</span></span><br><span class="line">            SMG_show();  <span class="comment">//调用数码管显示时钟函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区(按键消抖)</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1; <span class="comment">//缓冲区左移一位，并将当前扫描值移入最低位</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;  <span class="comment">//1111 1111 &lt;&lt; 1 --&gt; 1111 1110 | KeyIn1 --&gt; 1111 1111</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>)) <span class="comment">//由于只需要判断最后四位，所以要 &amp; 上0x0F</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            key_state[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            key_state[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    KeyOut1 = <span class="number">0</span>; <span class="comment">//由于这里只需要三个按键，选了按键1 2 3，所以只需要KeyOut1 = 0就好</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================数码管驱动============================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;     <span class="comment">//动态扫描的索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>; <span class="comment">//显示消隐</span></span><br><span class="line">    <span class="keyword">switch</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        ADDR2 = <span class="number">0</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">0</span>;</span><br><span class="line">        ADDR0 = <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ADDR2 = <span class="number">1</span>;</span><br><span class="line">        ADDR1 = <span class="number">1</span>;</span><br><span class="line">        ADDR0 = <span class="number">0</span>;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        LED_SMG_PORT = SMG_BUFF[<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//点亮LED需要使能LEDS6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED流水灯函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Contrl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 Led_State = <span class="number">0x80</span>;  <span class="comment">// led初始状态</span></span><br><span class="line">    <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">    SMG_BUFF[<span class="number">6</span>] = ~Led_State; <span class="comment">//取反赋给数码管缓存数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">    Led_State &gt;&gt;= <span class="number">1</span>;          <span class="comment">//右移一位</span></span><br><span class="line">    <span class="keyword">if</span>(Led_State == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Led_State = <span class="number">0x80</span>;     <span class="comment">//右移到最低位后重新设置为第八个LED灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管计数函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 sec = <span class="number">0</span>; <span class="comment">//定义静态变量秒为0</span></span><br><span class="line">    sec++;</span><br><span class="line">    <span class="keyword">if</span>(sec &gt;= <span class="number">100</span>)  <span class="comment">//秒加到99就清0</span></span><br><span class="line">    &#123;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SMG_BUFF[<span class="number">0</span>] = gsmg[sec % <span class="number">10</span>]; <span class="comment">//秒个位</span></span><br><span class="line">    SMG_BUFF[<span class="number">1</span>] = gsmg[sec / <span class="number">10</span>]; <span class="comment">//秒十位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 hour = <span class="number">15</span>; <span class="comment">//初始化时钟时间</span></span><br><span class="line">    <span class="type">static</span> u8 min = <span class="number">35</span>;</span><br><span class="line">    <span class="type">static</span> u8 sec = <span class="number">30</span>;</span><br><span class="line">    SMG_BUFF[<span class="number">0</span>] = gsmg[sec % <span class="number">10</span>];   <span class="comment">//秒个位</span></span><br><span class="line">    SMG_BUFF[<span class="number">1</span>] = gsmg[sec / <span class="number">10</span>];   <span class="comment">//秒十位</span></span><br><span class="line">    SMG_BUFF[<span class="number">2</span>] = gsmg[min % <span class="number">10</span>];   <span class="comment">//分个位</span></span><br><span class="line">    SMG_BUFF[<span class="number">3</span>] = gsmg[min / <span class="number">10</span>];   <span class="comment">//分十位</span></span><br><span class="line">    SMG_BUFF[<span class="number">4</span>] = gsmg[hour % <span class="number">10</span>];  <span class="comment">//小时个位</span></span><br><span class="line">    SMG_BUFF[<span class="number">5</span>] = gsmg[hour / <span class="number">10</span>];  <span class="comment">//小时十位</span></span><br><span class="line">    sec++;</span><br><span class="line">    <span class="keyword">if</span>(sec &gt;= <span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sec = <span class="number">0</span>;</span><br><span class="line">        min++;</span><br><span class="line">        <span class="keyword">if</span>(min &gt;= <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min = <span class="number">0</span>;</span><br><span class="line">            hour++;</span><br><span class="line">            <span class="keyword">if</span>(hour &gt;= <span class="number">24</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hour = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================其他============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Parameter_Init</span><span class="params">()</span> <span class="comment">//参数初始化函数 调用这个函数主要是当按下其他按键时，前一个按键的功能不显示，</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//继续按下前一个按键时该按键的功能才会继续显示</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SMG_BUFF[i] = <span class="number">0xFF</span>; <span class="comment">//将数码管缓冲区全部关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================定时器============================*/</span></span><br><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count1 = <span class="number">0</span>; <span class="comment">//记录T0中断次数</span></span><br><span class="line">    <span class="type">static</span> u16 count2 = <span class="number">0</span>;</span><br><span class="line">    TH0 = <span class="number">0xFC</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    count1++;   <span class="comment">//中断计数+1</span></span><br><span class="line">    count2++;</span><br><span class="line">    <span class="keyword">if</span>(count1 &gt;= <span class="number">500</span>) <span class="comment">//中断500次相当于0.5秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        count1 = <span class="number">0</span>;   <span class="comment">//溢出中断清0</span></span><br><span class="line">        flag1 = <span class="number">1</span>;    <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count2 &gt;= <span class="number">1000</span>) <span class="comment">//中断1000次相当于1秒 (1000ms = 1s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        count2 = <span class="number">0</span>;    <span class="comment">//溢出中断清0</span></span><br><span class="line">        flag2 = <span class="number">1</span>;     <span class="comment">//设置中断标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    Key_Scan(); <span class="comment">//调用按键扫描函数</span></span><br><span class="line">    SMG_Scan(); <span class="comment">//调用数码管扫描函数(驱动函数)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="四个按键控制四个LED亮灭">四个按键控制四个LED亮灭</h4>
</blockquote>
<p><code>KEY.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KEY.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 Key_State[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//全部矩阵按键的当前状态</span></span><br><span class="line">u8 KeyDown_State; <span class="comment">//按下状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键驱动============================*/</span></span><br><span class="line"><span class="comment">//按键驱动函数，检测按键动作，调度相应动作函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Key_State[i][j] != backup[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>) <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Test(); <span class="comment">//调用按键检测函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = Key_State[i][j]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键检测============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Test</span><span class="params">()</span> <span class="comment">//按键检测函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == KeyIn1)      <span class="comment">//如果按键1按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">1</span>; <span class="comment">//按下状态为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == KeyIn2) <span class="comment">//如果按键2按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">2</span>; <span class="comment">//按下状态为2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == KeyIn3) <span class="comment">//如果按键3按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">3</span>; <span class="comment">//按下状态为3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == KeyIn4) <span class="comment">//如果按键4按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">4</span>; <span class="comment">//按下状态为4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================按键处理函数============================*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Handler</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == KeyDown_State)       <span class="comment">//如果按键按下状态为1，则表示按键1按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">0</span>;         <span class="comment">//按键状态清0</span></span><br><span class="line">        LED2 = !LED2;              <span class="comment">//LED2状态翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span> == KeyDown_State)  <span class="comment">//如果按键按下状态为2，则表示按键2按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">0</span>;         <span class="comment">//按键状态清0</span></span><br><span class="line">        LED3 = !LED3;              <span class="comment">//LED3状态翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">3</span> == KeyDown_State)  <span class="comment">//如果按键按下状态为3，则表示按键3按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">0</span>;         <span class="comment">//按键状态清0</span></span><br><span class="line">        LED4 = !LED4;              <span class="comment">//LED4状态翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">4</span> == KeyDown_State)  <span class="comment">//如果按键按下状态为4，则表示按键4按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        KeyDown_State = <span class="number">0</span>;         <span class="comment">//按键状态清0</span></span><br><span class="line">        LED5 = !LED5;              <span class="comment">//LED4状态翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1; <span class="comment">//缓冲区左移一位，并将当前扫描值移入最低位</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2; <span class="comment">//1111 1111 &lt;&lt; 1 --&gt; 1111 1110 | KeyIn1 --&gt; 1111 1111</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>)) <span class="comment">//由于只需要判断最后四位，所以要 &amp; 上0x0F</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    KeyOut1 = <span class="number">0</span>; <span class="comment">//由于这里只需要第一行的四个按键，所以只需要KeyOut1 = 0就好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>KEY.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>; <span class="comment">//定义按键管脚</span></span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">sbit LED2 = P0^<span class="number">0</span>; <span class="comment">//定义LED管脚</span></span><br><span class="line">sbit LED3 = P0^<span class="number">1</span>;</span><br><span class="line">sbit LED4 = P0^<span class="number">2</span>;</span><br><span class="line">sbit LED5 = P0^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Test</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Handler</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KEY.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LED2 = <span class="number">1</span>; <span class="comment">//先让LED熄灭</span></span><br><span class="line">    LED3 = <span class="number">1</span>;</span><br><span class="line">    LED4 = <span class="number">1</span>;</span><br><span class="line">    LED5 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//使能LEDS6</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    ADDR2 = <span class="number">1</span>;</span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    EA = <span class="number">1</span>;         <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>;   <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xF8</span>;     <span class="comment">//定时2ms</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;        <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;        <span class="comment">//启动 T0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver();  <span class="comment">//按键驱动函数</span></span><br><span class="line">        Key_Handler(); <span class="comment">//按键处理函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器0中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = <span class="number">0xF8</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    Key_Scan(); <span class="comment">//调用按键扫描函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="使用按键控制秒表的启动与停止">使用按键控制秒表的启动与停止</h4>
</blockquote>
<ul>
<li><code>回车键</code>：开启/暂停；<code>Esc</code>：清0</li>
<li>最右边的两个数码管显示毫秒，左边四个数码管显示秒数</li>
</ul>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF</span></span><br><span class="line"></span><br><span class="line">bit Watch_Run = <span class="number">0</span>;     <span class="comment">//秒表运行标志</span></span><br><span class="line">bit Watch_Refresh = <span class="number">1</span>; <span class="comment">//秒表计数刷新标志</span></span><br><span class="line"></span><br><span class="line">u8 Decimal = <span class="number">0</span>;   <span class="comment">//秒表的小数部分</span></span><br><span class="line">u16 Integer = <span class="number">0</span>;  <span class="comment">//秒表的整数部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表计数显示函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Display</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> i; <span class="comment">//由于i是--，最后会减为0，如果换成无符号的话再减就变成256了，所以这里要写出有符号的变量</span></span><br><span class="line">    u8 buf[<span class="number">4</span>];  <span class="comment">//数据转换的缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//小数部分转换到低2位</span></span><br><span class="line">    SMG_BUFF[<span class="number">0</span>] = gsmg[Decimal % <span class="number">10</span>];</span><br><span class="line">    SMG_BUFF[<span class="number">1</span>] = gsmg[Decimal / <span class="number">10</span>];</span><br><span class="line">    <span class="comment">//整数部分转换到高4位</span></span><br><span class="line">    buf[<span class="number">0</span>] = Integer % <span class="number">10</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = (Integer / <span class="number">10</span>) % <span class="number">10</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = (Integer / <span class="number">100</span>) % <span class="number">10</span>;</span><br><span class="line">    buf[<span class="number">3</span>] = (Integer / <span class="number">1000</span>) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) <span class="comment">//从最高位起，遇到 0 转换为空格，遇到非 0 则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == buf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            SMG_BUFF[i + <span class="number">2</span>] = <span class="number">0xFF</span>; <span class="comment">//如果该数码管显示的数为0则关闭该数码管</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--) <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        SMG_BUFF[i + <span class="number">2</span>] = gsmg[buf[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    SMG_BUFF[<span class="number">2</span>] &amp;= <span class="number">0x7F</span>; <span class="comment">//在倒数第三个数码管点亮小数点(0111 1111)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表启停函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Action</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Watch_Run)</span><br><span class="line">        Watch_Run = <span class="number">0</span>; <span class="comment">//已启动则停止</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Watch_Run = <span class="number">1</span>; <span class="comment">//未启动则启动</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表复位函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Reset</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Watch_Run = <span class="number">0</span>;        <span class="comment">//停止秒表</span></span><br><span class="line">    Decimal = <span class="number">0</span>;          <span class="comment">//整数小数清零计数值</span></span><br><span class="line">    Integer = <span class="number">0</span>;</span><br><span class="line">    Watch_Refresh = <span class="number">1</span>;    <span class="comment">//置刷新标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//缓冲区中索引位置的数据送到数码管端口</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 秒表计数函数，每隔 10ms 调用一次进行秒表计数累加 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Watch_Run)             <span class="comment">//当处于运行状态时递增计数值</span></span><br><span class="line">    &#123;</span><br><span class="line">        Decimal++;              <span class="comment">//小数部分+1</span></span><br><span class="line">        <span class="keyword">if</span>(Decimal &gt;= <span class="number">100</span>)      <span class="comment">//小数部分计到100时进位到整数部分</span></span><br><span class="line">        &#123;</span><br><span class="line">            Decimal = <span class="number">0</span>;</span><br><span class="line">            Integer++;            <span class="comment">//整数部分+1</span></span><br><span class="line">            <span class="keyword">if</span>(Integer &gt;= <span class="number">10000</span>)  <span class="comment">//整数部分计到10000时归零</span></span><br><span class="line">            &#123;</span><br><span class="line">                Integer = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Watch_Refresh = <span class="number">1</span>;      <span class="comment">//设置秒表计数刷新标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SMG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SMG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Display</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Action</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Reset</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Watch_Count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> bit Watch_Refresh;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 Key_State[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//按键当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测4个按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(backup[i] != Key_State[i]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i] != <span class="number">0</span>)  <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == i)  <span class="comment">//Esc键复位秒表</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Watch_Reset();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span> == i) <span class="comment">//回车键启停秒表</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Watch_Action();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            backup[i] = Key_State[i]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//按键扫描缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按键值移入缓冲区</span></span><br><span class="line">    keybuf[<span class="number">0</span>] = (keybuf[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[<span class="number">1</span>] = (keybuf[<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[<span class="number">2</span>] = (keybuf[<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[<span class="number">3</span>] = (keybuf[<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0x00</span> == keybuf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续8次扫描值为0，即16ms内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0xFF</span> == keybuf[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续8次扫描值为1，即16ms内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_PORT	P2 <span class="comment">//宏定义按键端口</span></span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>;</span><br><span class="line">u8 T0RL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;      <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>; <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;       <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//使能选择数码管</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    KEY_PORT = <span class="number">0xFE</span>; <span class="comment">//P2.0置0，选择第4行按键作为独立按键(KeyOut4为0)</span></span><br><span class="line">    Config_Time0(<span class="number">2</span>); <span class="comment">//配置T0定时2ms</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Watch_Refresh)    <span class="comment">//如果秒表计数刷新标志为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            Watch_Refresh = <span class="number">0</span>; <span class="comment">//秒表计数刷新标志置0</span></span><br><span class="line">            Watch_Display();   <span class="comment">//调用秒表计数显示函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        Key_Driver(); <span class="comment">//调用按键驱动函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，完成数码管、按键扫描与秒表计数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TH0 = T0RH;  <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Key_Scan();  <span class="comment">//数码管扫描显示</span></span><br><span class="line">    Smg_Scan();  <span class="comment">//按键扫描</span></span><br><span class="line">    <span class="comment">//定时10ms进行一次秒表计数</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        Watch_Count(); <span class="comment">//调用秒表计数函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="实现按键长按功能">实现按键长按功能</h4>
</blockquote>
<p>打开开关后，数码管显示数字 0，按向上的按键数字加 1，按向下的按键数字减 1，长按向上按键 1 秒后，数字会持续增加，长按向下按键 1 秒后，数字会持续减小。设定好数字后，按下回车按键，时间就会进行倒计时，当倒计时到 0 的时候，用蜂鸣器和板子上的 8 个 LED 小灯做炸弹效果， 蜂鸣器持续响，LED 小灯全亮</p>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管+独立LED显示缓冲区，初值0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一个无符号长整型的数字显示到数码管上，num-待显示数字 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">(u32 num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> i; <span class="comment">//由于i是--，最后会减为0，如果换成无符号的话再减就变成256了，所以这里要写出有符号的变量</span></span><br><span class="line">    u8 buf[<span class="number">6</span>];             <span class="comment">//数据转换的缓冲区</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="comment">//把长整型数转换为 6 位十进制的数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = num % <span class="number">10</span>;   <span class="comment">//取出最低位到数码管上</span></span><br><span class="line">        num /= <span class="number">10</span>;           <span class="comment">//去掉最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) <span class="comment">//从最高位起，遇到 0 转换为空格，遇到非 0 则退出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == buf[i])      <span class="comment">//如果该数码管显示的数为0则关闭该数码管</span></span><br><span class="line">        &#123;</span><br><span class="line">            SMG_BUFF[i] = <span class="number">0xFF</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--)     <span class="comment">//剩余低位都如实转换为数码管显示字符</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SMG_BUFF[i] = gsmg[buf[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//索引递增循环，遍历整个缓冲区，由于加了LED显示，点亮LED需要使能LEDS6,所以i小于6不是小于5</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">6</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SMG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SMG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SMG_Show</span><span class="params">(u32 num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 SMG_BUFF[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 Key_State[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//按键当前状态</span></span><br><span class="line">u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//矩阵按键编号到标准键盘键码的映射表</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span> &#125;, <span class="comment">//数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123; <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span> &#125;, <span class="comment">//数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123; <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span> &#125;, <span class="comment">//数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span> &#125;  <span class="comment">//数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//由于定义变量data可以省略，但是这个变量内存空间不够，所以得使用pdata</span></span><br><span class="line">u32 pdata KeyDownTime[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;<span class="comment">//每个按键按下的持续时间，单位 ms</span></span><br><span class="line">bit enBuzz = <span class="number">0</span>;    <span class="comment">//蜂鸣器使能标志</span></span><br><span class="line">bit flag1s = <span class="number">0</span>;    <span class="comment">//1 秒定时标志</span></span><br><span class="line">bit flagStart = <span class="number">0</span>; <span class="comment">//倒计时启动标志</span></span><br><span class="line">u16 CountDown = <span class="number">0</span>; <span class="comment">//倒计时计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>  <span class="comment">//按键动作函数，根据键码执行相应动作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0x26</span> == keycode)        <span class="comment">//向上键，倒计时设定值递增</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CountDown &lt; <span class="number">9999</span>)     <span class="comment">//最大计时 9999 秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            CountDown++;</span><br><span class="line">            SMG_Show(CountDown);   <span class="comment">//将数值显示在数码管上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x28</span> == keycode)   <span class="comment">//向下键，倒计时设定值递减</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(CountDown &gt; <span class="number">1</span>)        <span class="comment">//最小计时 1 秒</span></span><br><span class="line">        &#123;</span><br><span class="line">            CountDown--;</span><br><span class="line">            SMG_Show(CountDown);   <span class="comment">//将数值显示在数码管上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x0D</span> == keycode)   <span class="comment">//回车键，启动倒计时</span></span><br><span class="line">    &#123;</span><br><span class="line">        flagStart = <span class="number">1</span>;           <span class="comment">//启动倒计时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x1B</span> == keycode)   <span class="comment">//Esc 键，取消倒计时</span></span><br><span class="line">    &#123;</span><br><span class="line">        enBuzz = <span class="number">0</span>;              <span class="comment">//关闭蜂鸣器</span></span><br><span class="line">        SMG_BUFF[<span class="number">6</span>] = <span class="number">0xFF</span>;      <span class="comment">//关闭独立 LED</span></span><br><span class="line">        flagStart = <span class="number">0</span>;           <span class="comment">//停止倒计时</span></span><br><span class="line">        CountDown = <span class="number">0</span>;           <span class="comment">//倒计时数归零</span></span><br><span class="line">        SMG_Show(CountDown);     <span class="comment">//将数值显示在数码管上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="type">static</span> u32 pdata TimeThr[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//快速输入执行的时间阈值(一开始默认为1秒，也就是按键按下超过1秒表示长按)</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;, &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;, &#123;<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环扫描 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i][j] != Key_State[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)  <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]); <span class="comment">//调用按键动作函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = Key_State[i][j]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(KeyDownTime[i][j] &gt; <span class="number">0</span>)         <span class="comment">//检测执行快速输入(按键按下的持续时间 &gt; 0)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(KeyDownTime[i][j] &gt;= TimeThr[i][j]) <span class="comment">//按键按下的持续时间达到阈值时执行一次动作</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]);        <span class="comment">//调用按键动作函数</span></span><br><span class="line">                    TimeThr[i][j] += <span class="number">200</span>;                <span class="comment">//时间阈值增加 200ms，以准备下次执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//按键弹起时复位阈值时间</span></span><br><span class="line">                TimeThr[i][j] = <span class="number">1000</span>; <span class="comment">//恢复 1s 的初始阈值时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">            KeyDownTime[KeyOut][i] += <span class="number">4</span>; <span class="comment">//按下的持续时间累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">            KeyDownTime[KeyOut][i] = <span class="number">0</span>; <span class="comment">//按下的持续时间清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++; <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span> (KeyOut &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	KeyOut = KeyOut &amp; 0x03; //索引值加到 4 即归零</span></span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u16 CountDown;  <span class="comment">//由于外部文件用到了该变量，所以前面要加上extern，外部才可以用</span></span><br><span class="line"><span class="keyword">extern</span> bit enBuzz;</span><br><span class="line"><span class="keyword">extern</span> bit flag1s;</span><br><span class="line"><span class="keyword">extern</span> bit flagStart;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u16 CountDown;  <span class="comment">//由于外部文件用到了该变量，所以前面要加上extern，外部才可以用</span></span><br><span class="line"><span class="keyword">extern</span> bit enBuzz;</span><br><span class="line"><span class="keyword">extern</span> bit flag1s;</span><br><span class="line"><span class="keyword">extern</span> bit flagStart;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>; <span class="comment">//定义蜂鸣器管脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>; <span class="comment">//选择数码管和独立 LED</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    Config_Time0(<span class="number">1</span>); <span class="comment">//配置T0定时1ms</span></span><br><span class="line">    SMG_Show(<span class="number">0</span>);     <span class="comment">//上电显示 0</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver(); <span class="comment">//调用按键驱动函数</span></span><br><span class="line">        <span class="keyword">if</span>(flagStart &amp;&amp; flag1s) <span class="comment">//倒计时启动且 1 秒定时到达时，处理倒计时</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag1s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(CountDown &gt; <span class="number">0</span>)        <span class="comment">//倒计时未到 0 时，计数器递减</span></span><br><span class="line">            &#123;</span><br><span class="line">                CountDown--;</span><br><span class="line">                SMG_Show(CountDown);   <span class="comment">//刷新倒计时数显示</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == CountDown)     <span class="comment">//减到 0 时，执行声光报警</span></span><br><span class="line">                &#123;</span><br><span class="line">                    enBuzz = <span class="number">1</span>;          <span class="comment">//启动蜂鸣器发声</span></span><br><span class="line">                    SMG_BUFF[<span class="number">6</span>] = <span class="number">0x00</span>;  <span class="comment">//点亮独立 LED</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，完成数码管、按键扫描与秒定时 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>; <span class="comment">//1 秒定时计数</span></span><br><span class="line">    TH0 = T0RH;           <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(enBuzz)            <span class="comment">//蜂鸣器发声处理</span></span><br><span class="line">        BUZZ = ~BUZZ;       <span class="comment">//驱动蜂鸣器发声</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        BUZZ = <span class="number">1</span>;           <span class="comment">//关闭蜂鸣器</span></span><br><span class="line">    <span class="keyword">if</span>(flagStart)         <span class="comment">//倒计时启动时处理 1 秒定时</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count &gt;= <span class="number">1000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            flag1s = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                  <span class="comment">//倒计时未启动时 1 秒定时器始终归零</span></span><br><span class="line">        flag1s = <span class="number">0</span>;</span><br><span class="line">    Key_Scan();           <span class="comment">//数码管扫描显示</span></span><br><span class="line">    Smg_Scan();           <span class="comment">//按键扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="步进电机">步进电机</h2>
<p>步进电机是将<code>电脉冲信号转变为角位移或线位移</code>的开环控制元件。在非超载的情况下，电机的转速、停止的位置<code>只取决于脉冲信号的频率和脉冲数</code>，而<code>不受负载变化的影响</code>，即给电机加一个脉冲信号，电机则转过一个步距角。这一线性关系的存在，加上步进电机只有周期性的误差而无累计误差等特点</p>
<h3 id="工作原理">工作原理</h3>
<p>通常步进电机的转子为永磁体，当电流流过定子绕组时，定子绕组产生一矢量磁场。输入一个电脉冲，电动机转动一个角度前进一步。它输出的角位移与输入的脉冲 数成正比、转速与脉冲频率成正比。改变绕组通电的顺序，电机就会反转。所以可以控制脉冲数量、频率及电动机各相绕组的通电顺序来控制步进电机的转动。 具体看下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/af53b8b5e6334243a3daad45db2e5c07.webp" style="zoom:33%;" />
<p>步进电机工作原理:当定子的矢量磁场旋转一个角度。转子也随着该磁场转步距角。每输入一个<code>电脉冲</code> ，电动机转动一个角度前进一步。它输出的角位移与输入的脉冲数成正比、转速与脉冲频率成正比。<code>改变绕组通电的顺序，电机就会反转</code> 。所以可以控制脉冲数量、频率及电动机各相绕维组的通电顺序来控制步进电机的转动</p>
<h3 id="28BYJ-48-步进电机简介">28BYJ-48 步进电机简介</h3>
<p>28——步进电机的有效最大外径是 28 毫米</p>
<p>B——表示是步进电机</p>
<p>Y——表示是永磁式</p>
<p>J——表示是减速型</p>
<p>48——表示四相八拍</p>
<p>28BYJ48 步进电机自带减速器，为<code>四相无线步进电机</code>，直径为 28mm，实物如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/890d1c9dc9fc495cbf6e63768a8a5614.webp" style="zoom:33%;" />
<p>28BYJ48 电机内部结构等效图如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f7d81929dbca43caa29fe7b4869e7056.webp" style="zoom:50%;" />
<p>步进电机一共有 5 根引线，其中红色的是<code>公共端</code>，连接到 5V 电源，接下来的<code>橙、黄、粉、蓝</code>就对应了 <code>A、B、C、D</code> 相；如果要导通 A 相绕组，就只需将橙色线接地即可，B 相则黄色接地，依此类推</p>
<p>绕组控制顺序表：(必须按顺序不能跳过哪步否则电机不会被磁力吸附)</p>
<p><code>橙、黄、粉、蓝 --- A、B、C、D</code><br>
<code>A --&gt; AB --&gt; B --&gt; BC --&gt; C --&gt; CD --&gt; D --&gt; DA</code></p>
<p>28BYJ48 步进电机旋转驱动方式如下表：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220930225257.jpg" style="zoom:67%;" />
<p>28BYJ48 步进电机实际上是：<code>减速齿轮+步进电机</code>组成</p>
<h3 id="原理图">原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220930225508.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220926220312.jpg" style="zoom:80%;" />
<p>板子需要把 <code>跳线帽</code> 跳到左边那列(J13~J16)，可以使用 P1.0 到 P1.3 控制步 进电机了，如要再使用显示部分的话，就要再换回到右侧</p>
<p>问：如果大家既想让显示部分正常工作，又想让电机工作该怎么办呢？</p>
<p>跳线帽保持在右侧，用杜邦线把步进电机的控制引脚 （即左侧的排针）连接到其它的暂不使用的单片机 IO 上即可</p>
<p>单片机的 IO 口可以直接输出 0V 和 5V 的电压，但是电流驱动能力，也就是带载能力非常有限，所以我们在每相的控制线上都增加一个<code>三极管</code>来提高驱动能力。由图中可以看出，若要使 <code>A 相导通</code>，则必须是 <code>Q2 导通</code>，此时 A 相也就是<code>橙色线就相当于接地</code>了，于是 A 相绕组导通，此时单片机 <code>P1 口低 4 位</code>应输出 <code>0b1110</code>，即 <code>0xE</code>；如要 <code>A、B</code> 相同时导通，那么就是 <code>Q2、Q3</code> 导通，<code>P1 口低 4 位</code>应输出 <code>0b1100</code>，即 <code>0xC</code>，依此类推，可以得到下面的八拍节拍的 IO 控制代码数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> code BeatCode[<span class="number">8</span>] = &#123; <span class="number">0x0E</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0x09</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x07</span>, <span class="number">0x06</span> &#125;; </span><br></pre></td></tr></table></figure>
<p>28BYJ48 步进电机主要参数如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20220930231807.jpg" style="zoom:67%;" />
<p>表中给出的参数是≥550，单位是 P.P.S，即每秒脉冲数，这里的意思就是说：电机保证 在你每秒给出 550 个步进脉冲的情况下，可以正常启动。那么换算成单节拍持续时间就是 1s/550=1.8ms，为了让电机能够启动，我们控制节拍刷新时间大于 1.8ms 就可以了</p>
<p>问：八拍模式时，步进电机转过一圈是需要 64 个节拍，而我们程序中是每个节拍持续 2ms，那么转一圈就应该是 128ms，即 1 秒钟转 7 圈多，可怎么看上去它好像是 7 秒多才转了一圈呢？</p>
<p>原因在于 “减速” 上，位于最中心的那个白色小齿轮才是步进电机的转子输出，64 个节拍只是让这个小齿轮转了一圈，然后它带动那个浅蓝色的大齿轮，这就 是一级减速，每 2 个齿轮都构成一级减速，一共就有了 4 级减速；电机参数表中的减速比是1:64，转子转 64 圈，最终输出轴才会 转一圈，也就是需要 <code>64*64=4096</code> 个节拍输出轴才转过一圈，<code>2ms*4096=8192ms</code>，8 秒多才转 一圈；4096 个节拍转动一圈，那么一个节拍转动的角度——步进角度就是 <code>360/4096</code>，看一下表中的步进角度参数 <code>5.625/64</code>，算一下就知道这两个值是相等的</p>
<p>问：厂家的参数为什么会有误差呢？</p>
<p>28BYJ-48 最初的设计目的是用来控制空调的扇叶的，扇叶的活动范围是不会超过180度的在这种应用场合下，厂商给出一个近似的整数减速比 1:64 已经足够精确了，这也是合情合理的；我们不一定是要用它来驱动空调扇叶，我们可以让它转动很多圈来干别的</p>
<h3 id="程序-3">程序</h3>
<p>这里只用到了 <code>P1</code> 中的低4位，养成好习惯把整个 <code>P1</code> 先赋给一个变量，然后不影响到其他位的状态</p>
<p>中断转动任意角度</p>
<ul>
<li>运行后会发现角度并不精确，这是因为真实准确的减速比并不是这个值 <code>1:64</code>，而是 <code>1:63.684</code>，所以把程序里 <code>4096 改成4076</code> 会发现误差小很多了</li>
<li><code>StartMotor 函数</code>中对 <code>EA</code> 的两次操作是因为：STC89C52 单片机是 <code>8 </code>位单片机(即按一个字节进行的)，要操作 <code>多个字节</code>（不论是读还是写）就必须分多次进行了； <code>beats 这个变量是 unsigned long 型，它要占用 4 个字节，那么对它的赋值最少也要分 4 次才能完成</code>；所以执行前先关闭了中断，而等它执行完后，才又重新打开了中断。在它执行过程中单片机是不会响应中断的，即中断函数 time0 不会被执行，即使这时候定时器溢出了，中断发生了，也只能等待 EA 重新置 1 后，才能得到响应，中断函数 time0 才会被执行</li>
</ul>
<p><code>注意需要把跳线帽跳到左边那列(J13~J16)</code></p>
<blockquote>
<h4 id="步进电机基础转动">步进电机基础转动</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR_PORT	P1 <span class="comment">//宏定义步进电机管脚</span></span></span><br><span class="line"></span><br><span class="line">u32 beats = <span class="number">0</span>; <span class="comment">//电机转动节拍总数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>; <span class="comment">//函数调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(u32 angle)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Init(); <span class="comment">//定时器初始化</span></span><br><span class="line">    StartMotor(<span class="number">360</span> * <span class="number">2</span> + <span class="number">180</span>); <span class="comment">//控制电机转动 2 圈半</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xF8</span>;   <span class="comment">//定时 2ms</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动 T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机启动函数，angle-需转过的角度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(u32 angle)</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">0</span>; <span class="comment">//在计算前关闭中断，完成后再打开，以避免中断打断计算过程而造成错误</span></span><br><span class="line">    beats = (angle * <span class="number">4076</span>) / <span class="number">360</span>;  <span class="comment">//实测为 4076 拍转动一圈</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，用于驱动步进电机旋转 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    u8 temp; <span class="comment">//临时变量</span></span><br><span class="line">    <span class="type">static</span> u8 index = <span class="number">0</span>; <span class="comment">//节拍输出索引</span></span><br><span class="line">    u8 code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0x0E</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0x09</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x07</span>, <span class="number">0x06</span>&#125;; <span class="comment">//步进电机节拍对应的 IO 控制代码</span></span><br><span class="line">    TH0 = <span class="number">0xF8</span>; <span class="comment">//重新加载初值</span></span><br><span class="line">    TL0 = <span class="number">0xCD</span>;</span><br><span class="line">    <span class="keyword">if</span>(beats != <span class="number">0</span>) <span class="comment">//节拍数不为 0 则产生一个驱动节拍</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = MOTOR_PORT;       <span class="comment">//用 temp 把步进电机端口当前值暂存</span></span><br><span class="line">        temp &amp;= <span class="number">0xF0</span>;            <span class="comment">//用&amp;操作清零低 4 位</span></span><br><span class="line">        temp |= BeatCode[index]; <span class="comment">//用|操作把节拍代码写到低 4 位</span></span><br><span class="line">        MOTOR_PORT = temp;       <span class="comment">//把低 4 位的节拍代码和高 4 位的原值送回步进电机端口</span></span><br><span class="line">        index++;                 <span class="comment">//节拍输出索引递增</span></span><br><span class="line">        index &amp;= <span class="number">0x07</span>;           <span class="comment">//用&amp;操作实现到 8 归零</span></span><br><span class="line">        beats--;                 <span class="comment">//总节拍数-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//节拍数为 0 则关闭电机所有的相</span></span><br><span class="line">        MOTOR_PORT |= <span class="number">0x0F</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="按键控制步进电机">按键控制步进电机</h4>
</blockquote>
<ul>
<li><code>1~9</code>键：是转动圈数，<code>上下</code>键：正转和反转，<code>左右</code>键：+90度和-90度</li>
<li><code>中断函数用一个静态bit变量实现二分频，即2ms定时，用于控制电机</code></li>
</ul>
<p><code>Motor.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> beats = <span class="number">0</span>; <span class="comment">//电机转动节拍总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机启动函数，angle-需转过的角度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> angle)</span> <span class="comment">//因为涉及正转反转，符号有正负，所以要用signed</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">0</span>; <span class="comment">//在计算前关闭中断，完成后再打开，以避免中断打断计算过程而造成错误</span></span><br><span class="line">    beats = (angle * <span class="number">4076</span>) / <span class="number">360</span>; <span class="comment">//实测为 4076 拍转动一圈</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步进电机停止函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StopMotor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">0</span>;</span><br><span class="line">    beats = <span class="number">0</span>;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 电机转动控制函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TurnMotor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp;   <span class="comment">//临时变量</span></span><br><span class="line">    <span class="type">static</span> u8 index = <span class="number">0</span>; <span class="comment">//节拍输出索引</span></span><br><span class="line">    u8 code BeatCode[<span class="number">8</span>] = &#123;<span class="number">0x0E</span>, <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0x09</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x07</span>, <span class="number">0x06</span>&#125;; <span class="comment">//步进电机节拍对应的 IO 控制代码</span></span><br><span class="line">    <span class="keyword">if</span>(beats != <span class="number">0</span>) <span class="comment">//节拍数不为 0 则产生一个驱动节拍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(beats &gt; <span class="number">0</span>) <span class="comment">//节拍数大于 0 时正转</span></span><br><span class="line">        &#123;</span><br><span class="line">            index++;        <span class="comment">//正转时节拍输出索引递增</span></span><br><span class="line">            index &amp;= <span class="number">0x07</span>;  <span class="comment">//用&amp;操作实现到 8 归零</span></span><br><span class="line">            beats--;        <span class="comment">//正转时节拍计数递减</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>              <span class="comment">//节拍数小于 0 时反转</span></span><br><span class="line">        &#123;</span><br><span class="line">            index--;        <span class="comment">//反转时节拍输出索引递减</span></span><br><span class="line">            index &amp;= <span class="number">0x07</span>;  <span class="comment">//用&amp;操作同样可以实现到-1 时归 7</span></span><br><span class="line">            beats++;        <span class="comment">//反转时节拍计数递增</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp = MOTOR_PORT;       <span class="comment">//用 temp 把步进电机端口当前值暂存</span></span><br><span class="line">        temp &amp;= <span class="number">0xF0</span>;            <span class="comment">//用&amp;操作清零低 4 位</span></span><br><span class="line">        temp |= BeatCode[index]; <span class="comment">//用|操作把节拍代码写到低 4 位</span></span><br><span class="line">        MOTOR_PORT = temp;       <span class="comment">//把低 4 位的节拍代码和高 4 位的原值送回步进电机端口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//节拍数为 0 则关闭电机所有的相</span></span><br><span class="line">    &#123;</span><br><span class="line">        MOTOR_PORT |= <span class="number">0x0F</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Motor.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MOTOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MOTOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOTOR_PORT	P1 <span class="comment">//宏定义步进电机管脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartMotor</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> angle)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StopMotor</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TurnMotor</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//矩阵按键编号到标准键盘键码的映射表</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x26</span> &#125;, <span class="comment">//数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123; <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x25</span> &#125;, <span class="comment">//数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123; <span class="number">0x37</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x28</span> &#125;, <span class="comment">//数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123; <span class="number">0x30</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span> &#125;</span><br><span class="line">&#125;; <span class="comment">//数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line"></span><br><span class="line">u8 Key_State[<span class="number">4</span>][<span class="number">4</span>] =  &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//全部矩阵按键的当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环检测 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i][j] != Key_State[i][j])   <span class="comment">//检测按键动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)             <span class="comment">//按键按下时执行动作</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]); <span class="comment">//调用按键动作函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = Key_State[i][j];   <span class="comment">//刷新前一次的备份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> bit dirMotor = <span class="number">0</span>; <span class="comment">//电机转动方向</span></span><br><span class="line">    <span class="keyword">if</span>((keycode &gt;= <span class="number">0x30</span>) &amp;&amp; (keycode &lt;= <span class="number">0x39</span>)) <span class="comment">//控制电机转动 1-9 圈</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == dirMotor)</span><br><span class="line">            StartMotor(<span class="number">360</span> * (keycode - <span class="number">0x30</span>));   <span class="comment">//正转</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            StartMotor(<span class="number">-360</span> * (keycode - <span class="number">0x30</span>));  <span class="comment">//反转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x26</span> == keycode)  <span class="comment">//向上键，控制转动方向为正转</span></span><br><span class="line">    &#123;</span><br><span class="line">        dirMotor = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x28</span> == keycode)  <span class="comment">//向下键，控制转动方向为反转</span></span><br><span class="line">    &#123;</span><br><span class="line">        dirMotor = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x25</span> == keycode)  <span class="comment">//向左键，固定正转 90 度</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartMotor(<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x27</span> == keycode)  <span class="comment">//向右键，固定反转 90 度</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartMotor(<span class="number">-90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x1B</span> == keycode)  <span class="comment">//Esc 键，停止转动</span></span><br><span class="line">    &#123;</span><br><span class="line">        StopMotor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用，推荐调用间隔 1ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++; <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span> (KeyOut &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	KeyOut = KeyOut &amp; 0x03; //索引值加到 4 即归零</span></span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;  <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能总中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//设置 T0 为模式 1</span></span><br><span class="line">    TH0 = <span class="number">0xFC</span>;   <span class="comment">//定时 1ms</span></span><br><span class="line">    TL0 = <span class="number">0x66</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动 T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	Time0_Init(); <span class="comment">//定时器初始化</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Key_Driver(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，用于按键扫描与电机转动控制 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> bit div = <span class="number">0</span>; <span class="comment">//标志</span></span><br><span class="line">	TH0 = <span class="number">0xFC</span>;  <span class="comment">//重新加载初值</span></span><br><span class="line">	TL0 = <span class="number">0x66</span>;</span><br><span class="line">	Key_Scan();  <span class="comment">//执行按键扫描</span></span><br><span class="line">	<span class="comment">//用一个静态 bit 变量实现二分频，即 2ms 定时，用于控制电机</span></span><br><span class="line">	div = ~div;  <span class="comment">//1ms改变一次值</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span> == div) <span class="comment">//每2ms调用电机控制函数</span></span><br><span class="line">	&#123;</span><br><span class="line">		TurnMotor(); <span class="comment">//电机转动控制函数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Motor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="蜂鸣器">蜂鸣器</h2>
<p>蜂鸣器从<code>结构</code>区分分为<code>压电式蜂鸣器</code>和<code>电磁式蜂鸣器</code>。压电式为压电陶瓷片发音，电流 比较小一些，电磁式蜂鸣器为线圈通电震动发音，体积比较小</p>
<p>按照<code>驱动方式</code>分为<code>有源蜂鸣器</code>和<code>无源蜂鸣器</code>。这里的有源和无源不是指电源，而是<code>振荡源</code>。有源蜂鸣器内部带了振荡源，给了 BUZZ 引脚一个<code>低电平</code>，蜂鸣器就会直接响。而无源蜂鸣器内部是不带振荡源的，要让他响必须给 500Hz～4.5KHz 之间的<code>脉冲频率信号</code>来驱动它才会响</p>
<h3 id="原理图-2">原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221001102625.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221001103851.jpg" style="zoom:80%;" />
<p>蜂鸣器电流依然相对较大，因此需要用<code>三极管</code>驱动，并且加了一个 100 欧的电阻作为<code>限流电阻</code>。此外还加了一个 D4 二极管，这个二极管叫做<code>续流二极管</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重装载计算</span></span><br><span class="line">reload = <span class="number">65536</span> - (<span class="number">11059200</span>/<span class="number">12</span>)/(frequ*<span class="number">2</span>);  <span class="comment">//由给定频率计算定时器重载值</span></span><br><span class="line">T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(reload &gt;&gt; <span class="number">8</span>);  <span class="comment">//16位重载值分解为高低两个字节,因为51单片机是8位的需要分两次写入</span></span><br><span class="line">T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)reload;</span><br></pre></td></tr></table></figure>
<h3 id="程序-4">程序</h3>
<blockquote>
<h4 id="蜂鸣器演示">蜂鸣器演示</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>; <span class="comment">//蜂鸣器控制引脚</span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>;   <span class="comment">//T0重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;   <span class="comment">//T0重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Open_BUZZ</span><span class="params">(u16 frequ)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Stop_BUZZ</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//使能全局中断</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0工作在模式1，但先不启动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Open_BUZZ(<span class="number">4000</span>);            <span class="comment">//以4KHz的频率启动蜂鸣器</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">        Stop_BUZZ();                <span class="comment">//停止蜂鸣器</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">        Open_BUZZ(<span class="number">1000</span>);            <span class="comment">//以1KHz的频率启动蜂鸣器</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">        Stop_BUZZ();                <span class="comment">//停止蜂鸣器</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">40000</span>; i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器启动函数，frequ-工作频率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Open_BUZZ</span><span class="params">(u16 frequ)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 reload;  <span class="comment">//计算所需的定时器重载值</span></span><br><span class="line">    reload = <span class="number">65535</span> - (<span class="number">11059200</span> / <span class="number">12</span>) / (frequ * <span class="number">2</span>); <span class="comment">//由给定频率计算定时器重载值</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(reload &gt;&gt; <span class="number">8</span>);            <span class="comment">//16位重载值分解为高低两个字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)reload;</span><br><span class="line">    TH0 = <span class="number">0xFF</span>;  <span class="comment">//设定一个接近溢出的初值，以使定时器马上投入工作</span></span><br><span class="line">    TL0 = <span class="number">0xFE</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;     <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;     <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 蜂鸣器停止函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Stop_BUZZ</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ET0 = <span class="number">0</span>; <span class="comment">//禁用T0中断</span></span><br><span class="line">    TR0 = <span class="number">0</span>; <span class="comment">//停止T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，用于控制蜂鸣器发声 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    BUZZ = ~BUZZ; <span class="comment">//反转蜂鸣器控制电平</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="门铃">门铃</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>; <span class="comment">//蜂鸣器控制引脚</span></span><br><span class="line">u8 ding, dong, flag, stop;</span><br><span class="line">u16 count; <span class="comment">//定时标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Tnit</span><span class="params">()</span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Tnit();</span><br><span class="line">    Mark_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Tnit</span><span class="params">()</span>    <span class="comment">//定时器0初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD = <span class="number">0X01</span>;     <span class="comment">//定时器0 方式1</span></span><br><span class="line">    TH0 = <span class="number">0Xff</span>;</span><br><span class="line">    TL0 = <span class="number">0X06</span>;      <span class="comment">//定时250us</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    ET0 = <span class="number">1</span>;</span><br><span class="line">    TR0 = <span class="number">1</span>;         <span class="comment">//打开定时器0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Mark_Init</span><span class="params">()</span>   <span class="comment">//各个标号初始化</span></span><br><span class="line">&#123;</span><br><span class="line">    ding = <span class="number">0</span>;      <span class="comment">//叮声音  计数标志</span></span><br><span class="line">    dong = <span class="number">0</span>;      <span class="comment">//咚声音  计数标志</span></span><br><span class="line">    count = <span class="number">0</span>;     <span class="comment">//定时0.5s标志</span></span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">    stop = <span class="number">0</span>;      <span class="comment">//结束标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">    TH0 = <span class="number">0Xff</span>; <span class="comment">//重载初值</span></span><br><span class="line">    TL0 = <span class="number">0X06</span>;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">2000</span>)      <span class="comment">//定时0.5s  叮响0.5秒，咚响0.5秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//以下代码实现叮咚响切换</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = ~flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            stop = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过改变定时计数时间可以改变门铃的声音</span></span><br><span class="line">        ding++;              <span class="comment">//叮</span></span><br><span class="line">        <span class="keyword">if</span>(ding == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ding = <span class="number">0</span>;</span><br><span class="line">            BUZZ = ~BUZZ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dong++;</span><br><span class="line">        <span class="keyword">if</span>(dong == <span class="number">2</span>)        <span class="comment">//咚</span></span><br><span class="line">        &#123;</span><br><span class="line">            dong = <span class="number">0</span>;</span><br><span class="line">            BUZZ = ~BUZZ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PWM">PWM</h2>
<p>PWM 又叫<code>脉冲宽度调制</code>，它利用微处理器的数字输出来对模拟电路进行控制的一种有效的技术，其实就是<code>使用数字信号达到一个模拟信号的效果</code>。脉冲宽度调制，就是改变脉冲宽度来实现不同的效果</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221001142129.jpg" style="zoom:67%;" />
<p>这是一个周期是 10ms，即频率是 100Hz 的波形，但是每个周期内，高低电平脉冲宽度各不相同，这就是 PWM 的本质</p>
<p>占空比是指<code>高电平的时间占整个周期的比例</code>。比如第一部分波形的占空比是 40%，第二部分波形占空比是 60%，第三部分波形占空比是 80%，这就是 PWM 的解释</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">周期与频率的关系是互为倒数，周期单位是s，所以需要转换,如下面：</span><br><span class="line"><span class="number">10</span>ms = <span class="number">0.01</span>s --&gt; <span class="number">1</span>/<span class="number">0.01</span>s = <span class="number">100</span>Hz</span><br><span class="line"><span class="number">100</span>Hz = <span class="number">1</span> / <span class="number">100</span> = <span class="number">0.01</span>s = <span class="number">10</span>ms</span><br></pre></td></tr></table></figure>
<h3 id="程序-5">程序</h3>
<blockquote>
<h4 id="呼吸灯">呼吸灯</h4>
</blockquote>
<ul>
<li>利用 <code>2个定时器+2个中断</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line">sbit ADDR0 = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit ADDR1 = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit ADDR2 = P1 ^ <span class="number">2</span>;</span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line">sbit PWMOUT = P0 ^ <span class="number">0</span>; <span class="comment">//定义用PWM控制的LED管脚(第一个LED灯)</span></span><br><span class="line"></span><br><span class="line">u32 Period_Count = <span class="number">0</span>; <span class="comment">//PWM 周期计数值</span></span><br><span class="line">u8 HighRH = <span class="number">0</span>;        <span class="comment">//高电平重载值的高字节</span></span><br><span class="line">u8 HighRL = <span class="number">0</span>;        <span class="comment">//高电平重载值的低字节</span></span><br><span class="line">u8 LowRH = <span class="number">0</span>;         <span class="comment">//低电平重载值的高字节</span></span><br><span class="line">u8 LowRL = <span class="number">0</span>;         <span class="comment">//低电平重载值的低字节</span></span><br><span class="line">u8 T1RH = <span class="number">0</span>;          <span class="comment">//T1 重载值的高字节</span></span><br><span class="line">u8 T1RL = <span class="number">0</span>;          <span class="comment">//T1 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_PWM</span><span class="params">(u16 freq, u16 duty)</span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time1_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;</span><br><span class="line">    ADDR3 = <span class="number">1</span>; <span class="comment">//使能独立 LED</span></span><br><span class="line">    ADDR2 = <span class="number">1</span>;</span><br><span class="line">    ADDR1 = <span class="number">1</span>;</span><br><span class="line">    ADDR0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Config_PWM(<span class="number">100</span>, <span class="number">10</span>); <span class="comment">//配置并启动 PWM</span></span><br><span class="line">    Config_Time1(<span class="number">50</span>);   <span class="comment">//用 T1 定时调整占空比</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动 PWM，freq-频率，duty-占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_PWM</span><span class="params">(u16 freq, u16 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 high, low;</span><br><span class="line">    Period_Count = (<span class="number">11059200</span> / <span class="number">12</span>) / freq; <span class="comment">//计算一个周期所需的计数值</span></span><br><span class="line">    high = (Period_Count * duty) / <span class="number">100</span>;    <span class="comment">//计算高电平所需的计数值</span></span><br><span class="line">    low = Period_Count - high;             <span class="comment">//计算低电平所需的计数值</span></span><br><span class="line">    high = <span class="number">65536</span> - high + <span class="number">12</span>;              <span class="comment">//计算高电平的定时器重载值并补偿中断延时</span></span><br><span class="line">    low = <span class="number">65536</span> - low + <span class="number">12</span>;                <span class="comment">//计算低电平的定时器重载值并补偿中断延时</span></span><br><span class="line">    HighRH = (<span class="type">unsigned</span> <span class="type">char</span>)(high &gt;&gt; <span class="number">8</span>);   <span class="comment">//高电平重载值拆分为高低字节</span></span><br><span class="line">    HighRL = (<span class="type">unsigned</span> <span class="type">char</span>)high;</span><br><span class="line">    LowRH = (<span class="type">unsigned</span> <span class="type">char</span>)(low &gt;&gt; <span class="number">8</span>);     <span class="comment">//低电平重载值拆分为高低字节</span></span><br><span class="line">    LowRL = (<span class="type">unsigned</span> <span class="type">char</span>)low;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零 T0 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置 T0 为模式 1</span></span><br><span class="line">    TH0 = HighRH; <span class="comment">//加载 T0 重载值</span></span><br><span class="line">    TL0 = HighRL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能 T0 中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动 T0</span></span><br><span class="line">    PWMOUT = <span class="number">1</span>;   <span class="comment">//输出高电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动 T1，ms-定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time1_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">12</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T1RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T1RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x10</span>; <span class="comment">//配置 T1 为模式 1</span></span><br><span class="line">    TH1 = T1RH;   <span class="comment">//加载 T1 重载值</span></span><br><span class="line">    TL1 = T1RL;</span><br><span class="line">    ET1 = <span class="number">1</span>;      <span class="comment">//使能 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;      <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 占空比调整函数，频率不变只调整占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Adjust_duty</span><span class="params">(u16 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 high, low;</span><br><span class="line">    high = (Period_Count * duty) / <span class="number">100</span>;  <span class="comment">//计算高电平所需的计数值</span></span><br><span class="line">    low = Period_Count - high;           <span class="comment">//计算低电平所需的计数值</span></span><br><span class="line">    high = <span class="number">65536</span> - high + <span class="number">12</span>;            <span class="comment">//计算高电平的定时器重载值并补偿中断延时</span></span><br><span class="line">    low = <span class="number">65536</span> - low + <span class="number">12</span>;              <span class="comment">//计算低电平的定时器重载值并补偿中断延时</span></span><br><span class="line">    HighRH = (<span class="type">unsigned</span> <span class="type">char</span>)(high &gt;&gt; <span class="number">8</span>); <span class="comment">//高电平重载值拆分为高低字节</span></span><br><span class="line">    HighRL = (<span class="type">unsigned</span> <span class="type">char</span>)high;</span><br><span class="line">    LowRH = (<span class="type">unsigned</span> <span class="type">char</span>)(low &gt;&gt; <span class="number">8</span>);   <span class="comment">//低电平重载值拆分为高低字节</span></span><br><span class="line">    LowRL = (<span class="type">unsigned</span> <span class="type">char</span>)low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，产生 PWM 输出 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == PWMOUT) <span class="comment">//当前输出为高电平时，装载低电平值并输出低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        TH0 = LowRH;</span><br><span class="line">        TL0 = LowRL;</span><br><span class="line">        PWMOUT = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">//当前输出为低电平时，装载高电平值并输出高电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        TH0 = HighRH;</span><br><span class="line">        TL0 = HighRL;</span><br><span class="line">        PWMOUT = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T1 中断服务函数，定时动态调整占空比 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time1</span><span class="params">()</span> interrupt 3</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> bit dir = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 index = <span class="number">0</span>;</span><br><span class="line">    u8 code  table[<span class="number">13</span>] = &#123;<span class="number">5</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">41</span>, <span class="number">51</span>, <span class="number">60</span>, <span class="number">68</span>, <span class="number">75</span>, <span class="number">81</span>, <span class="number">86</span>, <span class="number">90</span>, <span class="number">93</span>, <span class="number">95</span>&#125;; <span class="comment">//占空比调整表</span></span><br><span class="line">    TH1 = T1RH; <span class="comment">//重新加载 T1 重载值</span></span><br><span class="line">    TL1 = T1RL;</span><br><span class="line">    Adjust_duty(table[index]); <span class="comment">//调整 PWM 的占空比</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == dir)</span><br><span class="line">    &#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == index)</span><br><span class="line">        &#123;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UART-串口通信">UART 串口通信</h2>
<p>UART 即<code>通用异步收发器</code>，串行通信通常用于单片机和电脑之间以及单片机和单片机之间的通信</p>
<h3 id="串口通信相关术语">串口通信相关术语</h3>
<p>通信的方式可以分为多种，按照数据<code>传送方式</code>可分为<code>串行通信</code>和<code>并行通信</code>。按照通信的数据<code>同步方式</code>，可分为<code>异同通信</code>和<code>同步通信</code>。按照数据的<code>传输方向</code>又可分为<code>单工</code>、<code>半双工</code>和<code>全双工通信</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全双工：通信双方可以在同一时刻互相传输数据 </span><br><span class="line">半双工：通信双方可以互相传输数据，但必须分时复用一根数据线</span><br><span class="line">单工：通信只能有一方发送到另一方，不能反向传输 </span><br><span class="line">异步：通信双方各自约定通信速率 </span><br><span class="line">同步：通信双方靠一根时钟线来约定通信速率 </span><br><span class="line">总线：连接各个设备的数据传输线路(类似于一条马路，把路边各住户连接起来，使住户可以相互交流)</span><br></pre></td></tr></table></figure>
<p>STC89C52 有两个引脚是专门用来做 UART 串行通信的，一个是 <code>P3.0</code> 一个是 <code>P3.1</code>，它们 还分别有另外的名字叫做 <code>RXD</code> 和 <code>TXD</code>，由它们组成的通信接口就叫做<code>串行接口</code>，简称串口。 用两个单片机进行 UART 串口通信</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-02%20005258.webp" style="zoom:33%;" />
<p>GND 表示单片机系统电源的参考地，<code>TXD 是串行发送引脚，RXD 是串行接收引脚</code>。两个单片机之间要通信，首先电源基准得一样</p>
<p><strong>（1）串行通信</strong></p>
<p>串行通信是指<code>使用一条数据线，将数据一位一位地依次传输</code>，每一位数据占据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机、计算机与外设之间的远距离通信。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/12589b57cc2a47c1affdd41ecc0572d6.webp" style="zoom:50%;" />
<p>串行通信的特点：传输线少，长距离传送时成本低，且可以利用电话网等现成的设备，但数据的传送控制比并行通信复杂。</p>
<p><strong>（2）并行通信</strong></p>
<p>并行通信通常是将数据字节的各位用<code>多条数据线同时进行传送</code>，通常是 8 位、16 位、32 位等数据一起传输。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/eb76b85de109425f89a0022265d39d70.webp" style="zoom:50%;" />
<p>并行通信的特点：控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难，抗干扰能力差。</p>
<p><strong>（3）异步通信</strong></p>
<p>异步通信是指<code>通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程</code>。为使双方的收发协调，要求发送和接收设备的<code>时钟尽可能一致</code>。</p>
<p>异步通信是以<code>字符</code>（构成的帧）为单位进行传输，字符与字符之间的间隙（时间间隔）是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间不 一定有“位间隔”的整数倍的关系，但同一字符内的各位之间的距离均为“ 位间隔”的整数倍。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/fc5638ed2f844a328d7f9072915d1992.webp" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/38440152295143bea5f60f3f1e33e727.webp" style="zoom:48%;" />
<p>异步通信的特点：不要求收发双方时钟的严格一致，实现容易，设备开销较小，但每个字符要附加 2～3 位用于起止位，各帧之间还有间隔，因此传输效率不高。</p>
<p><strong>（4）同步通信</strong></p>
<p>同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到<code>完全同步</code>。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步可以通过两种方法实现。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/8bc79b08ff0e4acbbe1bde31d7962602.webp" style="zoom:40%;" />
<p><strong>（5）单工通信</strong></p>
<p>单工是指数据传输仅能沿一个方向，不能实现反向传输。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/582511011b1b4a33b377a525926f366d.webp" style="zoom: 60%;" />
<p><strong>（6）半双工通信</strong></p>
<p>半双工是指数据传输可以沿两个方向，但需要分时进行。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/340c7cf2e06d4dc781916f3ac5f9c8b0.webp" style="zoom: 50%;" />
<p><strong>（7）全双工通信</strong></p>
<p>全双工是指数据可以同时进行双向传输。如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/942ed54e1b9d4c4f91630b3eb4c13d5c.webp" style="zoom: 50%;" />
<p><strong>（8）通信速率</strong></p>
<p>比特率是 <code>每秒钟传输二进制代码的位数</code>，单位是：<code>位／秒</code>（ bps）。如每秒钟传送 240 个字符，而每个字符格式包含 10 位(1 个起始位、1 个停止位、8 个数据位)，这时的比特率为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>10</mn><mtext>位</mtext><mo>×</mo><mn>240</mn><mtext>个/秒</mtext><mo>=</mo><mn>2400</mn><mi>b</mi><mi>p</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">10 \text{位} ×240 \text{个/秒} = 2400 bps
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">10</span><span class="mord text"><span class="mord cjk_fallback">位</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">240</span><span class="mord text"><span class="mord cjk_fallback">个</span><span class="mord">/</span><span class="mord cjk_fallback">秒</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2400</span><span class="mord mathnormal">b</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p>波特率： 它<code>表示每秒钟传输了多少个码元</code>。通信中常用时间间隔相同的符号来表示一个二进制数字，这样的信号称为码元。用 <code>0V 表示数字 0，5V 表示数字 1</code>，那么 <code>一个码元可以表示两种状态 0 和 1</code>，所以一个码元等于一个二进制比特位，此时波特率的大小与比特率一致；如果在通信传输中，有 0V、 2V、4V 以及 6V 分别表示二进制数 00、 01、 10、 11，那么每个码元可以表示四种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候的波特率为比特率的一半。由于很多常见的通信中一个码元都是表示两种状态，所以我们常常直接以 <code>波特率来表示比特率</code>。</p>
<p>波特率就是<code>发送二进制数据位的速率</code>，习惯上用 <code>baud</code> 表示，即我们发送一位二进制数据的持续时间 = <code>1/baud</code>。在通信之前，单片机 1 和单片机 2 首先都要明确的约定好它们之间的<code>通信波特率，必须保持一致</code>，收发双方才能正常实现通信</p>
<blockquote>
<p>问：约定好速度后，我们还要考虑第二个问题，数据什么时候是起始，什么时候是结束呢？</p>
</blockquote>
<p>不管是提前接收还是延迟接收，数据都会接收错误。在 UART 通信的时候， <code>一个字节是 8 位</code>， 规定 <code>当没有通信信号发生时，通信线路保持高电平</code>，当要 <code>发送数据之前，先发一位 0 表示起始位</code>，然后 <code>发送 8 位数据位</code>，数据位是 <code>先低后高</code>的顺序，数据位发完后 <code>再发一位 1 表示停止位</code>，加起来一共发送 <code>10位</code>；而接收方呢，原本一直保持的高电平， <code>一旦检测到了一位低电平</code>，那就知道了要 <code>开始准备接收数据</code>了，接收到 8 位数据位后，然后 <code>检测到高电平(停止位)</code>，再 <code>准备下一个数据的接收</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221001202151.jpg" style="zoom:67%;" />
<h3 id="RS232-通信接口">RS232 通信接口</h3>
<p>●RS232 通信接口 ：就是台式电脑那些 “9针&quot;和&quot;9孔”(公头/母头)串行接口，虽然RS232也有 “RXD”,“TXD”,“GND”，但是却不能直接和单片机连接，因为它们的电平不相同，不是所有的电路都是 5V 代表高电平而 0V 代表低电平的，对于RS232标准来说，它是 “反逻辑”，即 “<code>低电平代表的是 1，而高电平代表的是 0</code>”，所以需要用一个电平转换芯片 “<code>MAX232</code>” 作为中间人将它们两电平互相转化从而可以互相通信</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f090bc2db98a4124940dd32d27cbdc57.webp" style="zoom: 33%;" />
<blockquote>
<p>CH340T芯片</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-02%20012411.webp" style="zoom: 33%;" />
<p>这个芯片就可以实现把标准 RS232 串口电平转换成我们单片机能够识别和承受的 UART  0V/5V 电平。其实 RS232 串口和 UART 串口，它们的协议类型是一样的，只是电平标准不同而已，而 <code>MAX232 这个芯片起到的就是中间人的作用</code>，它把 UART 电平转换成 RS232 电平，也把 RS232 电平转换成 UART 电平，从而实现标准 RS232 接口和单片机 UART 之间的通信连接</p>
<h3 id="IO-口模拟-UART-串口通信">IO 口模拟 UART 串口通信</h3>
<p>把 P3.0 和 P3.1 当做 IO 口来进行模拟实际串口通信的过程 (了解即可)</p>
<blockquote>
<p>串口调试助手的使用</p>
</blockquote>
<p>串口调试助手的实质就是利用电脑上的 UART 通信接口，发送数据给我们的单片机，也可以把我们的单片机发送的数据接收到这个调试助手界面上</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-02%20113632.webp" style="zoom:40%;" />
<p>配置波特率的时候，我们用的是<code>定时器 T0 的模式 2</code>(8位自动装载模式)。模式 2 中，不再是 TH0 代表高 8 位，TL0 代表低 8 位了，而只有 TL0 在进行计数，<code>当 TL0 溢出后，不仅仅会让 TF0 变 1，而且还会将 TH0 中的内容重新自动装到 TL0 中</code>，好处是：可以把想要的定时器初值提前存在 TH0 中，当 TL0 溢出后，TH0 自动把初值就重新送入 TL0 了，全自动的，不需要程序中再给 TL0 重新赋值 了</p>
<blockquote>
<h4 id="IO-口模拟-UART-串口通信-串口发送数据则接收该数据-1">IO 口模拟 UART 串口通信(串口发送数据则接收该数据+1)</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line">sbit PIN_RXD = P3 ^ <span class="number">0</span>; <span class="comment">//接收引脚定义</span></span><br><span class="line">sbit PIN_TXD = P3 ^ <span class="number">1</span>; <span class="comment">//发送引脚定义</span></span><br><span class="line"></span><br><span class="line">bit RxdOrTxd = <span class="number">0</span>;  <span class="comment">//指示当前状态为接收还是发送</span></span><br><span class="line">bit RxdEnd = <span class="number">0</span>;    <span class="comment">//接收结束标志</span></span><br><span class="line">bit TxdEnd = <span class="number">0</span>;    <span class="comment">//发送结束标志</span></span><br><span class="line">u8 RxdBuf = <span class="number">0</span>;     <span class="comment">//接收缓冲器</span></span><br><span class="line">u8 TxdBuf = <span class="number">0</span>;     <span class="comment">//发送缓冲器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTXD</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StartRXD</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    EA = <span class="number">1</span>;            <span class="comment">//开总中断</span></span><br><span class="line">    ConfigUART(<span class="number">9600</span>);  <span class="comment">//配置波特率为9600</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (PIN_RXD);        <span class="comment">//等待接收引脚出现低电平，即起始位</span></span><br><span class="line">        StartRXD();             <span class="comment">//启动接收</span></span><br><span class="line">        <span class="keyword">while</span> (!RxdEnd);        <span class="comment">//等待接收完成</span></span><br><span class="line">        StartTXD(RxdBuf + <span class="number">1</span>);   <span class="comment">//接收到的数据+1后，发送回去</span></span><br><span class="line">        <span class="keyword">while</span> (!TxdEnd);        <span class="comment">//等待发送完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ConfigUART</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>;   <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x02</span>;   <span class="comment">//配置T0为模式2</span></span><br><span class="line">    TH0 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span>) / baud; <span class="comment">//计算T0重载值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动串行接收 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartRXD</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    TL0 = <span class="number">256</span> - ((<span class="number">256</span> - TH0) &gt;&gt; <span class="number">1</span>); <span class="comment">//接收启动时的T0定时为半个波特率周期</span></span><br><span class="line">    ET0 = <span class="number">1</span>;        <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;        <span class="comment">//启动T0</span></span><br><span class="line">    RxdEnd = <span class="number">0</span>;     <span class="comment">//清零接收结束标志</span></span><br><span class="line">    RxdOrTxd = <span class="number">0</span>;   <span class="comment">//设置当前状态为接收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动串行发送，dat-待发送字节数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartTXD</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    TxdBuf = dat;   <span class="comment">//待发送数据保存到发送缓冲器</span></span><br><span class="line">    TL0 = TH0;      <span class="comment">//T0计数初值为重载值</span></span><br><span class="line">    ET0 = <span class="number">1</span>;        <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;        <span class="comment">//启动T0</span></span><br><span class="line">    PIN_TXD = <span class="number">0</span>;    <span class="comment">//发送起始位</span></span><br><span class="line">    TxdEnd = <span class="number">0</span>;     <span class="comment">//清零发送结束标志</span></span><br><span class="line">    RxdOrTxd = <span class="number">1</span>;   <span class="comment">//设置当前状态为发送</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0中断服务函数，处理串行发送和接收 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 cnt = <span class="number">0</span>; <span class="comment">//位接收或发送计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RxdOrTxd)  <span class="comment">//串行发送处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= <span class="number">8</span>)  <span class="comment">//低位在先依次发送8bit数据位</span></span><br><span class="line">        &#123;</span><br><span class="line">            PIN_TXD = TxdBuf &amp; <span class="number">0x01</span>;	<span class="comment">//&amp;0x01表示发送最低位</span></span><br><span class="line">            TxdBuf &gt;&gt;= <span class="number">1</span>;             <span class="comment">//将次低位右移到最低位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">9</span>)  <span class="comment">//发送停止位</span></span><br><span class="line">        &#123;</span><br><span class="line">            PIN_TXD = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>            <span class="comment">//发送结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;    <span class="comment">//复位bit计数器</span></span><br><span class="line">            TR0 = <span class="number">0</span>;    <span class="comment">//关闭T0</span></span><br><span class="line">            TxdEnd = <span class="number">1</span>; <span class="comment">//置发送结束标志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                  <span class="comment">//串行接收处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)     <span class="comment">//处理起始位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PIN_RXD) <span class="comment">//起始位为0时，清零接收缓冲器，准备接收数据位</span></span><br><span class="line">            &#123;</span><br><span class="line">                RxdBuf = <span class="number">0</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>          <span class="comment">//起始位不为0时，中止接收</span></span><br><span class="line">            &#123;</span><br><span class="line">                TR0 = <span class="number">0</span>;  <span class="comment">//关闭T0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt;= <span class="number">8</span>)   <span class="comment">//处理8位数据位</span></span><br><span class="line">        &#123;</span><br><span class="line">            RxdBuf &gt;&gt;= <span class="number">1</span>;    <span class="comment">//低位在先，所以将之前接收的位向右移</span></span><br><span class="line">            <span class="keyword">if</span> (PIN_RXD)     <span class="comment">//接收脚为1时，缓冲器最高位置1，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//而为0时不处理即仍保持移位后的0</span></span><br><span class="line">                RxdBuf |= <span class="number">0x80</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//停止位处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;         <span class="comment">//复位bit计数器</span></span><br><span class="line">            TR0 = <span class="number">0</span>;         <span class="comment">//关闭T0</span></span><br><span class="line">            <span class="keyword">if</span> (PIN_RXD)     <span class="comment">//停止位为1时，方能认为数据有效</span></span><br><span class="line">            &#123;</span><br><span class="line">                RxdEnd = <span class="number">1</span>;  <span class="comment">//置接收结束标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="USB-转串口通信">USB 转串口通信</h3>
<p>●USB 转串口通信，笔记本跟单片机通信需要在电路上添加一个 “<code>USB 转串口芯片</code>”，就可以成功实现 USB 通信协议和标准UART 串行通信协议的转换</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-02%20012650.webp" style="zoom: 40%;" />
<p>图中左下方 J1 和 J2 是两个跳线的组合，我们需要用跳线帽把<code>中间和下边的针短接</code>在一起。右侧的 CH340T 这个电路，把电源、晶振接好后，<code>6 脚和 7 脚的 DP 和 DM 分别接 USB 口的 2 个数据引脚上去，3 脚和 4 脚通过跳线接到了单片机的 TXD 和 RXD 上去</code></p>
<h3 id="串口相关寄存器">串口相关寄存器</h3>
<h4 id="串口控制寄存器-SCON">串口控制寄存器 SCON</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/23e02182609a4ef99be73518dc8d9b1c.webp" style="zoom:40%;" />
<p><strong>SM2</strong>：<code>多机通信控制位，主要用于方式 2 和方式 3</code>。当 SM2=1 时可以利用收到的 RB8 来控制是否激活 RI（RB8＝0 时不激活 RI，收到的信息丢弃；RB8＝1 时收到的数据进入 SBUF，并激活 RI，进而在中断服务中将数据从 SBUF 读走）。当 SM2=0 时，不论收到的 RB8 为 0 和 1，均可以使收到的数据进入 SBUF，并激活 RI （即此时 RB8 不具有控制 RI 激活的功能）。通过控制 SM2，可以实现多机通信。</p>
<p><strong>REN</strong>：<code>允许串行接收位</code>。由软件置 REN=1，则启动串行口接收数据；若软件置REN=0，则禁止接收。</p>
<p><strong>TB8</strong>：在方式 2 或方式 3 中，是发送数据的第 9 位，可以用软件规定其作用。 可以用作数据的奇偶校验位，或在多机通信中，作为地址帧/数据帧的标志位。 在<code>方式 0 和方式 1</code> 中，该位未用到。</p>
<p><strong>RB8</strong>：在方式 2 或方式 3 中，是接收到数据的第 9 位，作为奇偶校验位或地址帧/数据帧的标志位。在<code>方式 1 时，若 SM2=0，则 RB8 是接收到的停止位</code>。</p>
<p><strong>TI</strong>：<code>发送中断标志位</code>。在方式 0 时，当串行发送第 8 位数据结束时，或在其它方式，串行发送停止位的开始时，由内部硬件使 TI 置 1，向 CPU 发中断申请。 在<code>中断服务程序</code>中，必须用<code>软件将其清 0</code>，取消此中断申请。</p>
<p><strong>RI</strong>：<code>接收中断标志位</code>。在方式 0 时，当串行接收第 8 位数据结束时，或在其它方式，串行接收停止位的中间时，由内部硬件使 RI 置 1，向 CPU 发中断申请。 也必须在<code>中断服务程序</code>中，用<code>软件将其清 0</code>，取消此中断申请。</p>
<p>SM0 和 SM1 为工作方式选择位：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/d364ee2949db449393a4204dbe16648b.webp" style="zoom:38%;" />
<p>模式1： <code>1 位起始位，8 位数据位和 1 位停止位</code></p>
<p>波特率发生器：波特率发生器只能由 <code>定时器 T1 </code>或 <code>定时器 T2 </code>产生，<code>定时器 T1必须使用模式 2，也就是自动重装载模式</code></p>
<h4 id="电源控制寄存器-PCON">电源控制寄存器 PCON</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/600fe4f75bde490a8b4213b260988a50.webp" style="zoom:40%;" />
<p><strong>SMOD</strong>：<code>波特率倍增位</code>。在串口方式 1、方式 2、方式 3 时，波特率与 SMOD 有 关，当 SMOD=1 时，波特率提高一倍。复位时，SMOD=0。</p>
<h4 id="SBUF寄存器">SBUF寄存器</h4>
<p>串口通信的发送和接收电路在物理上有 2 个名字相同的 SBUF 寄存器，它们的地址也都 是 <code>0x99</code>，但是一个用来做 <code>发送缓冲</code>，一个用来做 <code>接收缓冲</code>，每次只操作 SBUF，单片机会自动根据对它执行的是“<code>读</code>”还是“<code>写</code>”操作来选择是<code>接收 SBUF</code> 还是 <code>发送 SBUF</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器的重载值计算公式为：</span></span><br><span class="line">TH1 = TL1 = <span class="number">256</span> - (晶振值 / <span class="number">12</span> / <span class="number">2</span> / <span class="number">16</span> / 波特率)</span><br></pre></td></tr></table></figure>
<p><strong>256</strong>：定时器模式2 ， 8 位定时器的溢出值，也就是 <code>TL1 的溢出值</code><br>
<strong>晶振值</strong>：<code>11059200</code><br>
<strong>12</strong>：一个机器周期(STC89C52中<code>一个时钟周期等于12个时钟周期</code>)<br>
<strong>16</strong>：串口模块将一位信号采集16次，将其中7,8,9次取出来，如果这三次中两次对如果是高电平就认为这位数据是1.<br>
<strong>波特率</strong>：要设定的波特率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//电源管理寄存器 PCON，设置它可以将波特率提高一倍</span></span><br><span class="line">PCON |= <span class="number">0x80</span></span><br><span class="line"><span class="comment">//此时公式是：           </span></span><br><span class="line">TH1 = TL1 = <span class="number">256</span> - (晶振值 / <span class="number">12</span> / <span class="number">16</span> / 波特率)</span><br></pre></td></tr></table></figure>
<h3 id="串口初始化步骤">串口初始化步骤</h3>
<blockquote>
<ol>
<li>
<p>配置串口为<code>模式 1</code> （SCON 寄存器）</p>
</li>
<li>
<p>配置定时器 T1 为<code>模式 2</code>，即自动重装模式（TMOD 寄存器）</p>
</li>
<li>
<p>根据波特率计算 TH1 和 TL1 的初值，如果有需要可以使用 PCON 进行波特率加倍</p>
</li>
<li>
<p>打开定时器控制寄存器 TR1，让定时器跑起来</p>
</li>
</ol>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/88ee872e113c42ac8b20cf7931edcb5c.png" style="zoom: 33%;" />
<p><strong>注意</strong>：</p>
<ol>
<li>
<p>在使用 T1 做波特率发生器的时候，千万不要再使能 T1 的 中断</p>
</li>
<li>
<p>因为接收和发送触发的是同一个串口中断，所以在串口中断函数中就必须先判断是哪种中断，然后再作出相应的处理（UART中断号是4）</p>
</li>
</ol>
<h3 id="程序-6">程序</h3>
<blockquote>
<h4 id="串口发送数据则接收到的数据为-发送的数据-1">串口发送数据则接收到的数据为 发送的数据+1</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UART_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    u8 rec_data; <span class="comment">//定义一个变量接收数据</span></span><br><span class="line">    <span class="keyword">if</span> (RI)      <span class="comment">//接收到字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;    <span class="comment">//串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请</span></span><br><span class="line">        rec_data = SBUF;     <span class="comment">//存储接收到的数据</span></span><br><span class="line">        SBUF = rec_data + <span class="number">1</span>; <span class="comment">//将接收到的 数据 + 1 放入到发送寄存器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TI)        <span class="comment">//字节发送完毕，发送完成 TI 会自动置 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;    <span class="comment">//串行发送停止位的开始时，内部硬件会将TI置 1，要清除发送完成标志位，需要清0，取消此中断申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="单片机串口调试助手发送的数据，在数码管上显示出来">单片机串口调试助手发送的数据，在数码管上显示出来</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义LED和数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF</span></span><br><span class="line">u8 T0RH = <span class="number">0</span>;  <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;  <span class="comment">//T0 重载值的低字节</span></span><br><span class="line">u8 RxdByte = <span class="number">0</span>; <span class="comment">//串口接收到的字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//选择数码管</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Time0_Init(<span class="number">1</span>);   <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    UART_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将接收字节在数码管上以十六进制形式显示出来</span></span><br><span class="line">        SMG_BUFF[<span class="number">0</span>] = gsmg[RxdByte &amp; <span class="number">0x0F</span>]; <span class="comment">//低四位</span></span><br><span class="line">        SMG_BUFF[<span class="number">1</span>] = gsmg[RxdByte &gt;&gt; <span class="number">4</span>];   <span class="comment">//高四位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//缓冲区中索引位置的数据送到数码管端口</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">5</span>)                   <span class="comment">//索引递增循环，遍历整个缓冲区</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，完成数码管扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Smg_Scan();   <span class="comment">//数码管动态扫描刷新函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (RI)      <span class="comment">//接收到字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;    <span class="comment">//串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请</span></span><br><span class="line">        RxdByte = SBUF;     <span class="comment">//接收到的数据保存到接收字节变量中</span></span><br><span class="line">        SBUF = RxdByte;     <span class="comment">//接收到的数据又直接发回，叫作-&quot;echo&quot;，用以提示用户输入的信息是否已正确接收</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TI)      <span class="comment">//字节发送完毕，发送完成 TI 会自动置 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;    <span class="comment">//串行发送停止位的开始时，内部硬件会将TI置 1，要清除发送完成标志位，需要清0，取消此中断申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>问：用文本格式直接发送一个“12”，串口调试助手返回十六进制显示的是 31、32 两个数据，而数码管显示的是 32，为什么？</p>
</blockquote>
<p>对于 ASCII 码表来说，数字本身是字符而非数据，所以如果发送“12”的话，实际上是分别发送了“1”和“2”两个字符，单片机呢，先收到第一个字符“1”，在数码管上会显示出 31 这个对应数字，但是马上就又收到了“2”这个字符，数码管瞬间从 31 变成了 32， 而我们视觉上呢，是没有办法发现这种快速变化的，所以我们感觉数码管直接显示的是 32</p>
<blockquote>
<h4 id="接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上">接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义LED和数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF</span></span><br><span class="line">u8 T0RH = <span class="number">0</span>;    <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;    <span class="comment">//T0 重载值的低字节</span></span><br><span class="line">u8 RxdByte = <span class="number">0</span>; <span class="comment">//串口接收到的字节</span></span><br><span class="line">u8 flag = <span class="number">0</span>;    <span class="comment">//1s定时标志</span></span><br><span class="line">u8 dirflag = <span class="number">0</span>; <span class="comment">//流水灯流动方向标志位(0代表左移，1代表右移)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Fall</span><span class="params">(u8 dir)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//选择数码管</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Config_Time0(<span class="number">1</span>); <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    UART_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == dirflag) <span class="comment">//如果流动方向标志位为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == flag)  <span class="comment">//1s定时标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;    <span class="comment">//标志位清0</span></span><br><span class="line">                LED_Fall(<span class="number">0</span>); <span class="comment">//左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == dirflag) <span class="comment">//如果流动方向标志位为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == flag)       <span class="comment">//1s定时标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;         <span class="comment">//标志位清0</span></span><br><span class="line">                LED_Fall(<span class="number">1</span>);      <span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将接收字节在数码管上以十六进制形式显示出来</span></span><br><span class="line">        SMG_BUFF[<span class="number">0</span>] = gsmg[RxdByte &amp; <span class="number">0x0F</span>]; <span class="comment">//低四位</span></span><br><span class="line">        SMG_BUFF[<span class="number">1</span>] = gsmg[RxdByte &gt;&gt; <span class="number">4</span>];   <span class="comment">//高四位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//缓冲区中索引位置的数据送到数码管端口</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">6</span>)                   <span class="comment">//索引递增循环，遍历整个缓冲区</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制LED流水灯流动方向函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Fall</span><span class="params">(u8 dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x01</span>; <span class="comment">//LED状态</span></span><br><span class="line">        <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">        SMG_BUFF[<span class="number">6</span>] = ~Led_state; <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &lt;&lt;= <span class="number">1</span>;     <span class="comment">//左移一位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == Led_state)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x01</span>;  <span class="comment">//左移到最高位后重新设置为第一个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x80</span>; <span class="comment">//LED状态</span></span><br><span class="line">        <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">        SMG_BUFF[<span class="number">6</span>] = ~Led_state; <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &gt;&gt;= <span class="number">1</span>;     <span class="comment">//右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == Led_state)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x80</span>;  <span class="comment">//右移到最低位后重新设置为第八个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，完成数码管扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Smg_Scan();   <span class="comment">//数码管动态扫描刷新函数</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">1000</span>) <span class="comment">//1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (RI)      <span class="comment">//接收到字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;    <span class="comment">//串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请</span></span><br><span class="line">        RxdByte = SBUF;     <span class="comment">//接收到的数据保存到接收字节变量中</span></span><br><span class="line">        SBUF = RxdByte;     <span class="comment">//接收到的数据又直接发回，叫作-&quot;echo&quot;，用以提示用户输入的信息是否已正确接收</span></span><br><span class="line">        dirflag = !dirflag; <span class="comment">//每收到一个字节改变一次流水灯标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TI)      <span class="comment">//字节发送完毕，发送完成 TI 会自动置 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;    <span class="comment">//串行发送停止位的开始时，内部硬件会将TI置 1，要清除发送完成标志位，需要清0，取消此中断申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上，当接收到大写-“B”，蜂鸣器响-要用文本模式发送才有效">接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上，当接收到大写 “B”，蜂鸣器响(要用文本模式发送才有效)</h4>
</blockquote>
<p>这个程序就是在上面代码的基础上加，先定义一个flagBuzz控制蜂鸣器状态的(0表示关)，在串口中断那里，当接收到数据为&quot; B &quot;时，flagBuzz置1，在定时器0那一直扫描，当flagBuzz == 1 时，蜂鸣器取反（响），当flagBuzz == 0 时，蜂鸣器不响</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义LED和数码管端口</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line">sbit BUZZ  = P1 ^ <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">10</span>] = &#123;<span class="number">0xc0</span>, <span class="number">0xf9</span>, <span class="number">0xa4</span>, <span class="number">0xb0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xf8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>&#125;; <span class="comment">//数码管1-9</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">7</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管缓存区，初值0xFF</span></span><br><span class="line">u8 T0RH = <span class="number">0</span>;    <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;    <span class="comment">//T0 重载值的低字节</span></span><br><span class="line">u8 RxdByte = <span class="number">0</span>; <span class="comment">//串口接收到的字节</span></span><br><span class="line">u8 flag = <span class="number">0</span>;    <span class="comment">//1s定时标志</span></span><br><span class="line">u8 dirflag = <span class="number">0</span>; <span class="comment">//流水灯流动方向标志位(0代表左移，1代表右移)</span></span><br><span class="line">u8 flagBuzz = <span class="number">0</span>;<span class="comment">//蜂鸣器控制标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Fall</span><span class="params">(u8 dir)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;  <span class="comment">//选择数码管</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Config_Time0(<span class="number">1</span>); <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    UART_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == dirflag) <span class="comment">//如果流动方向标志位为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == flag)  <span class="comment">//1s定时标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;    <span class="comment">//标志位清0</span></span><br><span class="line">                LED_Fall(<span class="number">0</span>); <span class="comment">//左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == dirflag) <span class="comment">//如果流动方向标志位为1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == flag)       <span class="comment">//1s定时标志</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;         <span class="comment">//标志位清0</span></span><br><span class="line">                LED_Fall(<span class="number">1</span>);      <span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将接收字节在数码管上以十六进制形式显示出来</span></span><br><span class="line">        SMG_BUFF[<span class="number">0</span>] = gsmg[RxdByte &amp; <span class="number">0x0F</span>]; <span class="comment">//低四位</span></span><br><span class="line">        SMG_BUFF[<span class="number">1</span>] = gsmg[RxdByte &gt;&gt; <span class="number">4</span>];   <span class="comment">//高四位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Config_Time0</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//缓冲区中索引位置的数据送到数码管端口</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">6</span>)                   <span class="comment">//索引递增循环，遍历整个缓冲区</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制LED流水灯流动方向函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Fall</span><span class="params">(u8 dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x01</span>; <span class="comment">//LED状态</span></span><br><span class="line">        <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">        SMG_BUFF[<span class="number">6</span>] = ~Led_state; <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &lt;&lt;= <span class="number">1</span>;     <span class="comment">//左移一位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == Led_state)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x01</span>;  <span class="comment">//左移到最高位后重新设置为第一个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 Led_state = <span class="number">0x80</span>; <span class="comment">//LED状态</span></span><br><span class="line">        <span class="comment">//注意这里要把LED的状态变量赋给Led_Buff[6],因为数码管和LED共用端口，所以这里不能直接赋给P0</span></span><br><span class="line">        SMG_BUFF[<span class="number">6</span>] = ~Led_state; <span class="comment">//取反赋给数组里的第七个元素(也就是使能LEDS6，才可以点亮LED)</span></span><br><span class="line">        Led_state &gt;&gt;= <span class="number">1</span>;     <span class="comment">//右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == Led_state)</span><br><span class="line">        &#123;</span><br><span class="line">            Led_state = <span class="number">0x80</span>;  <span class="comment">//右移到最低位后重新设置为第八个LED灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，完成数码管扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 count = <span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Smg_Scan();   <span class="comment">//数码管动态扫描刷新函数</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">1000</span>) <span class="comment">//1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == flagBuzz) <span class="comment">//如果蜂鸣器控制标志为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        BUZZ = ~BUZZ;   <span class="comment">//蜂鸣器响</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        BUZZ = <span class="number">1</span>;       <span class="comment">//蜂鸣器关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (RI)      <span class="comment">//接收到字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;    <span class="comment">//串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请</span></span><br><span class="line">        RxdByte = SBUF;     <span class="comment">//接收到的数据保存到接收字节变量中</span></span><br><span class="line">        SBUF = RxdByte;     <span class="comment">//接收到的数据又直接发回，叫作-&quot;echo&quot;，用以提示用户输入的信息是否已正确接收</span></span><br><span class="line">        dirflag = !dirflag; <span class="comment">//每收到一个字节改变一次流水灯标志位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;B&#x27;</span> == RxdByte) <span class="comment">//如果接收到大写字母B蜂鸣器控制标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            flagBuzz = <span class="number">1</span>;    <span class="comment">//蜂鸣器控制标志置1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flagBuzz = <span class="number">0</span>;    <span class="comment">//否则蜂鸣器控制标志置0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TI)      <span class="comment">//字节发送完毕，发送完成 TI 会自动置 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;    <span class="comment">//串行发送停止位的开始时，内部硬件会将TI置 1，要清除发送完成标志位，需要清0，取消此中断申请</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="接收上位机下发的命令，根据命令值分别把不同数组的数据回发给上位机">接收上位机下发的命令，根据命令值分别把不同数组的数据回发给上位机</h4>
</blockquote>
<p>程序用到了指针的自增运算，也就是+1 运算，还有sizeof()</p>
<p>这个程序还应用到一个小技巧，前边讲了<code>串口发送中断标志位 TI 是硬件置位，软件清零</code>的。如果我们想一次发送多个数据的时候，就需要把第一个字节写入 SBUF，然后再等待发送中断，在后续中断中再发送剩余的数据，这样我们的数据发送过程就被拆分到了两个地方——主循环内和中断服务函数内，无疑就使得程序结构变得零散了。所以我们可以改成在启动发送的时候，不是向 SBUF 中写入第一个待发的字节，而是直接让 <code>TI = 1</code>，这时候会<code>马上进入串口中断</code>，因为中断标志位置 1 了，但是串口线上并没有发送任何数据，于是，所有的数据发送都可以在中断中进行，而不用再分为两部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"></span><br><span class="line">bit cmdArrived = <span class="number">0</span>; <span class="comment">//命令到达标志，即接收到上位机下发的命令</span></span><br><span class="line"></span><br><span class="line">u8 cmdIndex = <span class="number">0</span>; <span class="comment">//命令索引，即与上位机约定好的数组编号</span></span><br><span class="line">u8 cntTxd = <span class="number">0</span>;   <span class="comment">//串口发送计数器</span></span><br><span class="line">u8 *ptrTxd;      <span class="comment">//串口发送指针</span></span><br><span class="line"></span><br><span class="line">u8 array1[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">u8 array2[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">u8 array3[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">u8 array4[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    UART_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cmdArrived)</span><br><span class="line">        &#123;</span><br><span class="line">            cmdArrived = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(cmdIndex)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ptrTxd = array1;           <span class="comment">//数组 1 的首地址赋值给发送指针</span></span><br><span class="line">                cntTxd = <span class="keyword">sizeof</span>(array1);   <span class="comment">//数组 1 的长度赋值给发送计数器</span></span><br><span class="line">                TI = <span class="number">1</span>;                    <span class="comment">//手动方式启动发送中断，处理数据发送</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                ptrTxd = array2;</span><br><span class="line">                cntTxd = <span class="keyword">sizeof</span>(array2);</span><br><span class="line">                TI = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                ptrTxd = array3;</span><br><span class="line">                cntTxd = <span class="keyword">sizeof</span>(array3);</span><br><span class="line">                TI = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                ptrTxd = array4;</span><br><span class="line">                cntTxd = <span class="keyword">sizeof</span>(array4);</span><br><span class="line">                TI = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UART 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (RI)      <span class="comment">//接收到字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>;    <span class="comment">//串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请</span></span><br><span class="line">        cmdIndex = SBUF; <span class="comment">//接收到的数据保存到命令索引中</span></span><br><span class="line">        cmdArrived = <span class="number">1</span>;  <span class="comment">//设置命令到达标志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TI)      <span class="comment">//字节发送完毕，发送完成 TI 会自动置 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;    <span class="comment">//串行发送停止位的开始时，内部硬件会将TI置 1，要清除发送完成标志位，需要清0，取消此中断申请</span></span><br><span class="line">        <span class="keyword">if</span> (cntTxd &gt; <span class="number">0</span>) <span class="comment">//有待发送数据时，继续发送后续字节</span></span><br><span class="line">        &#123;</span><br><span class="line">            SBUF = *ptrTxd; <span class="comment">//发出指针指向的数据</span></span><br><span class="line">            cntTxd--;       <span class="comment">//发送计数器递减</span></span><br><span class="line">            ptrTxd++;       <span class="comment">//发送指针递增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1602液晶">1602液晶</h2>
<p>数据手册重要内容</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221014225318.jpg" style="zoom:80%;" />
<p>1602 液晶可以<code>显示 2 行</code>，每行 <code>16 个 字符</code>，这个 <code>2mA</code> 仅仅是指液晶，而它的黄绿背光都是用 LED 做的，所以功耗 不会太小的， <code>一二十毫安</code> 还是有的</p>
<h3 id="1602-液晶引脚功能">1602 液晶引脚功能</h3>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">引脚说明</th>
<th style="text-align:center">编号</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">引脚说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">VSS</td>
<td style="text-align:center">电源地</td>
<td style="text-align:center">9</td>
<td style="text-align:center">D2</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">VDD</td>
<td style="text-align:center">电源正极</td>
<td style="text-align:center">10</td>
<td style="text-align:center">D3</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">VL</td>
<td style="text-align:center">液晶显示偏压信号</td>
<td style="text-align:center">11</td>
<td style="text-align:center">D4</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">RS</td>
<td style="text-align:center">数据/命令选择端(H/L)</td>
<td style="text-align:center">12</td>
<td style="text-align:center">D5</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">R/W</td>
<td style="text-align:center">读/写选择端(H/L)</td>
<td style="text-align:center">13</td>
<td style="text-align:center">D6</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">E</td>
<td style="text-align:center">使能信号</td>
<td style="text-align:center">14</td>
<td style="text-align:center">D7</td>
<td style="text-align:center">Data I/O</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">D0</td>
<td style="text-align:center">Data I/O</td>
<td style="text-align:center">15</td>
<td style="text-align:center">BLA</td>
<td style="text-align:center">背光源正极</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">D1</td>
<td style="text-align:center">Data I/O</td>
<td style="text-align:center">16</td>
<td style="text-align:center">BLK</td>
<td style="text-align:center">背光源负极</td>
</tr>
</tbody>
</table>
<p>● 液晶的电源 1 脚 2 脚以及背光电源 15 脚 16 脚，正常接即可<br>
● <code>3 脚</code>叫做<code>液晶显示偏压信号</code>，调整显示的黑点和不显示的之间的对比度，调好就清晰多了<br>
● <code>4 脚</code>是<code>数据命令选择端</code> (这个引脚接到了 ADDR0 上，通过跳线帽和 P1.0 连接)；<code>高电平是数据，低电平是命令</code><br>
● <code>5 脚</code>是<code>读写选择端</code>  (这个引脚接到了 ADDR1 上，通过跳线帽和 P1.1 连接)；<code>高电平是读，低电平是写</code><br>
● <code>6 脚</code>是<code>使能信号</code> (很重要！)，液晶的读写命令和数据，都要靠它才能正常读写，这个引脚通过跳线帽接到了 <code>ENLCD</code> 上 (P1.5管脚)<br>
● <code>7 到 14 引脚</code>就是 8 个<code>数据引脚</code>了，通过这 8 个引脚<code>读写数据和命令</code> (接到了P0口)</p>
<h3 id="1602原理图">1602原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221014230736.jpg" style="zoom:80%;" />
<h3 id="1602-液晶的读写时序">1602 液晶的读写时序</h3>
<blockquote>
<p><strong>1602 内部 RAM 结构图</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20115926.webp" style="zoom: 33%;" />
<p>第一行的地址是 <code>0x00H 到 0x27</code>，第二行的地址从 <code>0x40 到 0x67</code>，其中第一行 <code>0x00 到 0x0F</code> 是与液晶上第一行 16 个字符<code>显示位置</code>相对应的，第二行 <code>0x40 到 0x4F</code> 是与第二行 16 个字符<code>显示位置</code>相对应的。而每行都多出来一部分，是为了显示移动字幕设置的</p>
<blockquote>
<p><strong>1602 液晶状态字</strong></p>
</blockquote>
<p>液晶有一个状态字字节，通过读取这个状态字的内容，可以知道 1602 液晶的一些内部情况</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20120311.webp" style="zoom: 33%;" />
<p>这个状态字节有 <code>8 个位</code>，<code>最高位</code>表示了当前液晶是不是<code>忙</code>，如果这个位是 <code>1 表示液 晶正“忙”</code>，<code>禁止读写数据或者命令</code>，如果是 <code>0</code>，则<code>可以进行读写</code>。而<code>低 7 位</code>就表示了<code>当前数据地址指针的位置</code></p>
<p>1602 的<code>基本操作时序</code>，一共有 4 个(单片机读外部状态前，必须先保证自己是<code>高电平</code>)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20123121.webp" style="zoom: 40%;" />
<p>首先把用到的总线接口做一个统一声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0 	  <span class="comment">//根据原理图可以知道P0组是控制上面8个状态字</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>; 	<span class="comment">//数据选择端</span></span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>; 	<span class="comment">//读写选择端</span></span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;    <span class="comment">//使能信号</span></span><br></pre></td></tr></table></figure>
<ol>
<li>读状态：<code>RS = L，R/W = H，E = H</code></li>
</ol>
<p>因为P0口总线也是流水灯数码管等等共用的，读取后如果一直是高电平会影响其他外设，所以通常要把这个引脚拉低来释放总线，这里用了一个 do…while 循环语句来实现(判断while是否为1，为1则执行上面的语句，不为1则退出循环)</p>
<p>通过判断 sta <code>最高位</code>的值来了解当前液晶是否处于<code>忙</code>状态，也可以得知当前数据的指针位置，如果当前读到的状态是<code>不忙</code>，那么程序可以进行<code>读写操作</code>，如果当前状态是<code>忙</code>，那么还得继续<code>等待重新判断液晶的状态</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LCD1602_DB = <span class="number">0xFF</span>;    </span><br><span class="line">LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">LCD1602_RW = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;	  <span class="comment">//使能</span></span><br><span class="line">    sta = LCD1602_DB; <span class="comment">//读取状态字</span></span><br><span class="line">    LCD1602_E = <span class="number">0</span>;    <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">&#125;<span class="keyword">while</span> (sta &amp; <span class="number">0x80</span>);  <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止 </span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>读数据：<code>RS = H，R/W = H，E = H</code> (不常用)</p>
</li>
<li>
<p>写指令：<code>RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</code></p>
</li>
</ol>
<p>这个指令一共有 4 条语句，其中前三条语句顺序无所谓，但是 E = 高脉冲这一句很关键。<code>E = 高脉冲</code>，意思就是：<code>E 使能引脚先从低拉高，再从高拉低，形成一个高脉冲</code></p>
<ol start="4">
<li>写数据：<code>RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</code></li>
</ol>
<p>写数据和写指令是类似的，就是把 RS 改成 H，把总线改成数据即可</p>
<p>注：这里用的1602液晶所使用的接口时序是摩托罗拉公司所创立的 <code>6800时序</code> ，还有另外一种时序是 Intel 公司的 <code>8080时序</code>，也有部分液晶模块采用，只是相对来说比较少见</p>
<p>1602 液晶的使能引脚 E， 高电平的时候是 <code>有效</code>，低电平的时候是 <code>无效</code>，前面也提到了高电平时会影响 P0 口，因此正常情况下，如果我们没有使用液晶的话，那么程序开始写一句 <code>LCD1602_E=0</code>，就可以避免1602 干扰到其它外设。之前的程序没有加这句，是因为板子在这个引脚上加了一个 <code>15K 的下拉电阻</code>，这个下拉电阻就可以保证这个引脚上电后默认是 <code>低电平</code>(但是在实际开发过程中，就不必要这样了。如果这是个实际产品，能用软件去处理的，我们就不会用硬件去实现)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015001628.jpg" style="zoom: 80%;" />
<h3 id="1602-液晶的指令">1602 液晶的指令</h3>
<ol>
<li>显示模式设置</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20123453.webp" style="zoom:50%;" />
<p>写指令 <code>0x38</code>，<code>设置 16x2 显示，5x7 点阵，8 位数据接口</code>。这条指令对这个1602液晶来说是固定的，必须写 <code>0x38</code>(仔细看会发现我们的液晶实际上内部点阵是 5x8 的)</p>
<ol start="2">
<li>显示开/关以及光标设置指令</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20123911.webp" style="zoom:50%;" />
<p>这里有 2 条指令，第一条指令，一个字节中 8 位，其中高 5 位是固定的 <code>0b00001</code>，低 3位分别用 <code>DCB 从高到低表示</code>， <code>D=1</code> 表示开显示， <code>D=0</code> 表示关显示； <code>C=1</code> 表示显示光标， <code>C=0</code> 表示不显示光标； <code>B=1</code> 表示光标闪烁， <code>B=0 </code>表示光标不闪烁；第二条指令，高 6 位是固定的 <code>0b000001</code>，低 2 位分别用 <code>NS 从高到低表示</code>，其中 <code>N=1 </code>表示读或者写一个字符后，指针自动加 1，光标自动加 1， <code>N=0 </code>表示读或者写一个字符 后指针自动减 1，光标自动减 1； <code>S=1</code> 表示写一个字符后，整屏显示左移(N=1)或右移(N=0)，以达到光标不移动而屏幕移动的效果，而 <code>S=0</code> 表示写一 个字符后，整屏显示不移动</p>
<p><strong>数据控制</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231005154424.webp" style="zoom:50%;" />
<ol start="3">
<li>清屏指令</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-05%20124312.webp" style="zoom:50%;" />
<p>写入 <code>0x01</code> 表示<code>显示清屏</code>，其中包含了数据指针清零，所有的显示清零。写入<code> 0x02</code> 则仅仅是<code>数据指针清零，显示不清零</code></p>
<ol start="4">
<li>RAM 地址设置指令</li>
</ol>
<p>该指令码的 <code>最高位为 1</code>， <code>低 7 位为 RAM 的地址</code>，RAM 地址与液晶上字符的关系如上映射图所示。通常，<code>我们在读写数据之前都要先设置好地址，然后再进行数据的读写操作</code></p>
<h3 id="通信时序解析">通信时序解析</h3>
<p>所谓“时序”从字面意义上来理解，一是 <code>时间问题</code>，二是 <code>顺序问题</code></p>
<blockquote>
<p><strong>读操作时序</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015144108.jpg" style="zoom:60%;" />
<p>RS 引脚和 R/W 引脚，这两个引脚<code>先进行变化</code>，因为是<code>读操作</code>，所以 <code>R/W</code> 引脚首先要置为<code>高电平</code>，而不管它原来是什么。(读指令还是读数据，都是读操作，而且都有可能，所以 RS 引脚既有可能是置为高电平，也有可能是置为低电平)，而 RS 和 R/W 变化了经过 <code>Tsp1 </code>这么长时间后，<code>使能引脚 E</code> 才能从<code>低电平到高电平</code>发生变化，经过了 <code>tD</code> 这么长时间后，LCD1602 输出 <code>DB</code> 的数据就是<code>有效数据</code>了(就可以来读取 DB 的数据了)，读完了之后，我们要先把使能 E 拉低，经过一段时间后 RS、R/W 和 DB 才可以变化继续为下一次读写做准备了</p>
<blockquote>
<p><strong>写操作时序</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015153636.jpg" style="zoom:60%;" />
<p>写操作时序和读操作时序的差别，就是<code>写操作时序</code>中，<code>DB 的改变是由单片机</code>来完成的，因此要<code>放到使能引脚 E 的变化之前</code>进行操作</p>
<ol>
<li>注意时间轴，如果没有标明(其实大部分也都是不标明的)，那么从左往右的方向为时间正向轴，即时间在增长</li>
<li>上图框出并注明了看懂此图的一些常识：</li>
</ol>
<p>(1) 时序图最左边一般是某一根引脚的标识，<code>表示此行图线体现该引脚的变化，上图分别标明了RS、R/W、E、DB0~DB7四类引脚的时序变化</code></p>
<p>(2) 有<code>线交叉状</code>的部分，表示<code>电平在变化</code>，如上所标注</p>
<p>(3) <code>两条平行线分别对应高低电平</code>，也正好吻合(2)中电平变化的说法</p>
<p>(4) 上图中，<code>密封的菱形部分</code>，注意要密封，表示<code>数据有效</code>，Valid Data这个词也显示了这点</p>
<ol start="3">
<li>
<p>需要十分注意的是，时序图里各个引脚的电平变化，基于的时间轴是一致的。一定要严格按照时间轴的增长方向来精确地观察时序图。要让器件严格的遵守时序图的变化。在类似于18B20这样的单总线器件对此要求尤为严格</p>
</li>
<li>
<p>以上几点，并不是LCD1602的时序图所特有的，绝大部分的时序图都遵循着这样的一般规则，所以要慢慢的习惯于这样的规则</p>
</li>
</ol>
<blockquote>
<p><strong>时序图时间标签</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015144127.jpg" style="zoom:60%;" />
<p><strong>tC</strong>：指的是<code>使能引脚 E 从本次上升沿到下次上升沿的最短时间是 400ns</code></p>
<p><strong>tPW</strong>：指的是<code>使能引脚 E 高电平的持续时间最短是 150ns</code></p>
<p><strong>tR tF</strong>：指的是<code>使能引脚 E 的上升沿时间和下降沿时间，不能超过 25ns</code></p>
<p><strong>tSP1</strong>：指的是 <code>RS 和 R/W 引脚使能后至少保持 30ns，使能引脚 E 才可以变成高电平</code></p>
<p><strong>tHD1</strong>：指的是<code>使能引脚 E 变成低电平后，至少保持 10ns 之后，RS 和 R/W 才能进行变化</code></p>
<p><strong>tD</strong>：指的是<code>使能引脚 E 变成高电平后，最多 100ns 后，1602 就把数据送出来</code>了</p>
<p><strong>tHD2</strong>：指的是<code>读操作</code>过程中，<code>使能引脚 E 变成低电平后，至少保持 20ns，DB 数据总线才可以进行变化</code></p>
<p><strong>tSP2</strong>：指的是 <code>DB 数据总线准备好后，至少保持 40ns，使能引脚 E 才可以从低到高进行使能变化</code></p>
<p><strong>tHD2</strong>：指的是<code>写操作</code>过程中，<code>要引脚 E 变成低电平后，至少保持 10ns，DB 数据总线才可以变化</code></p>
<p>要懂得估计主控芯片的指令时间，可以在官方数据手册上查到MCU的一些级别参数。比如我们现在用STC51做为主控芯片，外部11.0592MHz晶振，指令周期就是一个时钟周期为(1/11.0592MHz)s，所以至少确定了它执行一条指令的时间是us级别的。我们看到，以上给的时间参数全部是ns级别的，所以即便我们在程序里不加延时程序，也应该可以很好的配合LCD1602的时序要求了</p>
<h3 id="程序-7">程序</h3>
<blockquote>
<h4 id="在LCD1602上显示字符串">在LCD1602上显示字符串</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line"></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd1602_Init();                   <span class="comment">//LCD初始化</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">5</span>, <span class="number">0</span>, <span class="string">&quot;Hello&quot;</span>);       <span class="comment">//在液晶上显示字符串</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;You are the best&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);     <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)            <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)  <span class="comment">//连续写入字符串数据，直到检测到结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="左移字符串">左移字符串</h4>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line"></span><br><span class="line">sbit LCD1602_RS = P1 ^ <span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1 ^ <span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1 ^ <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">bit flag = <span class="number">0</span>; <span class="comment">//500ms 定时标志</span></span><br><span class="line">u8 T0RH = <span class="number">0</span>;  <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>;  <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//待显示的第一行字符串</span></span><br><span class="line">u8 code str1[] = <span class="string">&quot;Come on!&quot;</span>;</span><br><span class="line"><span class="comment">//待显示的第二行字符串，需保持与第一行字符串等长，较短的行可用空格补齐</span></span><br><span class="line">u8 code str2[] = <span class="string">&quot;Amazing!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 index = <span class="number">0</span>;  <span class="comment">//移动索引</span></span><br><span class="line">    u8 pdata bufMove1[<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) + <span class="number">16</span>]; <span class="comment">//移动显示缓冲区 1(液晶一共16个字节，在移动字符串前后各加上16个空格)</span></span><br><span class="line">    u8 pdata bufMove2[<span class="number">16</span> + <span class="keyword">sizeof</span>(str2) + <span class="number">16</span>]; <span class="comment">//移动显示缓冲区 2</span></span><br><span class="line"></span><br><span class="line">    Time0_Init(<span class="number">10</span>); <span class="comment">//配置 T0 定时 10ms</span></span><br><span class="line">    Lcd1602_Init(); <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓冲区开头一段填充为空格</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bufMove1[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        bufMove2[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//待显示字符串拷贝到缓冲区中间位置</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(str1) - <span class="number">1</span>); i++) <span class="comment">//i = 字符串长度，因为i从0算起，所以要 -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        bufMove1[<span class="number">16</span> + i] = str1[i];</span><br><span class="line">        bufMove2[<span class="number">16</span> + i] = str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲区结尾一段也填充为空格 (i初值为前面的16个空格加上字符串的长度，i要小于一整个缓冲区的长度 )</span></span><br><span class="line">    <span class="keyword">for</span>(i = (<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>); i &lt; <span class="keyword">sizeof</span>(bufMove1); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bufMove1[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        bufMove2[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)  <span class="comment">//每 500ms 移动一次屏幕</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从缓冲区抽出需显示的一段字符显示到液晶上</span></span><br><span class="line">            Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, bufMove1 + index, <span class="number">16</span>);</span><br><span class="line">            Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, bufMove2 + index, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">//移动索引递增，实现左移</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= (<span class="number">16</span> + <span class="keyword">sizeof</span>(str1) - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//起始位置达到字符串尾部后即返回从头开始</span></span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针，len-需显示的字符长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(len--)         <span class="comment">//连续写入 len 个字符数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，定时 500ms */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 count = <span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH; <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="计算器实例">计算器实例</h4>
</blockquote>
<p>计算器不考虑连加，连减等连续计算，不考虑小数情况。加减乘除分别用上下左右来替代，回车表示等于，ESC 表示归 0</p>
<p>main.c 文件实现所有应用层的操作函数，即计算器功能所需要信息显示、按键动作响应等，另外还包括主循环和定时中断的调度</p>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//矩阵按键编号到标准键盘键码的映射表</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x26</span> &#125;, <span class="comment">//数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123; <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="number">0x25</span> &#125;, <span class="comment">//数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123; <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="number">0x28</span> &#125;, <span class="comment">//数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123; <span class="string">&#x27;0&#x27;</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span> &#125; <span class="comment">//数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 pdata Key_State[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//按键当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环扫描 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i][j] != Key_State[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)  <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]); <span class="comment">//调用按键动作函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = Key_State[i][j]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++; <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span> (KeyOut &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	KeyOut = KeyOut &amp; 0x03; //索引值加到 4 即归零</span></span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针，len-需显示的字符长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 区域清除，清除从(x,y)坐标起始的 len 个字符位 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_AreaClear</span><span class="params">(u8 x, u8 y, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(len--)         <span class="comment">//连续写入空格</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整屏清除 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_FullClear</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_AreaClear</span><span class="params">(u8 x, u8 y, u8 len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_FullClear</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 step = <span class="number">0</span>;  <span class="comment">//操作步骤</span></span><br><span class="line">u8 oprt = <span class="number">0</span>;  <span class="comment">//运算类型</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> num1 = <span class="number">0</span>;   <span class="comment">//操作数 1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> num2 = <span class="number">0</span>;   <span class="comment">//操作数 2</span></span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> result = <span class="number">0</span>; <span class="comment">//运算结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Init(<span class="number">1</span>);           <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    Lcd1602_Init();          <span class="comment">//初始化液晶</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>); <span class="comment">//初始显示一个数字 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver(); <span class="comment">//调用按键驱动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 长整型数转换为字符串，str-字符串指针，dat-待转换数，返回值-字符串长度 */</span></span><br><span class="line">u8 <span class="title function_">LongToString</span><span class="params">(u8 *str, <span class="type">signed</span> <span class="type">long</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    u8 len = <span class="number">0</span>;</span><br><span class="line">    u8 buf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span>(dat &lt; <span class="number">0</span>)   <span class="comment">//如果为负数，首先取绝对值，并在指针上添加负号</span></span><br><span class="line">    &#123;</span><br><span class="line">        dat = -dat;</span><br><span class="line">        *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>            <span class="comment">//先转换为低位在前的十进制数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf[i++] = dat % <span class="number">10</span>;</span><br><span class="line">        dat /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(dat &gt; <span class="number">0</span>);</span><br><span class="line">    len += i;       <span class="comment">//i 最后的值就是有效字符的个数</span></span><br><span class="line">    <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>)  <span class="comment">//将数组值转换为 ASCII 码反向拷贝到接收指针上</span></span><br><span class="line">    &#123;</span><br><span class="line">        *str++ = buf[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//添加字符串结束符</span></span><br><span class="line">    <span class="keyword">return</span> len;  <span class="comment">//返回字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示运算符，显示位置 y，运算符类型 type */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShowOprt</span><span class="params">(u8 y, u8 type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, y, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//0 代表+</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, y, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//1 代表-</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, y, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//2 代表*</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, y, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//3 代表/</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算器复位，清零变量值，清除屏幕显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    num1 = <span class="number">0</span>;</span><br><span class="line">    num2 = <span class="number">0</span>;</span><br><span class="line">    step = <span class="number">0</span>;</span><br><span class="line">    Lcd_FullClear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数字键动作函数，n-按键输入的数值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NumKey_Action</span><span class="params">(u8 num)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 len = <span class="number">0</span>;</span><br><span class="line">    u8 str[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span>(step &gt; <span class="number">1</span>) <span class="comment">//如计算已完成，则重新开始新的计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        Reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == step) <span class="comment">//输入第一操作数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1 = num1 * <span class="number">10</span> + num;        <span class="comment">//输入数值累加到原操作数上</span></span><br><span class="line">        len = LongToString(str, num1); <span class="comment">//新数值转换为字符串</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str); <span class="comment">//显示到液晶第二行上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//输入第二操作数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num2 = num2 * <span class="number">10</span> + num;        <span class="comment">//输入数值累加到原操作数上</span></span><br><span class="line">        len = LongToString(str, num2); <span class="comment">//新数值转换为字符串</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str); <span class="comment">//显示到液晶第二行上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运算符按键动作函数，运算符类型 type */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Oprt_KeyAction</span><span class="params">(u8 type)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 len = <span class="number">0</span>;</span><br><span class="line">    u8 str[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == step) <span class="comment">//第二操作数尚未输入时响应，即不支持连续操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = LongToString(str, num1); <span class="comment">//第一操作数转换为字符串</span></span><br><span class="line">        Lcd_AreaClear(<span class="number">0</span>, <span class="number">0</span>, <span class="number">16</span> - len); <span class="comment">//清除第一行左边的字符位</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">16</span> - len, <span class="number">0</span>, str); <span class="comment">//字符串靠右显示在第一行</span></span><br><span class="line">        ShowOprt(<span class="number">1</span>, type);             <span class="comment">//在第二行显示操作符</span></span><br><span class="line">        Lcd_AreaClear(<span class="number">1</span>, <span class="number">1</span>, <span class="number">14</span>);       <span class="comment">//清除第二行中间的字符位</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);       <span class="comment">//在第二行最右端显示 0</span></span><br><span class="line">        oprt = type;                   <span class="comment">//记录操作类型</span></span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算结果函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetResult</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 len = <span class="number">0</span>;</span><br><span class="line">    u8 str[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == step)  <span class="comment">//第二操作数已输入时才执行计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span>(oprt) <span class="comment">//根据运算符类型计算结果，未考虑溢出问题</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            result = num1 + num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            result = num1 - num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            result = num1 * num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            result = num1 / num2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = LongToString(str, num2);   <span class="comment">//原第二操作数和运算符显示到第一行</span></span><br><span class="line">        ShowOprt(<span class="number">0</span>, oprt);</span><br><span class="line">        Lcd_AreaClear(<span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span> - <span class="number">1</span> - len);</span><br><span class="line">        Lcd_ShowStr(<span class="number">16</span> - len, <span class="number">0</span>, str);</span><br><span class="line">        len = LongToString(str, result); <span class="comment">//计算结果和等号显示在第二行</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">        Lcd_AreaClear(<span class="number">1</span>, <span class="number">1</span>, <span class="number">16</span> - <span class="number">1</span> - len);</span><br><span class="line">        Lcd_ShowStr(<span class="number">16</span> - len, <span class="number">1</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>  <span class="comment">//按键动作函数，根据键码执行相应动作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((keycode &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (keycode &lt;= <span class="string">&#x27;9&#x27;</span>)) <span class="comment">//输入字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumKey_Action(keycode - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x26</span> == keycode)  <span class="comment">//向上键，+</span></span><br><span class="line">    &#123;</span><br><span class="line">        Oprt_KeyAction(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x28</span> == keycode)  <span class="comment">//向下键，-</span></span><br><span class="line">    &#123;</span><br><span class="line">        Oprt_KeyAction(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x25</span> == keycode)  <span class="comment">//向左键，*</span></span><br><span class="line">    &#123;</span><br><span class="line">        Oprt_KeyAction(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x27</span> == keycode)  <span class="comment">//向右键，÷</span></span><br><span class="line">    &#123;</span><br><span class="line">        Oprt_KeyAction(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x0D</span> == keycode)  <span class="comment">//回车键，计算结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0x1B</span> == keycode)  <span class="comment">//Esc 键，清除</span></span><br><span class="line">    &#123;</span><br><span class="line">        Reset();</span><br><span class="line">        Lcd_ShowStr(<span class="number">15</span>, <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行按键扫描 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH; <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Key_Scan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="串口控制蜂鸣器与LCD1602液晶">串口控制蜂鸣器与LCD1602液晶</h4>
</blockquote>
<p>通过电脑串口调试助手下发三个不同的命令，第一条指令： <code>buzz on 可以让蜂鸣器响</code>；第二条指令：<code>buzz off 可以让蜂鸣器不响</code>；第三条指令：showstr ， 这个命令空格后边，可以添加任何字符串，让<code>后边的字符串在 1602 液晶上显示</code>出来，同时不管发送什么命令，单片机收到后把命令原封不动的再通过串口发送给电脑</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 区域清除，清除从(x,y)坐标起始的 len 个字符位 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_AreaClear</span><span class="params">(u8 x, u8 y, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(len--)         <span class="comment">//连续写入空格</span></span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_AreaClear</span><span class="params">(u8 x, u8 y, u8 len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>UART.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">bit flagFrame = <span class="number">0</span>;   <span class="comment">//帧接收完成标志，即接收到一帧新数据</span></span><br><span class="line">bit flagTxd = <span class="number">0</span>;     <span class="comment">//单字节发送完成标志，用来替代 TXD 中断标志位</span></span><br><span class="line">u8 cntRxd = <span class="number">0</span>;       <span class="comment">//接收字节计数器</span></span><br><span class="line">u8 pdata bufRxd[<span class="number">64</span>]; <span class="comment">//接收字节缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UAER_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据写入，即串口发送函数，buf-待发送数据的指针，len-指定的发送长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Write</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len--)  <span class="comment">//循环发送所有字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        flagTxd = <span class="number">0</span>;      <span class="comment">//清零发送标志</span></span><br><span class="line">        SBUF = *buf++;    <span class="comment">//发送一个字节数据</span></span><br><span class="line">        <span class="keyword">while</span>(!flagTxd);  <span class="comment">//等待该字节发送完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据读取函数，buf-接收指针，len-指定的读取长度，返回值-实际读到的长度 */</span></span><br><span class="line">u8 <span class="title function_">UartRead</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; cntRxd) <span class="comment">//指定读取长度大于实际接收到的数据长度时</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = cntRxd;  <span class="comment">//读取长度设置为实际接收到的数据长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">//拷贝接收到的数据到接收指针上</span></span><br><span class="line">    &#123;</span><br><span class="line">        *buf++ = bufRxd[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cntRxd = <span class="number">0</span>; <span class="comment">//接收计数器清零</span></span><br><span class="line">    <span class="keyword">return</span> len; <span class="comment">//返回实际读取长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口接收监控，由空闲时间判定帧结束，需在定时中断中调用，ms-定时间隔 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_RxMonitor</span><span class="params">(u8 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 cntbkp = <span class="number">0</span>;   <span class="comment">//前一次接收到数据的长度</span></span><br><span class="line">    <span class="type">static</span> u8 idletmr = <span class="number">0</span>;  <span class="comment">//空闲计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cntRxd &gt; <span class="number">0</span>)          <span class="comment">//接收计数器大于零时，监控总线空闲时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cntbkp != cntRxd)  <span class="comment">//接收计数器改变，即刚接收到数据时，清零空闲计时(与前一次接收到的数据长度不一样代表接收到数据)</span></span><br><span class="line">        &#123;</span><br><span class="line">            cntbkp = cntRxd;    <span class="comment">//把本次接收到数据赋给前一次接收到的数据</span></span><br><span class="line">            idletmr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                  <span class="comment">//接收计数器未改变，即总线空闲时，累积空闲时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idletmr &lt; <span class="number">30</span>)    <span class="comment">//空闲计时小于 30ms 时，持续累加</span></span><br><span class="line">            &#123;</span><br><span class="line">                idletmr += ms;</span><br><span class="line">                <span class="keyword">if</span>(idletmr &gt;= <span class="number">30</span>) <span class="comment">//空闲时间达到 30ms 时，即判定为一帧接收完毕</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flagFrame = <span class="number">1</span>;  <span class="comment">//设置帧接收完成标志</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cntbkp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口驱动函数，监测数据帧的接收，调度功能函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 len;</span><br><span class="line">    u8 pdata buf[<span class="number">40</span>]; <span class="comment">//数据缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(flagFrame)     <span class="comment">//有命令到达时，读取处理该命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        flagFrame = <span class="number">0</span>;</span><br><span class="line">        len = UartRead(buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//将接收到的命令读取到缓冲区中</span></span><br><span class="line">        Uart_Action(buf, len);           <span class="comment">//传递数据帧，调用动作执行函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(RI)    <span class="comment">//接收到新字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>; <span class="comment">//清零接收中断标志位</span></span><br><span class="line">        <span class="keyword">if</span>(cntRxd &lt; <span class="keyword">sizeof</span>(bufRxd)) <span class="comment">//接收缓冲区尚未用完时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//保存接收字节，并递增计数器</span></span><br><span class="line">            bufRxd[cntRxd++] = SBUF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(TI) <span class="comment">//字节发送完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;        <span class="comment">//清零发送中断标志位</span></span><br><span class="line">        flagTxd = <span class="number">1</span>;   <span class="comment">//设置字节发送完成标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UART.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UART_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UART_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UAER_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Write</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line">u8 <span class="title function_">UartRead</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_RxMonitor</span><span class="params">(u8 ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Action</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit BUZZ = P1 ^ <span class="number">6</span>; <span class="comment">//蜂鸣器控制引脚</span></span><br><span class="line">bit flagBuzzOn = <span class="number">0</span>; <span class="comment">//蜂鸣器启动标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Init(<span class="number">1</span>);           <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    UAER_Init(<span class="number">9600</span>);         <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    Lcd1602_Init();          <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Uart_Driver(); <span class="comment">//调用串口驱动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存比较函数，比较两个指针所指向的内存数据是否相同，ptr1-待比较指针 1，ptr2-待比较指针 2，</span></span><br><span class="line"><span class="comment">   len-待比较长度，返回值-两段内存数据完全相同时返回 1，不同返回 0 */</span></span><br><span class="line">bit <span class="title function_">Cmp_Memory</span><span class="params">(u8 *ptr1, u8 *ptr2, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*ptr1++ != *ptr2++) <span class="comment">//遇到不相等数据时即刻返回 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//比较完全部长度数据都相等则返回 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，根据接收到的命令帧执行响应的动作 buf-接收到的命令帧指针，len-命令帧长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Action</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 code cmd0[] = <span class="string">&quot;buzz on&quot;</span>;    <span class="comment">//开蜂鸣器命令</span></span><br><span class="line">    u8 code cmd1[] = <span class="string">&quot;buzz off&quot;</span>;   <span class="comment">//关蜂鸣器命令</span></span><br><span class="line">    u8 code cmd2[] = <span class="string">&quot;showstr &quot;</span>;   <span class="comment">//字符串显示命令</span></span><br><span class="line">    u8 code cmdLen[] = &#123;<span class="keyword">sizeof</span>(cmd0) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd1) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd2) - <span class="number">1</span>,&#125;; <span class="comment">//命令长度汇总表</span></span><br><span class="line">    u8 code *cmdPtr[] = &#123;&amp;cmd0[<span class="number">0</span>], &amp;cmd1[<span class="number">0</span>], &amp;cmd2[<span class="number">0</span>],&#125;;                  <span class="comment">//命令指针汇总表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmdLen); i++)  <span class="comment">//遍历命令列表，查找相同命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= cmdLen[i])               <span class="comment">//首先接收到的数据长度要不小于命令长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Cmp_Memory(buf, cmdPtr[i], cmdLen[i])) <span class="comment">//比较相同时退出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(i) <span class="comment">//循环退出时 i 的值即是当前命令的索引值</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        flagBuzzOn = <span class="number">1</span>; <span class="comment">//开启蜂鸣器</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        flagBuzzOn = <span class="number">0</span>; <span class="comment">//关闭蜂鸣器</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;           <span class="comment">//为接收到的字符串添加结束符</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, buf + cmdLen[<span class="number">2</span>]); <span class="comment">//显示命令后的字符串</span></span><br><span class="line">        i = len - cmdLen[<span class="number">2</span>];               <span class="comment">//计算有效字符个数</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">16</span>)  <span class="comment">//有效字符少于 16 时，清除液晶上的后续字符位</span></span><br><span class="line">        &#123;</span><br><span class="line">            Lcd_AreaClear(i, <span class="number">0</span>, <span class="number">16</span> - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">//未找到相符命令时，给上机发送“错误命令”的提示</span></span><br><span class="line">        Uart_Write(<span class="string">&quot;bad command.\r\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;bad command.\r\n&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\r&#x27;</span>; <span class="comment">//有效命令被执行后，在原命令帧之后添加</span></span><br><span class="line">    buf[len++] = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//回车换行符后返回给上位机，表示已执行</span></span><br><span class="line">    Uart_Write(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行串口接收监控和蜂鸣器驱动 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH; <span class="comment">//重新加载重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    <span class="keyword">if</span>(flagBuzzOn) <span class="comment">//执行蜂鸣器鸣叫或关闭</span></span><br><span class="line">    &#123;</span><br><span class="line">        BUZZ = ~BUZZ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        BUZZ = <span class="number">1</span>;</span><br><span class="line">    Uart_RxMonitor(<span class="number">1</span>); <span class="comment">//串口接收监控</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="I2C-总线与-EEPROM">I2C 总线与 EEPROM</h2>
<p><code>UART</code> 通信属于<code>异步通信</code>，多用于<code>板间通信</code>，比如单片机和电脑，这个设备和另外一个设备之间的通信，<code>I2C</code>属于<code>同步通信</code>，多用于<code>板内通信</code></p>
<h3 id="I2C-时序">I2C 时序</h3>
<p>I2C 总线是由时钟总线 <code>SCL</code> 和数据总线 <code>SDA</code> 两条线构成，连接到总线上的所有器件的 SCL 都连到一起，所有 SDA 都连到一起，I2C 总线是 <code>开漏引脚并联</code> 的结构，因此我们外部要添加上拉电阻， <code>所有接入的器件保持高电平，这条线才是高电平，而任何一个器件输出一个低电平，那这条线就会保持低电平，因此可以做到任何一个器件都可以拉低电平， 也就是任何一个器件都可以作为主机</code>；但绝大多数情况下我们都是用单片机来做主机， 而总线上挂的多个器件，每一个都像电话机一样有自己唯一的地址，在信息传输的过程中， 通过这唯一的地址就可以正常识别到属于自己的信息，在 KST-51 开发板上，就挂接了 2 个I2C 设备，一个是 <code>24C02</code>，一个是 <code>PCF8591</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20000542.webp" style="zoom:33%;" />
<h4 id="I2C-时序流程图">I2C 时序流程图</h4>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20001238.webp" style="zoom: 33%;" />
<p>I2C 分为<code>起始信号、数据传输部分、停止信号</code>。其中数据传输部分，可以一次通信过程传输很多个字节，字节数是不受限制的，而每个字节的数据最后也跟了一位，这一位叫做<code>应答位</code>，通常用 <code>ACK</code> 表示，有点类似于 UART 的停止位</p>
<blockquote>
<p><strong>I2C 通信流程解析</strong></p>
</blockquote>
<ol>
<li>数据有效性规定</li>
</ol>
<p>I2C 总线进行数据传送时，<code>时钟信号为高电平期间，数据线上的数据必须保持稳定</code>，只有在<code>时钟线(SCL)</code>上的<code>信号为低电平</code>期间，<code>数据线(SDA)</code>上的高电平或低电平状态才<code>允许变化</code>。每次数据传输都以<code>字节</code>为单位，每次传输的字节数不受限制。如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/25f747bf1fa3423fb4f0ab045629a7e9.webp" style="zoom: 40%;" />
<ol start="2">
<li>起始和停止信号</li>
</ol>
<p>SCL 线为<code>高电平</code>期间，<code>SDA 线由高电平向低电平的变化表示起始信号</code>；<code>SCL</code> 线为<code>高电平</code>期间，<code>SDA 线由低电平向高电平的变化表示终止信号</code>。起始和终止信号都是由<code>主机</code>发出的，在起始信号产生后，总线就处于被占用的状态；在终止信号产生后，总线就处于空闲状态。如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/56143584cafb4e4989d05bd05ef5a3eb.webp" style="zoom:40%;" />
<blockquote>
<p><strong>起始条件</strong>：SCL高电平期间，SDA从<code>高电平</code>切换到<code>低电平</code><br>
<strong>终止条件</strong>：SCL高电平期间，SDA从<code>低电平</code>切换到<code>高电平</code></p>
</blockquote>
<ol start="3">
<li>应答响应</li>
</ol>
<p>每当发送器件传输完一个<code>字节</code>的数据后，后面必须紧跟一个校验位，这个校验位是接收端通过控制 <code>SDA</code>（数据线）来实现的，以提醒发送端数据我这边已经接收完成，数据传送可以继续进行。这个校验位其实就是数据或地址传输过程中的响应。响应包括“<code>应答(ACK)”和“非应答(NACK)</code>”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后，若希望对方<code>继续发送数据</code>，则需要向对方发送“<code>应答(ACK)</code>”信号即特定的<code>低电平脉冲</code>， 发送方会继续发送下一个数据；若接收端希望<code>结束数据传输</code>，则向对方发送“<code>非应答(NACK)</code>”信号即特定的<code>高电平脉冲</code>，发送方接收到该信号后会产生一个停止信号，结束信号传输。应答响应时序图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/183438e594b8460780b55facd4dd00b9.webp" style="zoom:40%;" />
<p>I2C 通信是<code>高位在前，低位在后</code>，每一个字节必须保证 <code>8 位</code>长度。数据传送时，先<code>传送最高位</code>（MSB），每一个被传送的字节后面都必须<code>跟随一位应答位</code>（即一帧共有 9 位）。这些信号中，<code>起始信号是必需的，结束信号和应答信号都可以不要</code></p>
<blockquote>
<p><code>发送应答</code>：在<code>接收</code>完一个字节之后，主机在下一个时钟发送一位数据，<code>数据0表示应答，数据1表示非应答</code><br>
<code>接收应答</code>：在<code>发送</code>完一个字节之后，<code>主机</code>在下一个时钟接收一位数据，判断从机是否应答，<code>数据0表示应答，数据1表示非应答(主机在接收之前，需要释放SDA)</code></p>
</blockquote>
<ol start="4">
<li>总线的寻址方式</li>
</ol>
<p>I2C 总线寻址按照从机地址位数可分为两种，<code>一种是 7 位，另一种是 10 位</code>。采用 7 位的寻址字节（寻址字节是起始信号后的第一个字节）的位定义如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/33393f28ff184d1187c74acbe0c2e342.webp" style="zoom:50%;" />
<p>D7～D1 位组成从机的<code>地址</code>。D0 位是数据传送方向位，为“ <code>0</code>”时表示<code>主机向从机写数据</code>，为“<code>1</code>”时表示<code>主机由从机读数据</code>。在一个系统中可能希望接入多个相同的从机，从机地址中可编程部分决定了可接入总线该类器件的最大数目。如一个从机的 <code>7 位寻址位有 4 位是固定位，3 位是可编程位</code>，这时仅能寻址 8 个同样的器件，即可以有 8 个同样的器件接入到该 I2C 总线系统中。</p>
<ol start="5">
<li>数据传输</li>
</ol>
<p>I2C 总线上传送的数据信号是广义的，既包括地址信号，又包括真正的数据信号。在<code>起始信号后必须传送一个从机的地址（7 位）</code>，第 <code>8</code> 位是<code>数据的传送方向位（R/W）</code>，<code>用“ 0 ”表示主机发送（写）数据（W），“ 1 ”表示主机接收数据（R)</code>。每次数据传送总是由主机产生的终止信号结束。但是，若主机希望继续占用总线进行新的数据传送，则可以不产生终止信号，马上再次发出起始信号对另一从机进行寻址。</p>
<p>A2、A1、A0 都是接的 GND，也就是说都是 0，因此 24C02 的 <code>7 位地址</code>实际上是二进制的 0b1010000，也就是 <code>0x50</code>，AT24C02的固定地址 (8位) 为<code>1010</code>，可配置地址本开发板上为<code>000</code>，所以addr + W为<code>0xA0</code>（发送数据（<code>写</code>）），addr + R为<code>0xA1</code>（请求数据（<code>读</code>））</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-10%20003857.webp" style="zoom:33%;" />
<p>在总线的一次数据传送过程中，可以有以下几种组合方式：</p>
<p><strong>a、主机向从机发送数据，数据传送方向在整个传送过程中不变</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/ea985b6707c4464bace1b99f5147c7f4.webp" style="zoom:50%;" />
<blockquote>
<p>注意：有<code>阴影部分</code>表示数据由<code>主机向从机传送</code>，<code>无阴影部分</code>则表示数据由<code>从机向主机传送</code>。A 表示应答，A 非表示非应答（高电平）。S 表示起始信号，P 表示终止信号。</p>
</blockquote>
<p><strong>b、主机在第一个字节后，立即从从机读数据</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/81ccd6e1aab94baab9b15eac069f5fbd.webp" style="zoom:55%;" />
<p><strong>c、在传送过程中，当需要改变传送方向时，起始信号和从机地址都被重复产生一次，但两次读/写方向位正好相反</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/6f63a77db5de4cf494a5863783726abe.webp" style="zoom:50%;" />
<blockquote>
<p><strong>发送一个字节</strong>：<code>SCL低电平</code>期间，主机<code>将数据位依次放到SDA线</code>上(高位在前)，然后<code>拉高SCL</code>，从机将在<code>SCL高电平</code>期间<code>读取数据位</code>，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节。<br>
<strong>接收一个字节</strong>：<code>SCL低电平</code>期间，从机<code>将数据位依次放到SDA线上</code>(高位在前)，然后<code>拉高SCL</code>，主机将在<code>SCL高电平</code>期间<code>读取数据位</code>，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节(主机在接收之前，需要释放SDA)。</p>
</blockquote>
<h3 id="EEPROM芯片">EEPROM芯片</h3>
<p>在实际的应用中，保存在单片机 RAM 中的数据，掉电后就丢失了，保存在单片机 <code>FLASH</code> 中的数据，又<code>不能随意改变</code>，也就是不能用它来记录变化的数值。一般都是<code>使用 EEPROM 来保存数据</code>， 特点就是<code>掉电后不丢失</code>。我们板子上使用的这个器件是 <code>24C02</code>，是一个容量大小是 2Kbits， 也就是 <code>256 个字节</code>的 <code>EEPROM</code>。一般情况下，EEPROM 拥有 30 万到 100 万次的寿命，也就是它可以反复写入 30-100 万次，而读取次数是无限的。<code>24C02 是一个基于 I2C 通信协议的器件</code>，但是要分清楚，<code>I2C 是一个通信协议</code>，它拥有严密的通信时序逻辑要求， 而 <code>EEPROM 是一个器件</code>，只是这个器件采样了 I2C 协议的接口与单片机相连而已，二者并没有必然的联系，EEPROM 可以用其它接口，I2C 也可以用在其它很多器件上</p>
<p>板子上的 EEPROM 器件型号是 <code>24C02</code>，设备地址高4位是固定的 <code>0b1010</code>，低3位由原理图可知是接地(即低电平)，所以设备地址是 <code>0b1010000</code>(0x50)，如果发送的这个地址确实存在，那么这个地址的器件应该回应一个 <code>ACK</code>(拉低 SDA 即输出“0”)，如果不存在，就没“人”回应 <code>ACK</code>(SDA将保持高电平即“1”)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015214549.jpg" alt=""></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221015221322.jpg" style="zoom:80%;" />
<h4 id="EEPROM-单字节读写操作时序">EEPROM 单字节读写操作时序</h4>
<ol>
<li>EEPROM 写数据流程</li>
</ol>
<p>● 第一步，首先是 <code>I2C 的起始信号</code>，接着跟上<code>首字节</code>，也就是 I2C 的<code>器件地址</code>，并且在读写方向上选择<code>“写”操作</code></p>
<p>● 第二步，<code>发送数据的存储地址</code>。24C02 一共 256 个字节的存储空间，地址从 0x00～0xFF，我们想把数据存储在哪个位置，此刻写的就是哪个地址</p>
<p>● 第三步，发送要存储的数据第一个字节、第二个字节……注意在写数据的过程中，EEPROM 每个字节都会回应一个“<code>应答位 0</code>”，来告诉我们写 EEPROM 数据成功，如果没有回应答位，说明写入不成功。</p>
<p>在写数据的过程中，每成功写入一个字节，EEPROM 存储空间的地址就会<code>自动加 1</code>，当加到 0xFF 后，再写一个字节，地址会溢出又变成了 0x00</p>
<ol start="2">
<li>EEPROM 读数据流程</li>
</ol>
<p>● 第一步，首先是 <code>I2C 的起始信号</code>，接着跟上<code>首字节</code>，也就是 I2C 的<code>器件地址</code>，并且在读写方向上选择“<code>写</code>”操作。选择写操作，是为了把所要<code>读的数据的存储地址先写进去</code>，告诉 EEPROM 我们要读取哪个地址的数据。</p>
<p>● 第二步，<code>发送要读取的数据的地址</code>，注意是地址而非存在 EEPROM 中的数据，通知 EEPROM 我要哪个分机的信息。</p>
<p>● 第三步，重新<code>发送 I2C 起始信号和器件地址</code>，并且在方向位选择“<code>读</code>”操作。</p>
<p>这三步当中，每一个字节实际上都是在“<code>写</code>”，所以每一个字节 EEPROM 都会回应一个“应答位 0”。</p>
<p>● 第四步，<code>读取从器件发回的数据</code>，读一个字节，如果还想继续读下一个字节，就发送一个“应答位 ACK(0)”，如果不想读了，告诉 EEPROM，我不想要数据了，别再发数据了，那就发送一个“非应答位 NAK(1)”。</p>
<blockquote>
<p>A、<code>单片机是主机，24C02 是从机</code><br>
B、无论是读是写，<code>SCL</code> 始终都是由<code>主机</code>控制的<br>
C、写的时候应答信号由 <code>从机</code> 给出，表示<code>从机是否正确接收了数据</code><br>
D、读的时候应答信号则由 <code>主机</code> 给出，表示<code>是否继续读下去</code></p>
</blockquote>
<h4 id="EEPROM-多字节读写操作时序">EEPROM 多字节读写操作时序</h4>
<p>给 EEPROM 发送数据后，先保存在了 EEPROM的缓存里，EEPROM 必须要<code>把缓存中的数据搬移到“非易失”的区域</code>，才能达到掉电不丢失的效果。而往非易失区域写需要一定的时间，每种器件不完全一样，24C02 的 这个写入时间最高不超过 <code>5ms</code> (在往非易失区域写的过程，EEPROM 是不会再响应我们的访问的，不仅接收不到我们的数据，我们即使用 I2C 标准的寻址模式去寻址，EEPROM 都不会应答，就如同这个总线上没有这个器件一样。数据写入非易失区域完毕后，EEPROM 再次恢复正常，可以正常读写了)</p>
<h4 id="EEPROM-的页写入">EEPROM 的页写入</h4>
<p>在向 EEPROM 连续写入多个字节的数据时，如果每写一个字节都要等待几 ms 的话，整体上的写入效率就太低了。所以就想了一个办法，<code>把 EEPROM 分页管理</code>。 <code>24C01、24C02</code> 这两个型号是 <code>8 个字节一个页</code>，而 <code>24C04、24C08、24C16</code> 是 <code>16 个字节一页</code>。 开发板上用的型号是 <code>24C02</code>，<code>一共是 256 个字节，8 个字节一页，那么就一共有 32 页</code>。 分配好页之后，如果我们在同一个页内连续写入几个字节后，最后再发送停止位的时序。 EEPROM 检测到这个停止位后，就会一次性把这一页的数据写到非易失区域，就不需要写一个字节检测一次了，并且页写入的时间也不会超过 5ms。如果我们写入的数据跨页了，那么<code>写完了一页</code>之后，我们要发送一个<code>停止位</code>，然后等待并且检测 EEPROM 的<code>空闲模式</code>，一直<code>等到把上一页数据完全写到非易失区域后，再进行下一页的写入</code>，这样就可以在很大程度上提高数据的写入效率</p>
<h3 id="程序-8">程序</h3>
<blockquote>
<h4 id="访问-EEPROM-的地址">访问 EEPROM 的地址</h4>
</blockquote>
<p>用 I2C 的协议来寻址 0x50，另外再寻址一个不存在的地址 0x62，寻址完毕后，把返回的 ACK 显示到我们的 1602 液晶上(这里0表示地址存在，1表示地址不存在)</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                    <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 寻址函数，即检查地址为 addr 的器件是否存在，返回值-从器件应答值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Addressing</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack;</span><br><span class="line">    I2C_Start();  <span class="comment">//产生起始位，即启动一次总线操作</span></span><br><span class="line">    ack = I2C_Write(addr &lt;&lt; <span class="number">1</span>); <span class="comment">//器件地址需左移一位，因寻址命令的最低位为读写位，用于表示之后的操作是读或写</span></span><br><span class="line">    I2C_Stop();   <span class="comment">//不需进行后续读写，而直接停止本次总线操作</span></span><br><span class="line">    <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">bit <span class="title function_">I2C_Addressing</span><span class="params">(u8 addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack;</span><br><span class="line">    u8 str[<span class="number">10</span>];</span><br><span class="line">    Lcd1602_Init(); <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    ack = I2C_Addressing(<span class="number">0x50</span>); <span class="comment">//查询地址为 0x50 的器件</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;5&#x27;</span>;               <span class="comment">//将地址和应答值转换为字符串</span></span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    str[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)ack + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//转换为字符串</span></span><br><span class="line">    str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;              <span class="comment">//结束符</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);     <span class="comment">//显示到液晶上</span></span><br><span class="line"></span><br><span class="line">    ack = I2C_Addressing(<span class="number">0x62</span>); <span class="comment">//查询地址为 0x62 的器件</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;6&#x27;</span>;               <span class="comment">//将地址和应答值转换为字符串</span></span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    str[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)ack + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//转换为字符串</span></span><br><span class="line">    str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;          <span class="comment">//结束符</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">8</span>, <span class="number">0</span>, str); <span class="comment">//显示到液晶上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="读取-EEPROM-地址上的一个数据，将读出来的数据加-1，再写到-EEPROM-地址上">读取 EEPROM 地址上的一个数据，将读出来的数据加 1，再写到 EEPROM 地址上</h4>
</blockquote>
<p>读取 EEPROM 的 0x02 这个地址上的一个数据，不管这个数据之前是多少，都将读出来的数据加 1，再写到 EEPROM 的 0x02 这个地址上</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                  <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送非应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位    (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                    receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;     <span class="comment">//则接收到的数据加1             向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                   <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;<span class="comment">//再拉低 SCL，以使从机发送出下一位     为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                  <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;   <span class="comment">//8 位数据发送完后，拉高 SDA，发送非应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;   <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;   <span class="comment">//再拉低 SCL 完成非应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位  (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                  receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;    <span class="comment">//则接收到的数据加1           向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                 <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;                                 <span class="comment">//为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//8 位数据发送完后，拉低 SDA，发送应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>EEPROM.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 EEPROM 中的一个字节，addr-字节地址 */</span></span><br><span class="line">u8 <span class="title function_">EEPROM_ReadByte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_Write(<span class="number">0xA0</span>);           <span class="comment">//写命令(寻找从机) 最后一位为0表示主机向从机写数据</span></span><br><span class="line">    I2C_Write(addr);           <span class="comment">//写入存储地址</span></span><br><span class="line">    I2C_Start();               <span class="comment">//发送重复启动信号</span></span><br><span class="line">    I2C_Write(<span class="number">0xA1</span>);           <span class="comment">//进入接收模式   最后一位为1表示主机由从机读数据</span></span><br><span class="line">    receive = I2C_ReadNACK();  <span class="comment">//读取字节数据</span></span><br><span class="line">    I2C_Stop();                <span class="comment">//产生一个停止条件</span></span><br><span class="line">    <span class="keyword">return</span> receive;            <span class="comment">//返回读取的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 EEPROM 中写入一个字节，addr-字节地址 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_WriteByte</span><span class="params">(u8 addr, u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_Write(<span class="number">0xA0</span>); <span class="comment">//写命令，寻址器件，后续为写操作(前面4位固定，后面三位接gnd所以是0)</span></span><br><span class="line">    I2C_Write(addr); <span class="comment">//写入存储地址</span></span><br><span class="line">    I2C_Write(dat);  <span class="comment">//写入一个字节数据</span></span><br><span class="line">    I2C_Stop();      <span class="comment">//产生一个停止条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EEPROM.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EEPROM_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EEPROM_H_</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">EEPROM_ReadByte</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_WriteByte</span><span class="params">(u8 addr, u8 dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 dat;</span><br><span class="line">    u8 str[<span class="number">10</span>];</span><br><span class="line">    Lcd1602_Init(); <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    dat = EEPROM_ReadByte(<span class="number">0x02</span>); <span class="comment">//读取指定地址上的一个字节</span></span><br><span class="line">    str[<span class="number">0</span>] = (dat / <span class="number">100</span>) + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//转换为十进制字符串格式</span></span><br><span class="line">    str[<span class="number">1</span>] = (dat / <span class="number">10</span> % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str[<span class="number">2</span>] = (dat % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);      <span class="comment">//显示在液晶上</span></span><br><span class="line">    dat++;                       <span class="comment">//将其数值+1</span></span><br><span class="line">    EEPROM_WriteByte(<span class="number">0x02</span>, dat); <span class="comment">//再写回到对应的地址上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EEPROM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="EEPROM页写入-–-读取-EEPROM-地址上的多个数据，将读出来的数据分别-1-3-5···，再写到-EEPROM-地址上">EEPROM页写入 – 读取 EEPROM 地址上的多个数据，将读出来的数据分别 + 1 3 5···，再写到 EEPROM 地址上</h4>
</blockquote>
<p>函数 <code>MemToStr</code>：可以把一段<code>内存数据</code>转换成<code>十六进制字符串</code>的形式。由于我们从 EEPROM 读出来的是正常的数据，而 1602 液晶接收的是 <code>ASCII 码字符</code>，因此我们要通过液晶把数据显示出来必须先通过一步转换。就是把每一个字节的数据高 4 位 和低 4 位分开，和 9 进行比较，如果小于等于 9，则直接加 <code>'0'</code> 转为 0～9 的 ASCII 码；如果大于 9，则先<code>减掉 10 再加 ‘A’ </code>即可转为 A～F 的 ASCII 码</p>
<p>函数 EEPROM_Read：在读之前，要查询一下当前是否可以进行读写操作，EEPROM 正常响应才可以进行。进行后，读最后一个字节之前的，全部给出 ACK，而读完了最后一个字节， 我们要给出一个 NAK</p>
<p>函数 EEPROM_Write：每次写操作之前，都要进行查询判断当前 EEPROM 是否响应，正常响应后才可以写数据</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                  <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送非应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位    (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                    receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;     <span class="comment">//则接收到的数据加1             向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                   <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;<span class="comment">//再拉低 SCL，以使从机发送出下一位     为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                  <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;   <span class="comment">//8 位数据发送完后，拉高 SDA，发送非应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;   <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;   <span class="comment">//再拉低 SCL 完成非应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位  (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                  receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;    <span class="comment">//则接收到的数据加1           向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                 <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;                                 <span class="comment">//为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//8 位数据发送完后，拉低 SDA，发送应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>EEPROM.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* E2 读取函数，buf-数据接收指针，addr-E2 中的起始地址，len-读取长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(u8 *buf, u8 addr, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>                       <span class="comment">//用寻址操作查询当前是否可进行读写操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_Start();           <span class="comment">//写命令(寻找从机) 最后一位为0表示主机向从机写数据</span></span><br><span class="line">        <span class="keyword">if</span>(I2C_Write(<span class="number">0xA0</span>))    <span class="comment">//应答则跳出循环，非应答则进行下一次查询</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//应答返回1符合if条件然后break跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;               <span class="comment">//非应答返回0则一直在do while循环里面一直等到应答</span></span><br><span class="line">        &#125;</span><br><span class="line">        I2C_Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    I2C_Write(addr);         <span class="comment">//写入起始地址</span></span><br><span class="line">    I2C_Start();             <span class="comment">//发送重复启动信号</span></span><br><span class="line">    I2C_Write(<span class="number">0xA1</span>);         <span class="comment">//进入接收模式   最后一位为1表示主机由从机读数据</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">1</span>)           <span class="comment">//连续读取 len-1 个字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        *buf++ = I2C_ReadACK();<span class="comment">//最后字节之前为读取操作+应答</span></span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = I2C_ReadNACK();   <span class="comment">//最后一个字节为读取操作+非应答</span></span><br><span class="line">    I2C_Stop();              <span class="comment">//产生一个停止条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* E2 写入函数，buf-源数据指针，addr-E2 中的起始地址，len-写入长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 *buf, u8 addr, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待上次写入操作完成</span></span><br><span class="line">        <span class="keyword">do</span>                       <span class="comment">//用寻址操作查询当前是否可进行读写操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            I2C_Start();           <span class="comment">//写命令(寻找从机) 最后一位为0表示主机向从机写数据</span></span><br><span class="line">            <span class="keyword">if</span>(I2C_Write(<span class="number">0xA0</span>))    <span class="comment">//应答则跳出循环，非应答则进行下一次查询</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//应答返回1符合if条件然后break跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;               <span class="comment">//非应答返回0则一直在do while循环里面一直等到应答</span></span><br><span class="line">            &#125;</span><br><span class="line">            I2C_Stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//按页写模式连续写入字节</span></span><br><span class="line">        I2C_Write(addr);           <span class="comment">//写入起始地址</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            I2C_Write(*buf++);       <span class="comment">//写入一个字节数据</span></span><br><span class="line">            len--;                   <span class="comment">//待写入长度计数递减</span></span><br><span class="line">            addr++;                  <span class="comment">//E2 地址递增</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == (addr &amp; <span class="number">0x07</span>))   <span class="comment">//检查地址是否到达页边界，24C02 每页 8 字节，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所以检测低 3 位是否为零即可</span></span><br><span class="line">                <span class="keyword">break</span>;                 <span class="comment">//到达页边界时，跳出循环，结束本次写操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        I2C_Stop();                <span class="comment">//产生一个停止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EEPROM.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EEPROM_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EEPROM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(u8 *buf, u8 addr, u8 len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 *buf, u8 addr, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(u8 *str, u8 *src, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 buf[<span class="number">5</span>];</span><br><span class="line">    u8 str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    Lcd1602_Init(); <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    EEPROM_Read(buf, <span class="number">0x8E</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">//从 EEPROM 中读取一段数据</span></span><br><span class="line">    MemToStr(str, buf, <span class="keyword">sizeof</span>(buf));    <span class="comment">//转换为十六进制字符串</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);             <span class="comment">//显示到液晶上</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(buf); i++)    <span class="comment">//数据依次+1,+2,+3...</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf[i] = buf[i] + <span class="number">1</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    EEPROM_Write(buf, <span class="number">0x8E</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">//数据依次+1,+2,+3...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一段内存数据转换为十六进制格式的字符串，str-字符串指针，src-源数据地址，len-数据长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MemToStr</span><span class="params">(u8 *str, u8 *src, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp;</span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = *src &gt;&gt; <span class="number">4</span>;       <span class="comment">//先取高 4 位</span></span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">9</span>)           <span class="comment">//转换为 0-9 或 A-F</span></span><br><span class="line">            *str++ = temp + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//先把值传递给str指向的地址，然后地址++</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *str++ = temp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        temp = *src &amp; <span class="number">0x0F</span>;     <span class="comment">//再取低 4 位</span></span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">9</span>)           <span class="comment">//转换为 0-9 或 A-F</span></span><br><span class="line">            *str++ = temp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *str++ = temp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;           <span class="comment">//转换完一个字节添加一个空格</span></span><br><span class="line">        src++;                  <span class="comment">//原数据地址++，转化为下个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">    *str++ = <span class="string">&#x27;\0&#x27;</span>;            <span class="comment">//添加字符串结束符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EEPROM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="I2C-和-EEPROM-的综合实验">I2C 和 EEPROM 的综合实验</h4>
</blockquote>
<p>上电后，1602 的第一行显示 EEPROM 从 0x20 地址开始的 16 个字符，第二行显示 EERPOM 从 0x40 开始的 16 个字符。可以通过 UART 串口通信来改变 EEPROM 内部的这个数据，并且同时也改变了 1602 显示的内容，下次上电的时候，直接会显示更新过的内容</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>UART.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">bit flagFrame = <span class="number">0</span>;   <span class="comment">//帧接收完成标志，即接收到一帧新数据</span></span><br><span class="line">bit flagTxd = <span class="number">0</span>;     <span class="comment">//单字节发送完成标志，用来替代 TXD 中断标志位</span></span><br><span class="line">u8 cntRxd = <span class="number">0</span>;       <span class="comment">//接收字节计数器</span></span><br><span class="line">u8 pdata bufRxd[<span class="number">64</span>]; <span class="comment">//接收字节缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口配置函数，baud-通信波特率 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UAER_Init</span><span class="params">(u16 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCON = <span class="number">0x50</span>;  <span class="comment">//配置串口为模式 1  0101 0000 --&gt; 0x50</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>; <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x20</span>; <span class="comment">//配置 T1 为模式 2  0010 0000 --&gt; 0x20</span></span><br><span class="line">    TH1 = <span class="number">256</span> - (<span class="number">11059200</span> / <span class="number">12</span> / <span class="number">32</span>) / baud; <span class="comment">//计算 T1 重载值</span></span><br><span class="line">    TL1 = TH1;  <span class="comment">//初值等于重载值</span></span><br><span class="line">    EA = <span class="number">1</span>;     <span class="comment">//使能总中断</span></span><br><span class="line">    ES = <span class="number">1</span>;     <span class="comment">//使能串口中断</span></span><br><span class="line">    ET1 = <span class="number">0</span>;    <span class="comment">//禁止 T1 中断</span></span><br><span class="line">    TR1 = <span class="number">1</span>;    <span class="comment">//启动 T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据写入，即串口发送函数，buf-待发送数据的指针，len-指定的发送长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Write</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len--)  <span class="comment">//循环发送所有字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        flagTxd = <span class="number">0</span>;      <span class="comment">//清零发送标志</span></span><br><span class="line">        SBUF = *buf++;    <span class="comment">//发送一个字节数据</span></span><br><span class="line">        <span class="keyword">while</span>(!flagTxd);  <span class="comment">//等待该字节发送完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口数据读取函数，buf-接收指针，len-指定的读取长度，返回值-实际读到的长度 */</span></span><br><span class="line">u8 <span class="title function_">UartRead</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; cntRxd) <span class="comment">//指定读取长度大于实际接收到的数据长度时</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = cntRxd;  <span class="comment">//读取长度设置为实际接收到的数据长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">//拷贝接收到的数据到接收指针上</span></span><br><span class="line">    &#123;</span><br><span class="line">        *buf++ = bufRxd[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cntRxd = <span class="number">0</span>; <span class="comment">//接收计数器清零</span></span><br><span class="line">    <span class="keyword">return</span> len; <span class="comment">//返回实际读取长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口接收监控，由空闲时间判定帧结束，需在定时中断中调用，ms-定时间隔 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_RxMonitor</span><span class="params">(u8 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 cntbkp = <span class="number">0</span>;   <span class="comment">//前一次接收到数据的长度</span></span><br><span class="line">    <span class="type">static</span> u8 idletmr = <span class="number">0</span>;  <span class="comment">//空闲计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cntRxd &gt; <span class="number">0</span>)          <span class="comment">//接收计数器大于零时，监控总线空闲时间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cntbkp != cntRxd)  <span class="comment">//接收计数器改变，即刚接收到数据时，清零空闲计时(与前一次接收到的数据长度不一样代表接收到数据)</span></span><br><span class="line">        &#123;</span><br><span class="line">            cntbkp = cntRxd;    <span class="comment">//把本次接收到数据赋给前一次接收到的数据</span></span><br><span class="line">            idletmr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                  <span class="comment">//接收计数器未改变，即总线空闲时，累积空闲时间</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idletmr &lt; <span class="number">30</span>)    <span class="comment">//空闲计时小于 30ms 时，持续累加</span></span><br><span class="line">            &#123;</span><br><span class="line">                idletmr += ms;</span><br><span class="line">                <span class="keyword">if</span>(idletmr &gt;= <span class="number">30</span>) <span class="comment">//空闲时间达到 30ms 时，即判定为一帧接收完毕</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flagFrame = <span class="number">1</span>;  <span class="comment">//设置帧接收完成标志</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cntbkp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口驱动函数，监测数据帧的接收，调度功能函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 len;</span><br><span class="line">    u8 pdata buf[<span class="number">40</span>]; <span class="comment">//数据缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(flagFrame)     <span class="comment">//有命令到达时，读取处理该命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        flagFrame = <span class="number">0</span>;</span><br><span class="line">        len = UartRead(buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">//将接收到的命令读取到缓冲区中</span></span><br><span class="line">        Uart_Action(buf, len);           <span class="comment">//传递数据帧，调用动作执行函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART</span><span class="params">()</span> interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(RI)    <span class="comment">//接收到新字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        RI = <span class="number">0</span>; <span class="comment">//清零接收中断标志位</span></span><br><span class="line">        <span class="keyword">if</span>(cntRxd &lt; <span class="keyword">sizeof</span>(bufRxd)) <span class="comment">//接收缓冲区尚未用完时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//保存接收字节，并递增计数器</span></span><br><span class="line">            bufRxd[cntRxd++] = SBUF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(TI) <span class="comment">//字节发送完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        TI = <span class="number">0</span>;        <span class="comment">//清零发送中断标志位</span></span><br><span class="line">        flagTxd = <span class="number">1</span>;   <span class="comment">//设置字节发送完成标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UART.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _UART_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _UART_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">UAER_Init</span><span class="params">(u16 baud)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Write</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line">u8 <span class="title function_">UartRead</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_RxMonitor</span><span class="params">(u8 ms)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Uart_Action</span><span class="params">(u8 *buf, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                  <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送非应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位    (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                    receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;     <span class="comment">//则接收到的数据加1             向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                   <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;<span class="comment">//再拉低 SCL，以使从机发送出下一位     为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                  <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;   <span class="comment">//8 位数据发送完后，拉高 SDA，发送非应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;   <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;   <span class="comment">//再拉低 SCL 完成非应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位  (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                  receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;    <span class="comment">//则接收到的数据加1           向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                 <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;                                 <span class="comment">//为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//8 位数据发送完后，拉低 SDA，发送应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>EEPROM.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* E2 读取函数，buf-数据接收指针，addr-E2 中的起始地址，len-读取长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(u8 *buf, u8 addr, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>                       <span class="comment">//用寻址操作查询当前是否可进行读写操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_Start();           <span class="comment">//写命令(寻找从机) 最后一位为0表示主机向从机写数据</span></span><br><span class="line">        <span class="keyword">if</span>(I2C_Write(<span class="number">0xA0</span>))    <span class="comment">//应答则跳出循环，非应答则进行下一次查询</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//应答返回1符合if条件然后break跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;               <span class="comment">//非应答返回0则一直在do while循环里面一直等到应答</span></span><br><span class="line">        &#125;</span><br><span class="line">        I2C_Stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    I2C_Write(addr);         <span class="comment">//写入起始地址</span></span><br><span class="line">    I2C_Start();             <span class="comment">//发送重复启动信号</span></span><br><span class="line">    I2C_Write(<span class="number">0xA1</span>);         <span class="comment">//进入接收模式   最后一位为1表示主机由从机读数据</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">1</span>)           <span class="comment">//连续读取 len-1 个字节</span></span><br><span class="line">    &#123;</span><br><span class="line">        *buf++ = I2C_ReadACK();<span class="comment">//最后字节之前为读取操作+应答</span></span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    *buf = I2C_ReadNACK();   <span class="comment">//最后一个字节为读取操作+非应答</span></span><br><span class="line">    I2C_Stop();              <span class="comment">//产生一个停止条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* E2 写入函数，buf-源数据指针，addr-E2 中的起始地址，len-写入长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 *buf, u8 addr, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待上次写入操作完成</span></span><br><span class="line">        <span class="keyword">do</span>                       <span class="comment">//用寻址操作查询当前是否可进行读写操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            I2C_Start();           <span class="comment">//写命令(寻找从机) 最后一位为0表示主机向从机写数据</span></span><br><span class="line">            <span class="keyword">if</span>(I2C_Write(<span class="number">0xA0</span>))    <span class="comment">//应答则跳出循环，非应答则进行下一次查询</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//应答返回1符合if条件然后break跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;               <span class="comment">//非应答返回0则一直在do while循环里面一直等到应答</span></span><br><span class="line">            &#125;</span><br><span class="line">            I2C_Stop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//按页写模式连续写入字节</span></span><br><span class="line">        I2C_Write(addr);           <span class="comment">//写入起始地址</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            I2C_Write(*buf++);       <span class="comment">//写入一个字节数据</span></span><br><span class="line">            len--;                   <span class="comment">//待写入长度计数递减</span></span><br><span class="line">            addr++;                  <span class="comment">//E2 地址递增</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == (addr &amp; <span class="number">0x07</span>))   <span class="comment">//检查地址是否到达页边界，24C02 每页 8 字节，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//所以检测低 3 位是否为零即可</span></span><br><span class="line">                <span class="keyword">break</span>;                 <span class="comment">//到达页边界时，跳出循环，结束本次写操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        I2C_Stop();                <span class="comment">//产生一个停止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EEPROM.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _EEPROM_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _EEPROM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Read</span><span class="params">(u8 *buf, u8 addr, u8 len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 *buf, u8 addr, u8 len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_ShowStr</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">Cmp_Memory</span><span class="params">(u8 *ptr1, u8 *ptr2, u8 len)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TrimString16</span><span class="params">(u8 *out, u8 *in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Init(<span class="number">1</span>);   <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    UAER_Init(<span class="number">9600</span>); <span class="comment">//配置波特率为 9600</span></span><br><span class="line">    Lcd1602_Init();  <span class="comment">//初始化液晶</span></span><br><span class="line">    Init_ShowStr();  <span class="comment">//初始显示内容</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Uart_Driver(); <span class="comment">//调用串口驱动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理液晶屏初始显示内容 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_ShowStr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 str[<span class="number">17</span>];</span><br><span class="line">    str[<span class="number">16</span>] = <span class="string">&#x27;\0&#x27;</span>;           <span class="comment">//在最后添加字符串结束符，确保字符串可以结束</span></span><br><span class="line">    EEPROM_Read(str, <span class="number">0x20</span>, <span class="number">16</span>); <span class="comment">//读取第一行字符串，其 EEPROM 起始地址为 0x20</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);   <span class="comment">//显示到液晶屏</span></span><br><span class="line">    EEPROM_Read(str, <span class="number">0x40</span>, <span class="number">16</span>); <span class="comment">//读取第二行字符串，其 EEPROM 起始地址为 0x40</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, str);   <span class="comment">//显示到液晶屏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存比较函数，比较两个指针所指向的内存数据是否相同，ptr1-待比较指针 1，ptr2-待比较指针 2，</span></span><br><span class="line"><span class="comment">   len-待比较长度，返回值-两段内存数据完全相同时返回 1，不同返回 0 */</span></span><br><span class="line">bit <span class="title function_">Cmp_Memory</span><span class="params">(u8 *ptr1, u8 *ptr2, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*ptr1++ != *ptr2++) <span class="comment">//遇到不相等数据时即刻返回 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//比较完全部长度数据都相等则返回 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将一字符串整理成 16 字节的固定长度字符串，不足部分补空格</span></span><br><span class="line"><span class="comment"> out-整理后的字符串输出指针，in-待整理字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TrimString16</span><span class="params">(u8 *out, u8 *in)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*in != <span class="string">&#x27;\0&#x27;</span>) <span class="comment">//拷贝字符串直到输入字符串结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        *out++ = *in++;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">16</span>)      <span class="comment">//当拷贝长度已达到 16 字节时，强制跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">16</span>; i++) <span class="comment">//如不足 16 个字节则用空格补齐</span></span><br><span class="line">    &#123;</span><br><span class="line">        *out++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *out = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">//最后添加结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串口动作函数，根据接收到的命令帧执行响应的动作，buf-接收到的命令帧指针，len-命令帧长度 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Uart_Action</span><span class="params">(u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 str[<span class="number">17</span>];</span><br><span class="line">    u8 code cmd0[] = <span class="string">&quot;showstr1 &quot;</span>; <span class="comment">//第一行字符显示命令</span></span><br><span class="line">    u8 code cmd1[] = <span class="string">&quot;showstr2 &quot;</span>; <span class="comment">//第二行字符显示命令</span></span><br><span class="line">    u8 code cmdLen[] = &#123;<span class="keyword">sizeof</span>(cmd0) - <span class="number">1</span>, <span class="keyword">sizeof</span>(cmd1) - <span class="number">1</span> &#125;; <span class="comment">//命令长度汇总表</span></span><br><span class="line">    u8 code *cmdPtr[] = &#123; &amp;cmd0[<span class="number">0</span>], &amp;cmd1[<span class="number">0</span>] &#125;;              <span class="comment">//命令指针汇总表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(cmdLen); i++)            <span class="comment">//遍历命令列表，查找相同命令</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= cmdLen[i])                         <span class="comment">//首先接收到的数据长度要不小于命令长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Cmp_Memory(buf, cmdPtr[i], cmdLen[i]))  <span class="comment">//比较相同时退出循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(i)  <span class="comment">//根据比较结果执行相应命令</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//为接收到的字符串添加结束符</span></span><br><span class="line">        TrimString16(str, buf + cmdLen[<span class="number">0</span>]);  <span class="comment">//整理成 16 字节固定长度字符串</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);              <span class="comment">//显示字符串 1</span></span><br><span class="line">        EEPROM_Write(str, <span class="number">0x20</span>, <span class="keyword">sizeof</span>(str)); <span class="comment">//保存字符串 1，起始地址为 0x20</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;                     <span class="comment">//为接收到的字符串添加结束符</span></span><br><span class="line">        TrimString16(str, buf + cmdLen[<span class="number">1</span>]);  <span class="comment">//整理成 16 字节固定长度字符串</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, str);              <span class="comment">//显示字符串 2</span></span><br><span class="line">        EEPROM_Write(str, <span class="number">0x40</span>, <span class="keyword">sizeof</span>(str)); <span class="comment">//保存字符串 2，起始地址为 0x40</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">//未找到相符命令时，给上机发送“错误命令”的提示</span></span><br><span class="line">        Uart_Write(<span class="string">&quot;bad command.\r\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;bad command.\r\n&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\r&#x27;</span>; <span class="comment">//有效命令被执行后，在原命令帧之后添加</span></span><br><span class="line">    buf[len++] = <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//回车换行符后返回给上位机，表示已执行</span></span><br><span class="line">    Uart_Write(buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH;        <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Uart_RxMonitor(<span class="number">1</span>); <span class="comment">//串口接收监控</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UART.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EEPROM.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="实时时钟-DS1302">实时时钟 DS1302</h2>
<h3 id="BCD-码">BCD 码</h3>
<p>BCD 码亦称<code>二进码十进制数</code>或<code>二-十进制代码</code>。用 <code>4 位二进制数来表示 1 位十进制数中的 0～9 这 10 个数字</code>。是一种二进制的数字编码形式，用二进制编码的十进制代码。十进制的一位数字，从 0 到 9，最大的数字就是 9，再加 1 就要进位，所以用 4 位二进制表示十进制，就是从<code> 0b0000 到 0b1001</code>，不存在 0b1010、 0b1011、0b1100、0b1101、0b1110、0b1111 这 6 个数字。BCD 码如果到了 0b1001，再加 1 的话，数字就变成 0b00010000 这样了，相当于用了 8 位的二进制数字表示了 2 位的十进制数字</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/b1af064f5a32430ca69ab77f2011df59.webp" style="zoom:50%;" />
<p>从 DS1302 中读取出来的时钟数据均为 BCD 码格式，需转换为我们习惯的 10 进制</p>
<p>日期时间在时钟芯片中的存储格式就是 BCD 码，直接 <code>取出表示十进制 1 位数字的 4 个二进制位然后再加上 0x30 就可组成一个ASCII码字节</code></p>
<p>需要注意：<code>DS1302低位在前，高位在后</code></p>
<h3 id="SPI-时序">SPI 时序</h3>
<p>SPI 是串行外围设备接口，是一种高速的、全双工、同步通信总线，常用于单片机和 EEPROM、FLASH、实时时钟、数字信号处理器等器件的通信</p>
<p>SPI 通信原理主要是主从方式通信，这种模式通常只有一个主机和一个或者多个从机，标准的 SPI 是 4 根线，分别是 <code>SSEL</code>（片选，也写作 <code>SCS</code>）、<code>SCLK</code>（时钟，也写作 <code>SCK</code>）、<code>MOSI</code>（<code>主机输出从机输入</code>）和 <code>MISO</code>（<code>主机输入从机输出</code> ）</p>
<blockquote>
<p><strong>SSEL</strong>：从设备片选<code>使能信号</code>。如果从设备是低电平使能的话，当拉低这个引脚后，从设备就会被选中，主机和这个被选中的从机进行通信</p>
<p><strong>SCLK</strong>：<code>时钟信号</code>，由主机产生，和 I2C 通信的 SCL 有点类似</p>
<p><strong>MOSI</strong>：主机给从机<code>发送</code>指令或者数据的通道</p>
<p><strong>MISO</strong>：主机<code>读取</code>从机的状态或者数据的通道</p>
</blockquote>
<h4 id="读写数据时序的四种模式">读写数据时序的四种模式</h4>
<p>CPOL：时钟的极性。通信的整个过程分为<code>空闲时刻</code>和<code>通信时刻</code>，如果 SCLK 在数据发送之前和之后的<code>空闲状态是高电平</code>，那么 <code>CPOL=1</code>，如果<code>空闲状态 SCLK 是低电平</code>，那么 <code>CPOL=0</code></p>
<p>CPHA：时钟的相位。<code>CPHA=1</code> 表示<code>数据的输出</code>是在一个时钟周期的<code>第一个沿</code>上，那么<code>数据的采样</code>就是在<code>第二个沿上</code>了；<code>CPHA=0 </code>表示<code>数据的采样</code>是在一个时钟周期的<code>第一个沿上</code>，那么<code>数据的输出</code>就在<code>第二个沿上</code></p>
<blockquote>
<p><strong>模式一</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20005910.webp" style="zoom: 33%;" />
<p>当<code>数据未发送时以及发送完毕</code>后，<code>SCK 都是高电平</code>，因此 <code>CPOL=1</code>。 可以看出，在 SCK 第一个沿的时候，MOSI 和 MISO 会发生变化，同时 SCK 第二个沿的时候，数据是稳定的，此刻采样数据是合适的，也就是上升沿即一个时钟周期的后沿锁存读取数据，即 CPHA=1。最后最隐蔽的 SSEL 片选，这个引脚通常用来决定是哪个从机和主机进行通信</p>
<blockquote>
<p><strong>另外几种模式如图所示：</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20010352.webp" style="zoom: 50%;" />
<h3 id="实时时钟芯片-DS1302">实时时钟芯片 DS1302</h3>
<p>DS1302 是 一种<code>涓流充电时钟芯片</code>，内含有一个<code>实时时钟/日历</code>和 31 字节<code>静态 RAM</code>，通过简单的<code>串行接口</code>与单片机进行通信。<code>实时时钟/日历电路提供秒、分、时、日、周、月、年</code>的信息，每月的天数和闰年的天数可自动调整。时钟操作可通过 AM/PM 指示决定采用 <code>24 或 12</code> 小时格式。</p>
<p>DS1302 与单片机之间能简单地采用<code>同步串行</code>的方式进行通信，仅需用到三根通信线：<code>①RES复位 ②I/O 数据线 ③SCLK 串行时钟</code>。时钟/RAM 的读/写数据以一个字节或多达31 个字节的字符组方式通信。DS1302 工作时功耗很低保持数据和时钟信息时功率小于 1mW。</p>
<p>DS1302 由 DS1202 改进而来增加了以下的特性：<code>双电源管脚用于主电源和备份电源供应</code>，<code>Vcc1 为可编程涓流充电电源</code>，附加七个字节存储器。它广泛应用于电话、传真、便携式仪器以及电池供电的仪器仪表等产品领域下面。</p>
<p><strong>主要的性能指标：</strong></p>
<blockquote>
<p>实时时钟具有能计算 <code>2100 年之前</code>的秒、分、时、日、星期、月、年的能力，还有闰年调整的能力；<br>
31 个 8 位暂存数据存储 RAM；<br>
串行 I/O 口方式使得管脚数量最少；<br>
宽范围工作电压 2.0 - 5.5V；<br>
工作在 2.0V 时，电流小于 300nA；<br>
读/写时钟或 RAM 数据时有两种传送方式<code>单字节传送</code>和<code>多字节传送字符组</code>方式；<br>
8 脚 DIP 封装或可选的 8 脚 SOIC 封装根据表面装配；<br>
简单 3 线接口；<br>
与 TTL 兼容 Vcc=5V；<br>
可选工业级温度范围-40~+85</p>
</blockquote>
<p><strong>DS1302 芯片的管脚及功能</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/ea301ae157784841a6d82ac946e4926a.webp" style="zoom:50%;" />
<blockquote>
<p>1、<code>VCC2</code>：主电源引脚<br>
2、<code>X1、X2</code>：DS1302 外部晶振引脚，通常需外接 <code>32.768K 晶振</code><br>
3、<code>GND</code>：电源地<br>
4、<code>CE</code>：使能引脚，也是复位引脚（新版本功能变）<br>
5、<code>I/O</code>：串行数据引脚，数据输出或者输入都从这个引脚<br>
6、<code>SCLK</code>：串行时钟引脚<br>
7、<code>VCC1</code>：备用电源</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20101914.webp" style="zoom: 33%;" />
<h3 id="DS1302-使用">DS1302 使用</h3>
<p>操作 DS1302 的大致过程，就是将各种<code>数据写入 DS1302 的寄存器</code>，以设置它当前的时间的格式。然后<code>使 DS1302 开始运作</code>，DS1302 时钟会按照设置情况运转，再用<code>单片机将其寄存器内的数据读出</code>。再用<code>液晶显示</code>，就是我们常说的简易电子钟。所以总的来说 DS1302 的操作分 2 步（显示部分属于液晶显示的内容，不属于 DS1302 本身的内容）</p>
<p>DS1302 有一个控制寄存器、12 个日历、时钟寄存器和 31 个 RAM</p>
<h4 id="控制寄存器">控制寄存器</h4>
<p>控制寄存器用于存放 DS1302 的控制命令字，DS1302 的 <code>RST</code> 引脚回到<code>高电平</code>后写入的<code>第一个字节就为控制命令</code>。它用于<code>对 DS1302 读写过程进行控制</code>，格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/cfeba1df0ac74b1bad2c2863796fa3ab.webp" style="zoom:40%;" />
<p>1、第 7 位永远都是 <code>1</code>，这一位如果是 0 的话，那写进去也是无效的<br>
2、第 6 位，<code>1 表示 RAM，寻址内部存储器地址；0 表示 CK，寻址内部寄存器</code>；<br>
3、第 5 到第 1 位，为 RAM 或者寄存器的<code>地址</code>；<br>
4、最低位，<code>高电平</code>表示 RD，即下一步操作将要“<code>读</code>”；<code>低电平</code>表示 W，即下一步操作将要“<code>写</code>”。（与 AT24C02 寄存器类似，0读1写）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/eb2b895ba5f44ef68e3596573a2f5d87.webp" style="zoom:40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/c65ad7bab07548e3a528350b229e0682.webp" style="zoom:40%;" />
<p>比如要<code>读秒寄存器</code>则命令为 1000 0001，反之写为 1000 0000</p>
<h4 id="日历-时钟寄存器">日历/时钟寄存器</h4>
<p>DS1302 共有 12 个寄存器，其中有 7 个与日历、时钟相关，存放的数据为 <code>BCD码</code>形式。格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20103008.webp" style="zoom:33%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/b79c113e146e440089dd0c3cbd16aa90.webp" style="zoom:40%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/1c54c6ec19324dcb98fb22f6b8df66e2.webp" style="zoom:40%;" />
<p><strong>秒寄存器</strong>：<code>低四位为秒的个位，高的次三位为秒的十位</code>。最高位<code>CH</code> 为DS1302 的<code>运行标志</code>，当 <code>CH=0</code> 时，DS1302 <code>内部时钟运行</code>，反之 CH=1 时停止。DS1302 内部是 BCD 码， 而秒的十位最大是 5，所以 3 个二进制位就够了</p>
<p><strong>分寄存器</strong>：最高位未使用，剩下的 7 位中<code>高 3 位是分钟的十位，低 4 位是分钟的个位</code></p>
<p><strong>小时寄存器</strong>：<code>时寄存器</code>。<code>最高位为 12/24 小时的格式选择位</code>，该位为 <code>1</code> 时表示 <code>12 小时</code>格式，<code>0</code> 代表是 <code>24</code> 小时制。第六位固定是 0，当设置为 <code>12 小时</code>显示格式时，<code>第 5 位的 1 (高电平)表示下午（PM）</code>，<code>0 (低电平)表示上午（AM)</code>；而当设置为 <code>24 小时</code>格式时，<code>高 3 位代表了小时的十位，低 4 位代表的是小时的个位</code></p>
<p><strong>日寄存器</strong>：高 2 位固定是 0，bit5 和 bit4 是日期的十位，低 4 位是日期的个位</p>
<p><strong>月寄存器</strong>：高 3 位固定是 0，bit4 是月的十位，低 4 位是月的个位</p>
<p><strong>星期寄存器</strong>：高 5 位固定是 0，低 3 位代表了星期</p>
<p><strong>年寄存器</strong>：高 4 位代表了年的十位，低 4 位代表了年的个位。这里的 00～ 99 指的是 2000 年～2099 年</p>
<p><strong>写保护寄存器</strong>：当该寄存器最高位 <code>WP 为 1</code> 时，表示禁止给任何其它寄存器或者那 31 个字节的 RAM 写数据，DS1302<code>只读不写</code>，所以要在往 <code>DS1302 写数据之前确保 WP 为 0</code>。</p>
<p><strong>慢充电寄存器（涓细电流充电）寄存器</strong>：当 DS1302 掉电时，可以马上调用外部电源保护时间数据。该寄存器就是配置备用电源的充电选项的。其中高四位（4 个 TCS）只有在 1010 的情况下才能使用充电选项；低四位的情况与 DS1302 内部电路有关。</p>
<h3 id="DS1302-通信时序">DS1302 通信时序</h3>
<p>在<code>控制指令字输入后的下一个 SCLK 时钟的上升沿</code>时，<code>数据被写入 DS1302</code>，数据输入从<code>低位</code>（位 0）开始。同样，在紧跟 8 位的控制指令字后的<code>下一个 SCLK脉冲的下降沿读出 DS1302 的数据</code>，读出数据时从低位 0 位到高位 7。其时序图如下所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/febc7480c6534db7b37910623293d6c6.webp" style="zoom: 33%;" />
<p>上图就是 DS1302 的三个时序：<code>复位时序，单字节写时序，单字节读时序</code>；</p>
<p><strong>CE（RST</strong>）：<code>复位时序</code>，即在 RST 引脚产生一个正脉冲，在<code>整个读写器件，RST 要保持高电平</code>，一次字节<code>读写完毕</code>之后，要注意把 RST 返回<code>低电平</code>准备下次读写周期；</p>
<p><strong>单字节读时序</strong>：注意读之前还是要<code>先对寄存器写命令</code>，前八个为控制寄存器地址，从<code>最低位</code>开始写；可以看到，<code>写数据</code>是在 SCLK 的<code>上升沿</code>实现，而<code>读数据</code>在 SCLK 的<code>下降沿</code>实现。所以，在单字节读时序中，写命令的<code>第八个上升沿结束后</code>紧接着的<code>第八个下降沿</code>就将要<code>读</code>寄存器的<code>第一位数据</code>读到数据线上了！这个就是 DS1302 操作中最特别的地方。当然读出来的数据也是<code>最低位</code>开始。</p>
<p><strong>单字节写时序</strong>：两个字节的数据配合 <code>16 个上升沿</code>将数据写入即可。DS1302 的时序里， 单片机要预先写一个字节指令，指明要写入的寄存器的地址以及后续的操作是写操作，然后再写入一个字节的数据</p>
<blockquote>
<p><strong>程序注意事项</strong>：<br>
★要记得在操作 DS1302 之前关闭写保护(即<code>确保 WP 为 0</code>)；<br>
★注意用<code>延时</code>来降低单片机的速度以配合器件时序；<br>
★DS1302 读出来的数据是 <code>BCD 码</code>形式，要转换成我们习惯的 10 进制；<br>
★读取字节之前，将 IO 设置为输入口，读取完之后，要将其改回输出口；<br>
★在写程序的时候，建议实现开辟数组（内存空间）来集中放置 DS1302 的一系列数据，方便以后扩展键盘输入。</p>
</blockquote>
<h3 id="DS1302-的-BURST-模式">DS1302 的 BURST 模式</h3>
<p>DS1302 的突发模式。突发模式也分为 RAM 突发模式和时钟突发模式，只看和时钟相关的 clock burst mode</p>
<p>当写指令到DS1302 的时候，只要将要写的 <code>5 位地址全部写1</code>，即<code>读操作用0xBF， 写操作用 0xBE</code>，这样的指令送给 DS1302 之后，它就会自动识别出来是 burst 模式，<code>马上把所有的 8 个字节同时锁存到另外的 8 个字节的寄存器缓冲区内</code>，这样时钟继续走，而<code>读数据是从另外一个缓冲区内读取的</code>。同样的道理，如果用 burst 模式<code>写数据</code>，那么也是<code>先写到这个缓冲区</code>内，最终 DS1302 会把这个<code>缓冲区内的数据一次性送到它的时钟寄存器</code>内。 要注意的是，不管是读还是写，只要使用时钟的 <code>burst</code> 模式，则<code>必须一次性读写 8 个寄存器</code>，要把时钟的寄存器完全读出来或者完全写进去</p>
<h3 id="原理图-3">原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221017134845.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221017144535.jpg" style="zoom:80%;" />
<h3 id="程序-9">程序</h3>
<blockquote>
<h4 id="读取-DS1302-的当前时间，并显示在液晶屏上">读取 DS1302 的当前时间，并显示在液晶屏上</h4>
</blockquote>
<p>先将 2023 年 10 月 14 日星期六 16 点 36 分 30 秒这个时间写到 DS1302 内部，让 DS1302 正常运行，然后再不停的读取 DS1302 的当前时间，并显示在液晶屏上</p>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>DS1302.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//---DS1302写入和读取时分秒的地址命令---//</span></span><br><span class="line"><span class="comment">//---秒分时日月周年 最低位读写位;-------//</span></span><br><span class="line">u8 Write_addr[<span class="number">7</span>] = &#123;<span class="number">0x80</span>, <span class="number">0x82</span>, <span class="number">0x84</span>, <span class="number">0x86</span>, <span class="number">0x88</span>, <span class="number">0x8a</span>, <span class="number">0x8c</span>&#125;; <span class="comment">//数据可查看各类寄存器</span></span><br><span class="line">u8 Read_addr[<span class="number">7</span>] = &#123;<span class="number">0x81</span>, <span class="number">0x83</span>, <span class="number">0x85</span>, <span class="number">0x87</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x8d</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---DS1302时钟初始化2023年10月14日星期六16点36分30秒。---//</span></span><br><span class="line"><span class="comment">//---存储顺序是秒分时日月周年,存储格式是用BCD码---//</span></span><br><span class="line">u8 DS1302_Time[<span class="number">7</span>] = &#123;<span class="number">0x30</span>, <span class="number">0x36</span>, <span class="number">0x16</span>, <span class="number">0x14</span>, <span class="number">0x10</span>, <span class="number">0x06</span>, <span class="number">0x23</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名   : DS1302_Write_Byte</span></span><br><span class="line"><span class="comment">* 函数功能		 : DS1302写单字节</span></span><br><span class="line"><span class="comment">* 输    入   : addr：地址/命令</span></span><br><span class="line"><span class="comment">				        dat：数据</span></span><br><span class="line"><span class="comment">* 输    出   : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Write_Byte</span><span class="params">(u8 addr, u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line"></span><br><span class="line">    DS1302_CE = <span class="number">0</span>;    <span class="comment">//首先CE输出低电平</span></span><br><span class="line">    _nop_();          <span class="comment">//延时1us</span></span><br><span class="line">    DS1302_SCK = <span class="number">0</span>;   <span class="comment">//SCLK也输出低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    DS1302_CE = <span class="number">1</span>;    <span class="comment">//在读写过程，CE要保持高电平</span></span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)         <span class="comment">//循环8次，每次写1位，先写低位再写高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO = addr &amp; <span class="number">0x01</span>;     <span class="comment">//取出控制寄存器地址的最低位赋给DS1302的IO口</span></span><br><span class="line">        addr &gt;&gt;= <span class="number">1</span>;                  <span class="comment">//将控制寄存器地址的次低位移到最低位</span></span><br><span class="line">        DS1302_SCK = <span class="number">1</span>;              <span class="comment">//SCLK由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">        _nop_();                     <span class="comment">//延时1us</span></span><br><span class="line">        DS1302_SCK = <span class="number">0</span>;              <span class="comment">//SCLK先拉低，以便下一次上升沿</span></span><br><span class="line">        _nop_();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO = dat &amp; <span class="number">0x01</span>;      <span class="comment">//取出写入数据的最低位赋给DS1302的IO口</span></span><br><span class="line">        dat &gt;&gt;= <span class="number">1</span>;                   <span class="comment">//将数据的次低位移到最低位</span></span><br><span class="line">        DS1302_SCK = <span class="number">1</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">        DS1302_SCK = <span class="number">0</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE = <span class="number">0</span>;  <span class="comment">//CE拉低</span></span><br><span class="line">    _nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名   : DS1302_Read_Byte</span></span><br><span class="line"><span class="comment">* 函数功能		 : DS1302读单字节</span></span><br><span class="line"><span class="comment">* 输    入   : addr：地址/命令</span></span><br><span class="line"><span class="comment">* 输    出   : 读取的数据</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line">u8 <span class="title function_">DS1302_Read_Byte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 dat;          <span class="comment">//将接收到的数据存放到这个变量</span></span><br><span class="line"></span><br><span class="line">    DS1302_CE = <span class="number">0</span>;   <span class="comment">//首先CE输出低电平</span></span><br><span class="line">    _nop_();         <span class="comment">//延时1us</span></span><br><span class="line">    DS1302_SCK = <span class="number">0</span>;  <span class="comment">//SCLK也输出低电平</span></span><br><span class="line">    _nop_();</span><br><span class="line">    DS1302_CE = <span class="number">1</span>;   <span class="comment">//在读写过程，CE要保持高电平</span></span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)         <span class="comment">//循环8次，每次写1位，先写低位再写高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO = addr &amp; <span class="number">0x01</span>;     <span class="comment">//取出控制寄存器地址的最低位赋给DS1302的IO口</span></span><br><span class="line">        addr &gt;&gt;= <span class="number">1</span>;                  <span class="comment">//将控制寄存器地址的次低位移到最低位</span></span><br><span class="line">        DS1302_SCK = <span class="number">1</span>;              <span class="comment">//SCLK由低到高产生一个上升沿，从而写入数据</span></span><br><span class="line">        _nop_();                     <span class="comment">//延时1us</span></span><br><span class="line">        DS1302_SCK = <span class="number">0</span>;              <span class="comment">//SCLK先拉低，以便下一次上升沿</span></span><br><span class="line">        _nop_();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)        <span class="comment">//循环8次，每次写1位，先写低位再写高位</span></span><br><span class="line">    &#123;</span><br><span class="line">        dat &gt;&gt;= <span class="number">1</span>;                  <span class="comment">//将数据的次低位移到最低位</span></span><br><span class="line">        <span class="keyword">if</span>(DS1302_IO)               <span class="comment">//如果读取到的数据为1</span></span><br><span class="line">            dat |= <span class="number">0x80</span>;              <span class="comment">//dat相对应的值为1，否则不进入if语句，dat默认为0</span></span><br><span class="line">        DS1302_SCK = <span class="number">1</span>;</span><br><span class="line">        _nop_();                    <span class="comment">//延时1us</span></span><br><span class="line">        DS1302_SCK = <span class="number">0</span>;             <span class="comment">//SCLK由高到低产生一个下降沿，从而读入数据</span></span><br><span class="line">        _nop_();</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE = <span class="number">0</span>; <span class="comment">//CE拉低</span></span><br><span class="line">    _nop_();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dat;    <span class="comment">//将读取到的数据返回出去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名       : DS1302_Init</span></span><br><span class="line"><span class="comment">* 函数功能		     : DS1302初始化时间</span></span><br><span class="line"><span class="comment">* 输    入       : 无</span></span><br><span class="line"><span class="comment">* 输    出    	 : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    DS1302_Write_Byte(<span class="number">0x8E</span>, <span class="number">0x00</span>); <span class="comment">//关闭写保护(写保护寄存器的地址为0x8E,WP为其中的最高位，WP为0即为关闭写保护)</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_Write_Byte(Write_addr[i], DS1302_Time[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_Write_Byte(<span class="number">0x8E</span>, <span class="number">0x80</span>); <span class="comment">//打开写保护，以防止意外修改DS1302内部寄存器(WP为1即为打开写保护)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名       : DS1302_Read_Time</span></span><br><span class="line"><span class="comment">* 函数功能		     : DS1302读取时间</span></span><br><span class="line"><span class="comment">* 输    入       : 无</span></span><br><span class="line"><span class="comment">* 输    出    	 : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Read_Time</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_Time[i] = DS1302_Read_Byte(Read_addr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DS1302.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DS1302_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DS1302_H_</span></span><br><span class="line"></span><br><span class="line">sbit DS1302_CE = P1^<span class="number">7</span>;  <span class="comment">//复位管脚</span></span><br><span class="line">sbit DS1302_SCK = P3^<span class="number">5</span>; <span class="comment">//时钟管脚</span></span><br><span class="line">sbit DS1302_IO = P3^<span class="number">4</span>;  <span class="comment">//数据管脚</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Write_Byte</span><span class="params">(u8 addr,u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">DS1302_Read_Byte</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DS1302_Read_Time</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 DS1302_Time[<span class="number">7</span>]; <span class="comment">//使用extern之后外部文件就可以调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 str[<span class="number">12</span>]; <span class="comment">//字符串转换缓冲区</span></span><br><span class="line"></span><br><span class="line">    DS1302_Init();  <span class="comment">//初始化实时时钟</span></span><br><span class="line">    Lcd1602_Init(); <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_Read_Time(); <span class="comment">//读取 DS1302 当前时间</span></span><br><span class="line">        str[<span class="number">0</span>] = <span class="string">&#x27;2&#x27;</span>;       <span class="comment">//添加年份的高 2 位：20</span></span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;                                    <span class="comment">//因为BCD码用 4 位二进制数来表示 1 位十进制数</span></span><br><span class="line">        str[<span class="number">2</span>] = (DS1302_Time[<span class="number">6</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“年”高位数字转换为 ASCII 码(将高位右移四位移到低位)</span></span><br><span class="line">        str[<span class="number">3</span>] = (DS1302_Time[<span class="number">6</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//“年”低位数字转换为 ASCII 码</span></span><br><span class="line">        str[<span class="number">4</span>] = <span class="string">&#x27;-&#x27;</span>;  <span class="comment">//添加日期分隔符</span></span><br><span class="line">        str[<span class="number">5</span>] = (DS1302_Time[<span class="number">4</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“月”</span></span><br><span class="line">        str[<span class="number">6</span>] = (DS1302_Time[<span class="number">4</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[<span class="number">7</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        str[<span class="number">8</span>] = (DS1302_Time[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“日”</span></span><br><span class="line">        str[<span class="number">9</span>] = (DS1302_Time[<span class="number">3</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[<span class="number">10</span>] = <span class="string">&#x27;\0&#x27;</span>;                         <span class="comment">//添加结束符号</span></span><br><span class="line">        Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);                 <span class="comment">//显示到液晶的第一行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (DS1302_Time[<span class="number">5</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>; <span class="comment">//“星期”</span></span><br><span class="line">        str[<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        Lcd_ShowStr(<span class="number">11</span>, <span class="number">0</span>, <span class="string">&quot;week&quot;</span>);</span><br><span class="line">        Lcd_ShowStr(<span class="number">15</span>, <span class="number">0</span>, str);                <span class="comment">//显示到液晶的第一行</span></span><br><span class="line"></span><br><span class="line">        str[<span class="number">0</span>] = (DS1302_Time[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“时”</span></span><br><span class="line">        str[<span class="number">1</span>] = (DS1302_Time[<span class="number">2</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        str[<span class="number">3</span>] = (DS1302_Time[<span class="number">1</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“分”</span></span><br><span class="line">        str[<span class="number">4</span>] = (DS1302_Time[<span class="number">1</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[<span class="number">5</span>] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        str[<span class="number">6</span>] = (DS1302_Time[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>) + <span class="string">&#x27;0&#x27;</span>;   <span class="comment">//“秒”</span></span><br><span class="line">        str[<span class="number">7</span>] = (DS1302_Time[<span class="number">0</span>] &amp; <span class="number">0x0F</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str[<span class="number">8</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        Lcd_ShowStr(<span class="number">4</span>, <span class="number">1</span>, str);                 <span class="comment">//显示到液晶的第二行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DS1302.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="红外通信">红外通信</h2>
<h3 id="红外光的基本原理">红外光的基本原理</h3>
<p>红外线是<code>波长介于微波和可见光之间的电磁波</code>，波长在 760 纳米到 1 毫米之间，是波形比红光长的<code>非可见光</code>。自然界中的一切物体，只要它的温度高于绝对零度(-273)就存在分子和原子的无规则运动，其表面就会不停的辐射红外线。红外发射管很常用，在我们的遥控器上都可以看到，它类似发光二极管，但是它发射出来的是红外光，是<code>肉眼看不到</code>的。红外发射管发射红外线的强度会随着电流的增大而增强</p>
<p>常见的<code>红外发射管</code>如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20222233.webp" style="zoom: 33%;" />
<p>红外接收管内部是一个具有红外光敏感特征的 PN 节，属于<code>光敏二极管</code>，但是它<code>只对红外光有反应</code>。无红外光时，光敏管不导通，有红外光时，光敏管导通形成光电流，并且在<code>一定范围内电流随着红外光的强度的增强而增大</code>。典型的红外接收管如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-14%20222450.webp" style="zoom: 33%;" />
<h3 id="红外遥控的原理">红外遥控的原理</h3>
<p>红外遥控是一种<code>无线、非接触</code>控制技术，具有抗干扰能力强，信息传输可靠，功耗低，成本低，易实现等显著优点，被诸多电子设备特别是家用电器广泛采用，并越来越多的应用到计算机系统中。</p>
<p>红外遥控通信系统一般由<code>红外发射装置</code>和<code>红外接收设备</code>两大部分组成。</p>
<ol>
<li>红外发射装置</li>
</ol>
<p>红外发射装置，也就是通常我们说的红外遥控器是由<code>键盘电路、红外编码电路、电源电路和红外发射电路</code>组成。红外发射电路的主要元件为<code>红外发光二极管</code>。它实际上是一只特殊的发光二极管；由于其内部材料不同于普通发光二极管，因而在其两端施加一定电压时，它便发出的是红外线而不是可见光。目前大量的使用的红外发光二极管发出的红外线波长为 940nm 左右，外形与普通发光二极管相同。红外发光二极管有透明的，还有不透明的。红外遥控器和红外发光二极管如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/5bbbed137a7b469da6c0b670f3f39bac.webp" style="zoom:30%;" />
<p>通常红外遥控为了提高抗干扰性能和降低电源消耗，红外遥控器常用载波的方式传送<code>二进制编码</code>，常用的载波频率为 38kHz，这是由发射端所使用的 455kHz晶振来决定的。在发射端要对晶振进行整数分频，分频系数一般取 12，所以455kHz÷12≈37.9kHz≈38kHz。也有一些遥控系统采用 36kHz、 40 kHz、 56 kHz等，一般由发射端晶振的振荡频率来决定。所以，通常的红外遥控器是<code>将遥控信号（二进制脉冲码）调制在 38KHz 的载波上，经缓冲放大后送至红外发光二极管，转化为红外信号发射出去的</code>。</p>
<p>二进制脉冲码的形式有多种，其中最为常用的是 <code>NEC Protocol 的 PWM码</code>(脉冲宽度调制)和 Philips RC-5 Protocol 的<code>PPM 码</code>脉冲位置调制码，脉冲串之间的时间间隔来实现信号调制)。如果要开发红外接收设备，一定要知道红外遥控器的<code>编码方式和载波频率</code>。</p>
<ol start="2">
<li>红外接收设备</li>
</ol>
<p>红外接收设备是由<code>红外接收电路、红外解码、电源和应用电路</code>组成。红外遥控接收器的主要作用是<code>将遥控发射器发来的红外光信好转换成电信号</code>，再放大、限幅、检波、整形，形成遥控指令脉冲，输出至遥控微处理器。成品红外接收头的封装大致有两种：一种采用铁皮屏蔽；一种是塑料封装。均有三只引脚，即<code>电源正（ VDD）、电源负（GND）和数据输出（VOUT）</code>。其外观实物图如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/0441131bcfa54cc980f7154ab2e14330.webp" style="zoom:40%;" />
<p>正对接收头的凸起处看，从左至右，管脚依次是<code>1：VOUT，2：GND，3：VDD</code>。由于红外接收头在<code>没有脉冲</code>的时候为<code>高电平</code>，当<code>收到脉冲</code>的时候为<code>低电平</code>，所以可以通过<code>外部中断的下降沿</code>触发中断，在中断内通过计算<code>高电平时间</code>来判断接收到的数据是 <code>0 还是 1</code>。</p>
<h3 id="NEC协议红外遥控器">NEC协议红外遥控器</h3>
<p>其特征如下：</p>
<blockquote>
<p>1、8 位地址和 8 位指令长度；<br>
2、地址和命令 2 次传输（确保可靠性）<br>
3、PWM 脉冲位置调制，以发射红外载波的占空比代表“0”和“1”；<br>
4、载波频率为 38Khz；<br>
5、位时间为 1.125ms 或 2.25ms</p>
</blockquote>
<p>NEC 码的位定义：一个脉冲对应 560us 的连续载波，一个逻辑 1 传输需要2.25ms<code>（560us 脉冲+1680us 低电平）</code>，一个逻辑 0 的传输需要 1.125ms<code>（560us脉冲+560us 低电平）</code>。而红外接收头在收到脉冲的时候为低电平，在没有脉冲的时候为高电平，这样，我们在接收头端收到的信号为：<code>逻辑 1 应该是 560us 低+1680us 高，逻辑 0 应该是 560us 低+560us 高</code>。所以可以通过<code>计算高电平时间判断接收到的数据是 0 还是 1</code>。NEC 码位定义时序图如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f74c865950b74ebbb8c82974a8055cc8.webp" style="zoom:40%;" />
<p>NEC 遥控指令的数据格式为：<code>引导码、地址码、地址反码、控制码、控制反码</code>(引导码、用户码、用户码（或者用户码反码）、按键键码和 键码反码)。引导码由一个 9ms 的低电平和一个 4.5ms 的高电平组成，地址码、地址反码、控制码、控制反码均是 <code>8 位数据</code>格式。按照<code>低位在前，高位在后</code>的顺序发送。采用反码是为了<code>增加传输的可靠性</code>（可用于校验）。数据格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f09b2412150548bc8ab72ef50c196b71.webp" style="zoom:40%;" />
<p>NEC 码还规定了连发码(由 9ms 低电平+2.5m 高电平+0.56ms 低电平+97.94ms 高电平组成)，如果在一帧数据发送完毕之后，红外遥控器按键仍然没有放开，则发射连发码，可以通过统计连发码的次数来标记按键按下的长短或次数。</p>
<h3 id="原理图-4">原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221018195355.jpg" style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221018222808.jpg" style="zoom:67%;" />
<blockquote>
<p><strong>红外接收流程</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-15%20102459.webp" style="zoom:40%;" />
<h3 id="程序-10">程序</h3>
<blockquote>
<h4 id="数码管把遥控器的用户码和键码显示出来">数码管把遥控器的用户码和键码显示出来</h4>
</blockquote>
<p><code>smg.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gsmg[<span class="number">16</span>] = &#123;<span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>, <span class="number">0x82</span>, <span class="number">0xF8</span>,</span><br><span class="line">               <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>, <span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span></span><br><span class="line">              &#125;; <span class="comment">//数码管0-F</span></span><br><span class="line">u8 SMG_BUFF[<span class="number">6</span>] = &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;; <span class="comment">//数码管显示缓冲区，初值0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数码管动态扫描刷新函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 i;                <span class="comment">//动态扫描索引</span></span><br><span class="line">    LED_SMG_PORT = <span class="number">0xFF</span>;        <span class="comment">//关闭所有段选位，显示消隐</span></span><br><span class="line">    <span class="comment">//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推</span></span><br><span class="line">    P1 = (P1 &amp; <span class="number">0xF8</span>) | i;       <span class="comment">//位选索引值赋值到P1口低3位</span></span><br><span class="line">    LED_SMG_PORT = SMG_BUFF[i]; <span class="comment">//索引递增循环，遍历整个缓冲区，由于加了LED显示，点亮LED需要使能LEDS6,所以i小于6不是小于5</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="keyword">sizeof</span>(SMG_BUFF) - <span class="number">1</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>smg.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SMG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SMG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_SMG_PORT	P0  <span class="comment">//宏定义数码管端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Smg_Scan</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 gsmg[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">extern</span> u8 SMG_BUFF[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ired.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gired_data[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名         : ired_init</span></span><br><span class="line"><span class="comment">* 函数功能		   : 红外端口初始化函数，外部中断1配置</span></span><br><span class="line"><span class="comment">* 输    入         : 无</span></span><br><span class="line"><span class="comment">* 输    出         : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ired_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IRD = <span class="number">1</span>;       <span class="comment">//确保红外接收引脚被释放</span></span><br><span class="line">    TMOD &amp;= <span class="number">0x0F</span>;  <span class="comment">//清零 T1 的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x10</span>;  <span class="comment">//配置 T1 为模式 1</span></span><br><span class="line">    IT1 = <span class="number">1</span>;       <span class="comment">//设置 INT1 为下降沿触发</span></span><br><span class="line">    EA = <span class="number">1</span>;        <span class="comment">//开启总中断</span></span><br><span class="line">    EX1 = <span class="number">1</span>;       <span class="comment">//使能 INT1 中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired</span><span class="params">()</span> interrupt 2  <span class="comment">//外部中断1服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 time_cnt = <span class="number">0</span>;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    u8 ired_high_time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == IRD)</span><br><span class="line">    &#123;</span><br><span class="line">        time_cnt = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>((!IRD) &amp;&amp; (time_cnt)) <span class="comment">//等待引导信号9ms低电平结束，若超过10ms强制退出,若高电平则跳出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            Delay_10us(<span class="number">1</span>);  <span class="comment">//延时约10us 10us*1000 = 10000us --&gt; 10ms</span></span><br><span class="line">            time_cnt--;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == time_cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(IRD)  <span class="comment">//引导信号9ms低电平已过，进入4.5ms高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            time_cnt = <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">while</span>((IRD) &amp;&amp; (time_cnt)) <span class="comment">//等待引导信号4.5ms高电平结束，若超过5ms强制退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                Delay_10us(<span class="number">1</span>); <span class="comment">//延时约10us 10us*500 = 5000us --&gt; 5ms</span></span><br><span class="line">                time_cnt--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> == time_cnt) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环4次，读取4个字节数据(地址码、地址反码、控制码、控制反码)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) <span class="comment">//循环8次读取每位数据即一个字节</span></span><br><span class="line">                &#123;</span><br><span class="line">                    time_cnt = <span class="number">600</span>;</span><br><span class="line">                    <span class="keyword">while</span>((!IRD) &amp;&amp; (time_cnt)) <span class="comment">//等待数据1或0前面的0.56ms结束，若超过6ms强制退出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Delay_10us(<span class="number">1</span>); <span class="comment">//延时约10us 10us*600 = 6000us --&gt; 6ms</span></span><br><span class="line">                        time_cnt--;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="number">0</span> == time_cnt) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(IRD) <span class="comment">//等待数据1或0后面的高电平结束，若超过2ms强制退出</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Delay_10us(<span class="number">10</span>);  <span class="comment">//约0.1ms 100us*20 == 2000us --&gt; 2ms</span></span><br><span class="line">                        ired_high_time++;</span><br><span class="line">                        <span class="keyword">if</span>(ired_high_time &gt; <span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gired_data[i] &gt;&gt;= <span class="number">1</span>;     <span class="comment">//数据是先传低位再传高位，所以接收到的低位数据需要往右移一位</span></span><br><span class="line">                    <span class="keyword">if</span>(ired_high_time &gt;= <span class="number">8</span>)  <span class="comment">//如果高电平时间大于0.8ms，数据则为1，否则为0</span></span><br><span class="line">                        gired_data[i] |= <span class="number">0x80</span>; <span class="comment">//如果高电平时间大于0.8ms则接收到的数据为1，或上0x80相当于取出最高位的数据</span></span><br><span class="line">                    <span class="comment">//接着向右移动一位</span></span><br><span class="line">                    ired_high_time = <span class="number">0</span>;      <span class="comment">//重新清零，等待下一次计算时间</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gired_data[<span class="number">2</span>] != ~gired_data[<span class="number">3</span>]) <span class="comment">//校验控制码与反码，错误则返回</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">                gired_data[i] = <span class="number">0</span>; <span class="comment">//接收到的数据清0</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ired.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IRED_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IRED_H_</span></span><br><span class="line"></span><br><span class="line">sbit IRD = P3^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Ired_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 gired_data[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Delay.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数名:  Delay_10us</span></span><br><span class="line"><span class="comment">  * @参数1 : 需要延时多少微秒</span></span><br><span class="line"><span class="comment">  * @返回值: 无</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_10us</span><span class="params">(u16 ten_us)</span> <span class="comment">//当传入ten_us==1时，大约延时10us</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delay.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DELAY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DELAY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_10us</span><span class="params">(u16 ten_us)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit ADDR3 = P1 ^ <span class="number">3</span>;</span><br><span class="line">sbit ENLED = P1 ^ <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ENLED = <span class="number">0</span>;     <span class="comment">//使能选择数码管</span></span><br><span class="line">    ADDR3 = <span class="number">1</span>;</span><br><span class="line">    Time0_Init(<span class="number">1</span>); <span class="comment">//配置 T0 定时 1ms</span></span><br><span class="line">    Ired_Init();   <span class="comment">//初始化红外功能</span></span><br><span class="line">    PT0 = <span class="number">1</span>;       <span class="comment">//配置 T0 中断为高优先级，启用本行可消除接收时的闪烁</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SMG_BUFF[<span class="number">5</span>] = gsmg[gired_data[<span class="number">0</span>] &gt;&gt; <span class="number">4</span>];   <span class="comment">//用户码显示</span></span><br><span class="line">        SMG_BUFF[<span class="number">4</span>] = gsmg[gired_data[<span class="number">0</span>] &amp; <span class="number">0x0F</span>];</span><br><span class="line">        SMG_BUFF[<span class="number">1</span>] = gsmg[gired_data[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>];   <span class="comment">//键码显示</span></span><br><span class="line">        SMG_BUFF[<span class="number">0</span>] = gsmg[gired_data[<span class="number">2</span>] &amp; <span class="number">0x0F</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行数码管扫描显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Smg_Scan();   <span class="comment">//数码管扫描显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ired.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>问：当我们按下遥控器按键的时候，数码管显示的数字会闪烁，这是什么原因呢？</p>
<p>单片机的程序都是顺序执行的，一旦我们按下遥控器按键，单片机就会进入遥控器解码的中断程序内，而这个程序执行的时间又比较长，要几十个毫秒，而如果数码管动态刷新间隔超过10ms后就会感觉到闪烁，因此这个闪烁是由于程序执行红外解码时，延误了数码管动态刷新造成的，所以解决方法就是设置定时器0中断为高优先级，因为定时器中断执行时间也就几十个us不会对解码有很大的影响</p>
<h2 id="温度传感器-DS18B20">温度传感器 DS18B20</h2>
<p>DS18B20 是<code>温度传感器</code>，单片机可以通过 1-Wire 协议与 DS18B20 进行通信，最终将温度读出。1-Wire 总线的硬件接口很简单，只需要把 DS18B20 的数据引脚和单片机的一个 IO 口接上就可以了</p>
<p><strong>DS18B20 内部结构如下图所示：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/7801fb03019c4b3abfadd7c013f6ced0.webp" style="zoom:40%;" />
<p>ROM 中的 64 位序列号是出厂前被光刻好的，它可以看作是该 DS18B20 的地址序列号。光刻 ROM 的作用是使每一个 DS18B20 都各不相同，这样就可以实现<code>一根总线上挂接多个 DS18B20</code> 的目的。</p>
<p>DS18B20 温度传感器的内部存储器包括一个<code>高速的暂存器 RAM</code> 和一个<code>非易失性的可电擦除的 EEPROM</code>,后者存放<code>高温度和低温度触发器 TH、TL 和配置寄存器</code>。</p>
<p>配置寄存器是配置不同的位数来确定温度和数字的转化，配置寄存器结构如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/aabf06109b264bdb8a8d4a397a6f08c5.webp" style="zoom: 67%;" />
<p>低五位一直都是&quot;<code>1</code>&quot;，<code>TM</code> 是<code>测试模式位</code>，用于设置 DS18B20 在<code>工作模式</code>还是在<code>测试模式</code>。在 DS18B20 出厂时该位被设置为 <code>0</code>，因此 DS18B20 在<code>工作模式</code>。<code>R1 和R0</code> 用来设置 DS18B20 的<code>精度</code>（分辨率），可设置为 9，10，11 或 12 位，对应的分辨率温度是 0.5℃，0.25℃，0.125℃和 0.0625℃。R0 和 R1 配置如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/790abd7bc4e744ec93bb48ff222ca085.webp" style="zoom:50%;" />
<p>在初始状态下默认的精度是 12 位，即 <code>R0=1、R1=1</code>。高速暂存存储器由 9 个字节组成，其分配如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/3b1cf2a47b0b404c8153fb5a9f79d879.webp" style="zoom:40%;" />
<p>当温度转换命令（44H）发布后，经转换所得的温度值以<code>二字节补码</code>形式存放在<code>高速暂存存储器的第 0 和第 1 个字节</code>。存储的两个字节，高字节的前 5 位是符号位<code>S</code>，单片机可通过单线接口读到该数据，读取时<code>低位在前，高位在后</code>，数据格式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/e1d8a0c846f84b318607511826ea152b.webp" style="zoom:40%;" />
<p>如果测得的温度<code>大于 0</code>，这 <code>5 位符号位S为‘ 0’</code>，只要将测到的数值<code>乘以 0.0625</code>（默认精度是 12 位）即可得到<code>实际温度</code>；如果<code>温度小于 0</code>，这 <code>5 位符号位S为‘ 1’</code>，测到的数值需要<code>取反加 1 再乘以 0.0625</code> 即可得到<code>实际温度</code>。温度与数据对应关系如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/84e4f2fe1bb440838683f8b2f6bbbe20.webp" style="zoom:35%;" />
<p>比如要计算 <code>+85 度</code>，数据输出<code>十六进制是 0X0550</code>，因为要计算的<code>温度大于0</code>，所以高字节的高 5位为 0，<code>十六进制0X0550 对应的二进制为 0000 0101 0101 0000</code>，<code>该二进制对应的十进制为 1360</code>，将这个值<code>乘以 12 位精度 0.0625</code>，所以可以得到+85 度。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/6e3f530e87d349ccb34f7253205dbc38.webp" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/6dba2f7009284d67a219b577f0d4643b.webp" style="zoom: 130%;" />
<p>又比如要计算 <code>-0.5 度</code>，数据输出<code>十六进制是 FFF8</code>，因为要计算的<code>温度小于0</code>，所以高字节的高 5位为 1，<code>十六进制 FFF8 对应的二进制为 1111 1111 1111 1000</code>，先对这个二进制数进行<code>取反</code>为 0000 0000 0000 0111，再进行<code>加 1</code> ，则对应的<code>十六进制为0x08</code>， <code>十六进制 0x08 对应的十进制为 8</code>，将这个值<code>乘以 12 位精度 0.0625</code>，算出来的值为 0.5，因为该温度小于 0 ，所以可以得到 -0.5 度。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/1145b1251ab54ca5b414eaaa6140f927.webp" style="zoom:150%;" />
<h3 id="读取温度数据">读取温度数据</h3>
<p>由于 DS18B20是<code>单总线器件</code>，所有的单总线器件都要求采用严格的信号时序，以保数据的完整性。DS18B20 时序包括如下几种：<code>初始化时序、写（0 和 1）时序、 读（0和 1）时序</code>。 DS18B20 发送所有的命令和数据都是<code>字节的低位在前</code>。这里我们简单介绍这几个信号的时序：</p>
<h4 id="初始化时序">初始化时序</h4>
<p>单总线上的所有通信都是<code>以初始化序列开始</code>。<code>主机输出低电平</code>，保持低电平时间<code>至少 480us</code>（该时间的时间范围可以从 480 到 960 微秒），以产生复位脉冲。接着<code>主机释放总线</code>，外部的上拉电阻将单总线拉高，<code>延时 15～60 us</code>，并<code>进入接收模式</code>。接着 DS18B20 <code>拉低总线 60~240 us</code>，以产生<code>低电平应答脉冲</code>，若为低电平，还要做延时，其延时的时间从外部上拉电阻将单总线拉高算起最少要480 微妙。初始化时序图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/2f018d03e5614bfab1f7f1623d10997e.webp" style="zoom: 30%;" />
<h4 id="写时序">写时序</h4>
<p>写时序包括<code>写 0 时序和写 1 时序</code>。所有写时序至少需要 60us，且在 2 次独立的写时序之间至少需要 1us 的恢复时间，两种写时序均<code>起始于主机拉低总线</code>。写 <code>1 时序</code>：主机输出低电平，<code>延时 2us</code>，然后释放总线，<code>延时 60us</code>。写 <code>0时序</code>：主机输出低电平，<code>延时 60us</code>，然后释放总线，<code>延时 2us</code>。写时序图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/644c6fe2fc5841028f1d6bd3c60ea47f.webp" style="zoom: 38%;" />
<h4 id="读时序">读时序</h4>
<p>单总线器件仅<code>在主机发出读时序</code>时，才<code>向主机传输数据</code>，所以，<code>在主机发出读数据命令后，必须马上产生读时序，以便从机能够传输数据</code>。所有读时序至少需要 60us，且在 2 次独立的读时序之间至少需要 1us 的恢复时间。每个<code>读时序都由主机发起</code>，至少拉低总线 1us。<code>主机在读时序期间必须释放总线</code>，并且在时序起始后的 15us 之内采样总线状态。读时序图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/f12a0bf9e5454952b91aa75e7c586751.png" style="zoom:41%;" />
<p>典型的读时序过程为：主机输出低电平延时 2us，然后主机转入输入模式延时 2us，然后读取单总线当前的电平，然后延时 50us。</p>
<p>DS18B20 的典型温度读取过程为：<code>复位→发 SKIP ROM 命令（0XCC）→ 发开始转换命令（0X44）(启动温度转换) → 延时 → 复位 → 发送 SKIP ROM 命令（0XCC）→ 发读存储器命令（0XBE）→ 连续读出两个字节数据(即温度) → 结束</code></p>
<h3 id="原理图-5">原理图</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221019100701.jpg" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221019114333.jpg"  />
<h3 id="程序-11">程序</h3>
<blockquote>
<h4 id="将读到的温度值显示在-1602-液晶上，并且保留一位小数位"><strong>将读到的温度值显示在 1602 液晶上，并且保留一位小数位</strong></h4>
</blockquote>
<p><code>DS18B20.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位总线，获取存在脉冲，以启动一次读写操作 */</span></span><br><span class="line">bit <span class="title function_">Get_18B20Ack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack;</span><br><span class="line"></span><br><span class="line">    EA = <span class="number">0</span>;              <span class="comment">//禁止总中断</span></span><br><span class="line">    DS18B20_IO = <span class="number">0</span>;      <span class="comment">//产生 500us 复位脉冲</span></span><br><span class="line">    Delay_10us(<span class="number">50</span>);</span><br><span class="line">    DS18B20_IO = <span class="number">1</span>;</span><br><span class="line">    Delay_10us(<span class="number">6</span>);       <span class="comment">//延时 60us</span></span><br><span class="line">    ack = DS18B20_IO;    <span class="comment">//读取存在脉冲</span></span><br><span class="line">    <span class="keyword">while</span>(!DS18B20_IO);  <span class="comment">//等待存在脉冲结束</span></span><br><span class="line">    EA = <span class="number">1</span>;              <span class="comment">//重新使能总中断</span></span><br><span class="line">    <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 DS18B20 写入一个字节，dat-待写入字节 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DS18B20_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line"></span><br><span class="line">    EA = <span class="number">0</span>;                 <span class="comment">//禁止总中断</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS18B20_IO = <span class="number">0</span>;       <span class="comment">//产生 2us 低电平脉冲</span></span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x01</span>) &gt; <span class="number">0</span>)  <span class="comment">//dat最低位如果为大于0（等于1）</span></span><br><span class="line">            DS18B20_IO = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            DS18B20_IO = <span class="number">0</span>;</span><br><span class="line">        dat &gt;&gt;= <span class="number">1</span>;           <span class="comment">//右移一位</span></span><br><span class="line">        Delay_10us(<span class="number">6</span>);       <span class="comment">//延时 60us</span></span><br><span class="line">        DS18B20_IO = <span class="number">1</span>;      <span class="comment">//拉高通信引脚</span></span><br><span class="line">    &#125;</span><br><span class="line">    EA = <span class="number">1</span>;                <span class="comment">//重新使能总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 DS18B20 读取一个字节，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">DS18B20_Read</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u8 dat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    EA = <span class="number">0</span>;                 <span class="comment">//禁止总中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS18B20_IO = <span class="number">0</span>;       <span class="comment">//产生 2us 低电平脉冲</span></span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        DS18B20_IO = <span class="number">1</span>;       <span class="comment">//结束低电平脉冲，等待 18B20 输出数据</span></span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();     <span class="comment">//延时 2us</span></span><br><span class="line">        dat &gt;&gt;= <span class="number">1</span>;            <span class="comment">//右移一位</span></span><br><span class="line">        <span class="keyword">if</span>(DS18B20_IO)        <span class="comment">//如果通信引脚上的值为1</span></span><br><span class="line">            dat |= <span class="number">0x80</span>;        <span class="comment">//dat最高位赋为1</span></span><br><span class="line">        Delay_10us(<span class="number">5</span>);        <span class="comment">//再延时 50us</span></span><br><span class="line">    &#125;</span><br><span class="line">    EA = <span class="number">1</span>;                 <span class="comment">//重新使能总中断</span></span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动一次 18B20 温度转换，返回值-表示是否启动成功 */</span></span><br><span class="line">bit <span class="title function_">DS18B20_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack;</span><br><span class="line">    ack = Get_18B20Ack();   <span class="comment">//执行总线复位，并获取 18B20 应答</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ack)            <span class="comment">//如 18B20 正确应答，则启动一次转换</span></span><br><span class="line">    &#123;</span><br><span class="line">        DS18B20_Write(<span class="number">0xCC</span>);  <span class="comment">//跳过 ROM 操作</span></span><br><span class="line">        DS18B20_Write(<span class="number">0x44</span>);  <span class="comment">//启动一次温度转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~ack;            <span class="comment">//ack==0 表示操作成功，所以返回值对其取反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取 DS18B20 转换的温度值，返回值-表示是否读取成功 */</span></span><br><span class="line">bit <span class="title function_">DS18B20_Read_Temp</span><span class="params">(<span class="type">int</span> *temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack;</span><br><span class="line">    u8 LSB, MSB;                        <span class="comment">//16bit 温度值的低字节和高字节</span></span><br><span class="line">    ack = Get_18B20Ack();               <span class="comment">//执行总线复位，并获取 18B20 应答</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ack)                        <span class="comment">//如 18B20 正确应答，则读取温度值</span></span><br><span class="line">    &#123;</span><br><span class="line">        DS18B20_Write(<span class="number">0xCC</span>);              <span class="comment">//跳过 ROM 操作</span></span><br><span class="line">        DS18B20_Write(<span class="number">0xBE</span>);              <span class="comment">//发送读命令</span></span><br><span class="line">        LSB = DS18B20_Read();             <span class="comment">//读温度值的低字节</span></span><br><span class="line">        MSB = DS18B20_Read();             <span class="comment">//读温度值的高字节</span></span><br><span class="line">        *temp = ((<span class="type">int</span>)MSB &lt;&lt; <span class="number">8</span>) + LSB;    <span class="comment">//合成为 16bit 整型数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ~ack;                        <span class="comment">//ack==0 表示操作应答，所以返回值为其取反值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DS18B20.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DS18B20_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DS18B20_H_</span></span><br><span class="line"></span><br><span class="line">sbit DS18B20_IO = P3^<span class="number">2</span>; <span class="comment">//DS18B20 通信引脚</span></span><br><span class="line"></span><br><span class="line">bit <span class="title function_">Get_18B20Ack</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DS18B20_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">DS18B20_Read</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">DS18B20_Start</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">DS18B20_Read_Temp</span><span class="params">(<span class="type">int</span> *temp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>Delay.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------------------------------- begin  ------------------------------ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @函数名:  Delay_10us</span></span><br><span class="line"><span class="comment">  * @参数1 : 需要延时多少微秒</span></span><br><span class="line"><span class="comment">  * @返回值: 无</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">/* -------------------------------- end -------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_10us</span><span class="params">(u16 ten_us)</span> <span class="comment">//当传入ten_us==1时，大约延时10us</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delay.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">bit flag1s = <span class="number">0</span>; <span class="comment">//1s 定时标志</span></span><br><span class="line">u8 <span class="title function_">IntToString</span><span class="params">(u8 *str, <span class="type">int</span> dat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bit res;        <span class="comment">//接收应答</span></span><br><span class="line">    <span class="type">int</span> temp;       <span class="comment">//读取到的当前温度值</span></span><br><span class="line">    <span class="type">int</span> intT, decT; <span class="comment">//温度值的整数和小数部分</span></span><br><span class="line">    u8 len;</span><br><span class="line">    u8 str[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">    Time0_Init(<span class="number">10</span>);  <span class="comment">//T0 定时 10ms</span></span><br><span class="line">    DS18B20_Start(); <span class="comment">//启动 DS18B20</span></span><br><span class="line">    Lcd1602_Init();  <span class="comment">//初始化液晶</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag1s)     <span class="comment">//每秒更新一次温度</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag1s = <span class="number">0</span>;</span><br><span class="line">            res = DS18B20_Read_Temp(&amp;temp); <span class="comment">//读取当前温度</span></span><br><span class="line">            <span class="keyword">if</span>(res)                         <span class="comment">//读取成功时，刷新当前温度显示</span></span><br><span class="line">            &#123;</span><br><span class="line">                intT = temp &gt;&gt; <span class="number">4</span>;             <span class="comment">//分离出温度值整数部分</span></span><br><span class="line">                decT = temp &amp; <span class="number">0x0F</span>;           <span class="comment">//分离出温度值小数部分</span></span><br><span class="line">                len = IntToString(str, intT); <span class="comment">//整数部分转换为字符串</span></span><br><span class="line">                str[len++] = <span class="string">&#x27;.&#x27;</span>;             <span class="comment">//添加小数点</span></span><br><span class="line">                decT = (decT * <span class="number">10</span>) / <span class="number">16</span>;      <span class="comment">//二进制的小数部分转换为 1 位十进制位</span></span><br><span class="line">                str[len++] = decT + <span class="string">&#x27;0&#x27;</span>;      <span class="comment">//十进制小数位再转换为 ASCII 字符</span></span><br><span class="line">                <span class="keyword">while</span>(len &lt; <span class="number">6</span>)                <span class="comment">//用空格补齐到 6 个字符长度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str[len++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                str[len] = <span class="string">&#x27;\0&#x27;</span>;              <span class="comment">//添加字符串结束符</span></span><br><span class="line">                Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, str);       <span class="comment">//显示到液晶屏上</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">//读取失败时，提示错误信息</span></span><br><span class="line">            &#123;</span><br><span class="line">                Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            DS18B20_Start();                <span class="comment">//重新启动下一次转换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整型数转换为字符串，str-字符串指针，dat-待转换数，返回值-字符串长度 */</span></span><br><span class="line">u8 <span class="title function_">IntToString</span><span class="params">(u8 *str, <span class="type">int</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">    u8 len = <span class="number">0</span>;</span><br><span class="line">    u8 buf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span>(dat &lt; <span class="number">0</span>)                  <span class="comment">//如果为负数，首先取绝对值，并在指针上添加负号</span></span><br><span class="line">    &#123;</span><br><span class="line">        dat = -dat;</span><br><span class="line">        *str++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>                          <span class="comment">//先转换为低位在前的十进制数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        buf[i++] = dat % <span class="number">10</span>;</span><br><span class="line">        dat /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(dat &gt; <span class="number">0</span>);</span><br><span class="line">    len += i;                   <span class="comment">//i 最后的值就是有效字符的个数</span></span><br><span class="line">    <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>)              <span class="comment">//将数组值转换为 ASCII 码反向拷贝到接收指针上</span></span><br><span class="line">    &#123;</span><br><span class="line">        *str++ = buf[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *str = <span class="string">&#x27;\0&#x27;</span>;                <span class="comment">//添加字符串结束符</span></span><br><span class="line">    <span class="keyword">return</span> len;                 <span class="comment">//返回字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行数码管扫描显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 count = <span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;      <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">100</span>) <span class="comment">//定时 1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag1s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DS18B20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="模数转换-A-D-与数模转换-D-A">模数转换 A/D 与数模转换 D/A</h2>
<h3 id="A-D-和-D-A-的基本概念">A/D 和 D/A 的基本概念</h3>
<p>A/D 是<code>模拟量到数字量</code>的转换，依靠的是模数转换器(<code>ADC</code>)。D/A 是<code>数字量到模拟量</code>的转换，依靠的是数模转换器(<code>DAC</code>)</p>
<p>模拟量：指<code>变量在一定范围内连续变化的量</code>，也就是在一定范围内可以取任意值，总之，任何两个数字之间都有无限个中间值，所以称之为<code>连续变化的量</code>，也就是<code>模拟量</code></p>
<p>ADC 起到把<code>连续的信号用离散的数字表达</code>出来的作用</p>
<p>我们往杯子里倒水，水位会随着倒入的水量的多少而变化。现在就用这个米尺来测量我们杯子里的水位的高度。水位变化是连续的，而我们只能通过尺子上的刻度来读取水位的高度，获取我们想得到的水位的数字量信息。这个过程，就可以简单理解为我们电路中的 <code>ADC 采样</code></p>
<h3 id="A-D-的主要指标">A/D 的主要指标</h3>
<p>AD 的种类很多，分为<code>积分型、逐次逼近型、并行/串行比较型、Σ-Δ型</code>等多种类型</p>
<ol>
<li>ADC 的位数</li>
</ol>
<p>一个<code> n 位的 ADC</code> 表示这个 ADC 共有 <code>2 的 n 次方</code>个<code>刻度</code>。<code>8 位的 ADC</code>，输出的是从 0 ～ 255 一共 256 个数字量，也就是 <code>2 的 8 次方个数据刻度</code></p>
<ol start="2">
<li>基准源</li>
</ol>
<p>基准源，也叫<code>基准电压</code>，是 ADC 的一个<code>重要指标</code>，要想把输入 ADC 的信号测量准确， 那么基准源首先要准，<code>基准源的偏差会直接导致转换结果的偏差</code>。假如我们的基准源应该是 5.10 V，但是实际上提供的却是 4.5 V， 这样误把 4.5 V 当成了 5.10 V 来处理的话，偏差会比较大</p>
<ol start="3">
<li>分辨率</li>
</ol>
<p>分辨率是<code>数字量变化一个最小刻度时，模拟信号的变化量</code>，定义为满刻度量程与 2^n -1 的 比值。假定 5.10V 的电压系统，使用 8 位的 ADC 进行测量，那么相当于 0～255 一共 256 个 刻度把 5.10V 平均分成了 255 份，那么<code>分辨率</code>就是 <code>5.10 / 255 = 0.02V</code></p>
<ol start="4">
<li>INL（积分非线性度）和 DNL（差分非线性度）</li>
</ol>
<p>分辨率是用来描述<code>刻度划分</code>的，而<code>精度</code>是用来描述<code>准确程度</code>的</p>
<p>和 ADC 精度关系重大的两个指标是 <code>INL</code> 和 <code>DNL</code></p>
<p>INL 指的是 <code>ADC 器件在所有的数值上对应的模拟值和真实值之间误差最大的那一个点的误差值</code>，是 <code>ADC 最重要的一个精度指标</code>，单位是 <code>LSB</code>。LSB 是<code>最低有效位</code>的意思，那么它实际上对应的就是 <code>ADC 的分辨率</code>。一个基准为 5.10V 的 8 位 ADC， 它的分辨率就是 0.02V (5.10 / 255 = 0.02V)，用它去测量一个<code>电压信号</code>，得到的结果是 <code>100</code>，就表示它测到的<code>电压值</code>是 <code>100*0.02V=2V</code>，假定它的 INL 是 1 LSB，就表示这个电压信号真实的准确值是在 <code>1.98V～2.02V</code> 之间的，按理想情况对应得到的数字应该是 <code>99～101</code>，<code>测量误差是一个最低有效位</code>，即 1LSB</p>
<p>DNL 表示的是 <code>ADC 相邻两个刻度之间最大的差异</code>，单位也是 <code>LSB</code>。一把分辨率是 1 毫米的尺子，相邻的刻度之间并不都刚好是 1 毫米，而总是会存在或大或小的误差。同理，<code>一个 ADC 的两个刻度线之间也不总是准确的等于分辨率，也是存在误差</code>，这个<code>误差就是 DNL</code>。 一个基准为 5.10V 的 8 位 ADC，假定它的 DNL 是 0.5 LSB，那么当它的转换结果从 100 增加 到 101 时，理想情况下实际电压应该增加 0.02V，但 DNL 为 0.5LSB 的情况下实际电压的增加值是在 0.01～0.03V 之间。 DNL 并非一定小于 1LSB，很多时候它会等于或大于 1LSB，这就相当于是一定程度上的刻度紊乱，当实际电压保持不变时，ADC 得出的结果可能会在几个数值之间跳动，很大程度上就是由于这个原因</p>
<ol start="5">
<li>转换速率</li>
</ol>
<p>转换速率，是指 <code>ADC 每秒能进行采样转换的最大次数</code>，单位是 sps（或 s/s、sa/s），它<code>与 ADC 完成一次从模拟到数字的转换所需要的时间互为倒数关系</code>。ADC 的种类比较多，其中<code>积分型</code>的 ADC 转换时间是<code>毫秒级</code>的，属于<code>低速 ADC</code>；<code>逐次逼近型</code> ADC 转换时间是<code>微秒级</code>的，属于<code>中速 ADC</code>；<code>并行/串行</code>的 ADC 的转换时间可达到<code>纳秒级</code>，属于<code>高速 ADC</code></p>
<h3 id="PCF8591-的硬件接口">PCF8591 的硬件接口</h3>
<p>PCF8591 是一个<code>单电源低功耗</code>的 <code>8 位 CMOS 数据采集器件</code>，具有 <code>4 路模拟输入，1 路模拟输出和一个串行 I2C 总线</code>接口用来与单片机通信。与<code>24C02</code> 类似，3 个地址引脚 A0、A1、A2 用于编程硬件地址，允许最多 <code>8 个器件</code>连接到 I2C 总线而不需要额外的片选电路。<code>器件的地址、控制以及数据都是通过 I2C 总线来传输</code></p>
<blockquote>
<p><strong>PCF8591 的原理图</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221020151039.jpg" style="zoom: 80%;" />
<p>引脚 <code>1、2、3、4</code> 是 <code>4 路模拟输入</code>，引脚 <code>5、6、7</code> 是 <code>I2C 总线的硬件地址</code>，<code>8 脚</code>是<code>数字地 GND</code>，<code>9 脚和 10 脚</code>是 <code>I2C 总线的 SDA 和 SCL</code>。<code>12 脚</code>是<code>时钟选择</code>引脚，如果接<code>高电平</code>表示用<code>外部时钟输入</code>，接<code>低电平</code>则用<code>内部时钟</code>，我们板子上用的是<code>内部时钟</code>，因此 <code>12 脚</code>直接接 <code>GND</code>，同时 <code>11 脚悬空</code>。<code>13 脚</code>是<code>模拟地 AGND</code>，在实际开发中，如果有比较复杂的模拟电路， AGND 部分在布局布线上要特别处理，而且和 GND 的连接也有多种方式，板子上没有复杂的模拟部分电路，所以把 <code>AGND 和 GND 接到一起</code>。<code>14 脚是基准源，15 脚是 DAC 的模拟输出，16 脚是供电电源 VCC</code></p>
<p>PCF8591 的 <code>ADC 是逐次逼近型</code>的，转换速率算是中速，但是它的速度瓶颈在 I2C 通信 上。由于 I 2C 通信速度较慢，所以最终的 PCF8591 的转换速度，直接取决于 I2C 的通信速率。 由于 I2C 速度的限制，所以 PCF8591 得算是个<code>低速的 AD 和 DA 的集成</code>，主要应用在一些<code>转换速度要求不高，希望成本较低</code>的场合</p>
<p>Vref <code>基准电压</code>的提供有两种方法。一是采用简易的原则，<code>直接接到 VCC 上去</code>，但是由于 VCC 会受到整个线路的用电功耗情况影响，一来不是准确的 5V，实测大多在 4.8V 左右， 二来随着整个系统负载情况的变化会产生波动，所以只能用在<code>简易的、对精度要求不高</code>的场合。方法二是<code>使用专门的基准电压器件</code>，比如 <code>TL43</code>1，它可以提供一个精度很高的 <code>2.5V 的电压基准</code>，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-15%20213700.webp" style="zoom: 50%;" />
<p>图中 <code>J17 是双排插针</code>，可以根据自己的需求选择跳线帽短接还是使用杜邦线连接其它外部电路，二者都是可以的。在这个地方，直接把 <code>J17 的 3 脚和 4 脚用跳线帽短路</code>起来，那么 <code>Vref 的基准源就是 2.5V</code> 了。分别把 5 和 6、7 和 8、9 和 10、11 和 12 用跳线帽短接起来的话，那么 <code>AIN0 实测的就是电位器的分压值</code>，<code>AIN1 和 AIN2 测的是 GND 的值，AIN3 测的是+5V 的值</code>。这里需要注意的是，AIN3 虽然测的是+5V 的值，但是对于 AD 来说，只要<code>输入信号超过 Vref 基准源</code>，它得到的始终都是<code>最大值</code>，即 255，也就是说它实际上<code>无法测量超过其 Vref 的电压信号</code>的。需要注意的是，所有<code>输入信号的电压值都不能超过 VCC，即+5V</code>，否则可能会损坏 ADC 芯片</p>
<h3 id="PCF8591-的软件编程">PCF8591 的软件编程</h3>
<p>PCF8591 的<code>通信接口是 I2C</code>，那么编程肯定是要符合这个协议的。单片机对 PCF8591 进行<code>初始化</code>，一共发送<code>三个字节</code>即可。<code>第一个字节</code>，和 EEPROM 类似，是<code>器件地址字节</code>，其中 <code>7 位代表地址，1 位代表读写方向</code>。<code>地址高 4 位固定是 0b1001，低三位是 A2，A1，A0</code>， 这三位电路上都接了 <code>GND</code>，因此也就是 <code>0b000</code>，如图 所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-15%20214435.webp" style="zoom:50%;" />
<p>发送到 <code>PCF8591</code> 的<code>第二个字节</code>将<code>被存储在控制寄存器</code>，用于<code>控制 PCF8591 的功能</code>。其中<code>第 3 位和第 7 位是固定的 0</code>，另外 6 位各自有各自的作用，如图所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-15%20214642.webp" style="zoom:50%;" />
<p>控制字节的<code>第 6 位</code>是 <code>DA 使能位</code>，这一位置 <code>1 表示 DA 输出引脚使能，会产生模拟电压输出功能</code>。<code>第 4 位和第 5 位</code>可以实现把 <code>PCF8591 的 4 路模拟输入</code>配置成<code>单端模式和差分模式</code>，如图所示：</p>
<p>● 第  <code>3、7 </code>位 <code>固定为 0 </code><br>
● 控制字节的 <code>第 6 位是 DA 使能位 </code>，这一位置  <code>1 表示 DA 输出引脚使能，会产生模拟电压输出功能 </code><br>
● 第  <code>4 位和第 5 位 </code>可以实现把  <code>PCF8591 的 4 路模拟输入 </code>配置成 <code>单端模式和差分模式 </code><br>
● 第  <code>2 位 </code>是 <code>自动增量控制位 </code>，自动增量的意思就是，比如我们一共有 4 个通道，当我们全部使用的时候，读完了通道 0，下一次再读，会自动进入通道 1 进行读取，不需要我们指定下一个通道，由于 A/D 每次读到的数据，都是上一次的转换结果，所以在使用自动增量功能的时候，要特别注意， <code>当前读到的是上一个通道的值 </code><br>
● 控制字节的 <code>第 0 位和第 1 位 </code>就是 <code>通道0~3选择位 </code>( 00、01、10、11)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/QQ%E6%88%AA%E5%9B%BE20221020160841.jpg" alt=""></p>
<h3 id="程序-12">程序</h3>
<blockquote>
<h4 id="AIN0、AIN1、AIN3-测到的电压值显示在液晶上，转动电位器会发现-AIN0-的值发生变化">AIN0、AIN1、AIN3 测到的电压值显示在液晶上，转动电位器会发现 AIN0 的值发生变化</h4>
</blockquote>
<p>简单显示 <code>AIN0,AIN1,AIN3</code> 电压在液晶(因为AIN2跟AIN1一样故没显示)</p>
<ul>
<li>显示结果是 AIN1接地故保持是 <code>0V</code>，AIN3 是基准源2.5V故也保持 <code>2.5V</code>，AIN0可以通过扭动板子电位器使输出 <code>0~2.5V</code></li>
<li>这里控制字节是 <code>0x40|chn</code>(也就是只使能了DA和选择通道号其余的暂时不操作)</li>
<li><code>val = (val*25) / 255;</code> 255：因为这是8位的ADC，输出数字量是0～255</li>
<li><code>GetADCValue()</code>函数里那两条读语句作用：当前的转换结果总是在<code>下一个字节的 8 个 SCL 上才能读出</code>，因此这里第一条语句的作用是产生一个整体的 SCL 时钟提供给 PCF8591 进行 A/D 转换， 第二次是读取当前的转换结果。如果我们只使用第二条语句的话，每次读到的都是上一次的转换结果</li>
</ul>
<p><code>Lcd1602.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待液晶准备好 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span> <span class="comment">//读状态：RS = L，R/W = H，E = H</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 sta = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = <span class="number">0xFF</span>;</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> <span class="comment">//do while语句是先执行一次语句，再对循环条件进行判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        LCD1602_E = <span class="number">1</span>;     <span class="comment">//使能</span></span><br><span class="line">        sta = LCD1602_DB;  <span class="comment">//读取状态字</span></span><br><span class="line">        LCD1602_E = <span class="number">0</span>;     <span class="comment">//读完撤销使能，防止液晶输出数据干扰 P0 总线</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sta &amp; <span class="number">0x80</span>);   <span class="comment">//最高位等于 1 表示液晶正忙，重复检测直到其等于 0 为止</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节命令，cmd-待写入命令值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span> <span class="comment">//写指令：RS = L，R/W = L，D0~D7 = 指令码，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">0</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = cmd;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 LCD1602 液晶写入一字节数据，dat-待写入数据值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span> <span class="comment">//写数据：RS = H，R/W = L，D0~D7 = 数据，E = 高脉冲</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WaitReady();</span><br><span class="line">    LCD1602_RS = <span class="number">1</span>;</span><br><span class="line">    LCD1602_RW = <span class="number">0</span>;</span><br><span class="line">    LCD1602_DB = dat;</span><br><span class="line">    LCD1602_E = <span class="number">1</span>;</span><br><span class="line">    LCD1602_E = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置显示 RAM 起始地址，亦即光标位置，(x,y)-对应屏幕上的字符坐标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 addr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == y)          <span class="comment">//由输入的屏幕坐标计算显示RAM的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x00</span> + x;  <span class="comment">//第一行字符地址从0x00起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = <span class="number">0x40</span> + x;  <span class="comment">//第二行字符地址从0x40起始</span></span><br><span class="line">    &#125;</span><br><span class="line">    Lcd_WriteCmd(addr | <span class="number">0x80</span>); <span class="comment">//设置RAM地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在液晶上显示字符串，(x,y)-对应屏幕上的起始坐标，str-字符串指针 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_SetCursor(x, y); <span class="comment">//设置起始地址</span></span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Lcd_WriteDat(*str++); <span class="comment">//先取str指向的数据然后进入写数据函数，然后str自加1,优先级一样从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 1602 液晶 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x38</span>); <span class="comment">//16*2显示，5*7点阵，8位数据接口</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x0C</span>); <span class="comment">//显示器开，光标关闭，闪烁关闭	0000 1100</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x06</span>); <span class="comment">//文字不动，地址自动+1 0000 0110</span></span><br><span class="line">    Lcd_WriteCmd(<span class="number">0x01</span>); <span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Lcd1602.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LCD1602_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LCD1602_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD1602_DB P0     <span class="comment">//宏定义1602端口</span></span></span><br><span class="line">sbit LCD1602_RS = P1^<span class="number">0</span>;</span><br><span class="line">sbit LCD1602_RW = P1^<span class="number">1</span>;</span><br><span class="line">sbit LCD1602_E = P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WaitReady</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteCmd</span><span class="params">(u8 cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_WriteDat</span><span class="params">(u8 dat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_SetCursor</span><span class="params">(u8 x, u8 y)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd_ShowStr</span><span class="params">(u8 x, u8 y, u8 *str)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Lcd1602_Init</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                  <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送非应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位    (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                    receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;      <span class="comment">//则接收到的数据加1             向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                   <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;<span class="comment">//再拉低 SCL，以使从机发送出下一位    为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;   <span class="comment">//8 位数据发送完后，拉高 SDA，发送非应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;   <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;   <span class="comment">//再拉低 SCL 完成非应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位  (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                  receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;      <span class="comment">//则接收到的数据加1           向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                 <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;                                 <span class="comment">//为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                              <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//8 位数据发送完后，拉低 SDA，发送应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">bit flag300ms = <span class="number">1</span>; <span class="comment">//300ms 定时标志</span></span><br><span class="line">u8 <span class="title function_">IntToString</span><span class="params">(u8 *str, <span class="type">int</span> dat)</span>;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ADC_Get_Value</span><span class="params">(u8 chn)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ValueToString</span><span class="params">(u8 *str, u8 val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 val;</span><br><span class="line">    u8 str[<span class="number">10</span>];</span><br><span class="line">    Time0_Init(<span class="number">10</span>);  <span class="comment">//T0 定时 10ms</span></span><br><span class="line">    Lcd1602_Init();  <span class="comment">//初始化液晶</span></span><br><span class="line">    Lcd_ShowStr(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;AIN0 AIN1 AIN3&quot;</span>); <span class="comment">//显示通道指示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag300ms)     <span class="comment">//每秒更新一次温度</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag300ms = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//显示通道 0 的电压(电位器的分压值)</span></span><br><span class="line">            val = ADC_Get_Value(<span class="number">0</span>);  <span class="comment">//获取 ADC 通道 0 的转换值</span></span><br><span class="line">            ValueToString(str, val); <span class="comment">//转为字符串格式的电压值</span></span><br><span class="line">            Lcd_ShowStr(<span class="number">0</span>, <span class="number">1</span>, str);  <span class="comment">//显示到液晶上</span></span><br><span class="line">            <span class="comment">//显示通道 1 的电压(GND 的值) 通道1和2都是测量GND的电压值</span></span><br><span class="line">            val = ADC_Get_Value(<span class="number">1</span>);</span><br><span class="line">            ValueToString(str, val);</span><br><span class="line">            Lcd_ShowStr(<span class="number">6</span>, <span class="number">1</span>, str);</span><br><span class="line">            <span class="comment">//显示通道 3 的电压（+5V 的值）</span></span><br><span class="line">            val = ADC_Get_Value(<span class="number">3</span>);</span><br><span class="line">            ValueToString(str, val);</span><br><span class="line">            Lcd_ShowStr(<span class="number">12</span>, <span class="number">1</span>, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取当前的 ADC 转换值，chn-ADC 通道号 0~3 */</span></span><br><span class="line">u8 <span class="title function_">ADC_Get_Value</span><span class="params">(u8 chn)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 val;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    <span class="keyword">if</span>(!I2C_Write(<span class="number">0x90</span>))    <span class="comment">//寻址 PCF8591，如未应答，则停止操作并返回 0  1001 0000 --&gt; 0x90</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_Stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_Write(<span class="number">0x40</span> | chn);  <span class="comment">//写入控制字节，选择转换通道  0100 0000 | chn (控制字节的第6位是DA使能位，这一位置1表示DA输出引脚使能，会产生模拟电压输出功能)</span></span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_Write(<span class="number">0x91</span>);        <span class="comment">//寻址 PCF8591，指定后续为读操作 1001 0001 --&gt; 0x91  最后一位为 1 表示读操作</span></span><br><span class="line">    I2C_ReadACK();          <span class="comment">//先空读一个字节，提供采样转换时间</span></span><br><span class="line">    val = I2C_ReadNACK();   <span class="comment">//读取刚刚转换完的值</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC 转换值转为实际电压值的字符串形式，str-字符串指针，val-AD 转换值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ValueToString</span><span class="params">(u8 *str, u8 val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//电压值=转换结果*2.5V/255，式中的 25 隐含了一位十进制小数</span></span><br><span class="line">    val = (val * <span class="number">25</span>) / <span class="number">255</span>;</span><br><span class="line">    str[<span class="number">0</span>] = (val / <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//整数位字符</span></span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>;               <span class="comment">//小数点</span></span><br><span class="line">    str[<span class="number">2</span>] = (val % <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//小数位字符</span></span><br><span class="line">    str[<span class="number">3</span>] = <span class="string">&#x27;V&#x27;</span>;               <span class="comment">//电压单位</span></span><br><span class="line">    str[<span class="number">4</span>] = <span class="string">&#x27;\0&#x27;</span>;              <span class="comment">//结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行数码管扫描显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 count = <span class="number">0</span>;</span><br><span class="line">    TH0 = T0RH;      <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">30</span>) <span class="comment">//定时 1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        flag300ms = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lcd1602.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="A-D-差分输入信号">A/D 差分输入信号</h3>
<p>控制字的<code>第 4 位和第 5 位</code>是用于控制 PCF8591 的模拟输入引脚是 <code>单端输入还是差分输入</code></p>
<p>从严格意义上来讲，其实所有的信号都是差分信号，因为所有的电压只能是相对于另外一个电压而言。但是大多数系统，我们都是把系统的 <code>GND</code> 作为<code>基准点</code>。而对于 <code>A/D</code> 来说的<code>差分输入</code>，通常情况下是除了 GND 以外，<code>另外两路幅度相同，极性相反的输入信号</code></p>
<p>差分输入的话，就不是单个输入，而是由 2 个输入端构成的一组输入。PCF8591 一共是 4 个模拟输入端，可以配置成 4 种模式，最典型的是 4 个输入端构造成的两路差分模式，如图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20135406.webp" style="zoom: 40%;" />
<p>当控制字的<code>第 4 位和第 5 位都是 1</code> 的时候，那么 <code>4 路模拟被配置成 2 路差分模式输入</code> channel 0 和 channel 1。以 channel 0 为例，其中 AIN0 是正向输入端，AIN1 是反向输入端，它们之间的信号输入是幅度相同，极性相反的信号，通过减法器后，得到的是两个输入通道的差值，如图所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-1320729634.cos.ap-guangzhou.myqcloud.com/image/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-16%20135709.webp" style="zoom:33%;" />
<p>通常情况下，<code>差分输入的中线是基准电压的一半</code>，我们的基准电压是 2.5V，假如 1.25V 作为中线，V+是 AIN0 的输入波形，V-是 AIN1 的输入波形，Signal Value 就是经过<code>减法器</code>后的<code>波形</code>。很多 A/D 都采用差分的方式输入，因为差分输入方式比单端输入来说，有<code>更强的抗干扰能力</code></p>
<p>单端输入信号时，如果一线上发生干扰变化，比如幅度增大 5mv，GND 不变，测到的数据会有偏差；而差分信号输入时，当外界存在干扰信号时，只要布线合理，大都同时被耦合到两条线上，幅度增大 5mv 会同时增大 5mv，而接收端关心的只是两个信号的差值，所以外界的这种共模噪声可以被完全抵消掉。由于两根信号的极性相反，它们对外辐射的电磁场可以相互抵消，有效的抑制释放到外界的电磁能量</p>
<h3 id="D-A-输出">D/A 输出</h3>
<p>D/A 是和 A/D 刚好<code>反方向</code>的，一个 8 位的 D/A，从 0～255，代表了 0～2.55V 的话，那么用单片机给第三个字节发送 100，D/A 引脚就会输出一个 1V 的电压，发送 200 就输出 一个 2V 的电压</p>
<blockquote>
<h4 id="D-A-输出实验">D/A 输出实验</h4>
</blockquote>
<p>用单片机给第三个字节发送 100，D/A 引脚就会输出一个 1V 的电压，发送 200 就输出 一个 2V 的电压，并且通过上、下按键可以增大或减小输出幅度值，每次增加或减小 0.1V。如果有万用表的话，可以直接测试一下板子上 AOUT 点的输出电压，观察它的变化</p>
<p><code>key.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 code KeyCodeMap[<span class="number">4</span>][<span class="number">4</span>] =   <span class="comment">//矩阵按键编号到标准键盘键码的映射表</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x26</span> &#125;, <span class="comment">//数字键 1、数字键 2、数字键 3、向上键</span></span><br><span class="line">    &#123; <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="number">0x25</span> &#125;, <span class="comment">//数字键 4、数字键 5、数字键 6、向左键</span></span><br><span class="line">    &#123; <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="number">0x28</span> &#125;, <span class="comment">//数字键 7、数字键 8、数字键 9、向下键</span></span><br><span class="line">    &#123; <span class="string">&#x27;0&#x27;</span>, <span class="number">0x1B</span>, <span class="number">0x0D</span>, <span class="number">0x27</span> &#125; <span class="comment">//数字键 0、ESC 键、 回车键、 向右键</span></span><br><span class="line">&#125;;</span><br><span class="line">u8 pdata Key_State[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;<span class="comment">//按键当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键驱动函数，检测按键动作，调度相应动作函数，需在主循环中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, j;</span><br><span class="line">    <span class="type">static</span> u8 backup[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">//按键值备份，保存前一次的值</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环扫描 4*4 的矩阵按键</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(backup[i][j] != Key_State[i][j]) <span class="comment">//当前值与前次值不相等说明此时按键有动作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(backup[i][j] != <span class="number">0</span>)  <span class="comment">//前次值不等于0，则当前值等于0，按键按下</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Key_Action(KeyCodeMap[i][j]); <span class="comment">//调用按键动作函数</span></span><br><span class="line">                &#125;</span><br><span class="line">                backup[i][j] = Key_State[i][j]; <span class="comment">//更新前一次的备份值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键扫描函数，需在定时中断中调用 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> u8 KeyOut = <span class="number">0</span>; <span class="comment">//矩阵按键扫描输出索引</span></span><br><span class="line">    <span class="type">static</span> u8 keybuf[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;, &#123;<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>&#125;</span><br><span class="line">    &#125;; <span class="comment">//矩阵按键扫描缓冲区</span></span><br><span class="line">    <span class="comment">//将一行的 4 个按键值移入缓冲区</span></span><br><span class="line">    keybuf[KeyOut][<span class="number">0</span>] = (keybuf[KeyOut][<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) | KeyIn1;</span><br><span class="line">    keybuf[KeyOut][<span class="number">1</span>] = (keybuf[KeyOut][<span class="number">1</span>] &lt;&lt; <span class="number">1</span>) | KeyIn2;</span><br><span class="line">    keybuf[KeyOut][<span class="number">2</span>] = (keybuf[KeyOut][<span class="number">2</span>] &lt;&lt; <span class="number">1</span>) | KeyIn3;</span><br><span class="line">    keybuf[KeyOut][<span class="number">3</span>] = (keybuf[KeyOut][<span class="number">3</span>] &lt;&lt; <span class="number">1</span>) | KeyIn4;</span><br><span class="line">    <span class="comment">//消抖后更新按键状态</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//每行 4 个按键，所以循环 4 次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0x00</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 0，即 4*4ms 内都是按下状态时，可认为按键已稳定的按下</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0x0F</span> == (keybuf[KeyOut][i] &amp; <span class="number">0x0F</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//连续 4 次扫描值为 1，即 4*4ms 内都是弹起状态时，可认为按键已稳定的弹起</span></span><br><span class="line">            Key_State[KeyOut][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行下一次的扫描输出</span></span><br><span class="line">    KeyOut++; <span class="comment">//输出索引递增</span></span><br><span class="line">    <span class="keyword">if</span> (KeyOut &gt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KeyOut = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//	KeyOut = KeyOut &amp; 0x03; //索引值加到 4 即归零</span></span><br><span class="line">    <span class="keyword">switch</span>(KeyOut) <span class="comment">//根据索引，释放当前输出引脚，拉低下次的输出引脚</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        KeyOut4 = <span class="number">1</span>;</span><br><span class="line">        KeyOut1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        KeyOut1 = <span class="number">1</span>;</span><br><span class="line">        KeyOut2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        KeyOut2 = <span class="number">1</span>;</span><br><span class="line">        KeyOut3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        KeyOut3 = <span class="number">1</span>;</span><br><span class="line">        KeyOut4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>key.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _KEY_H_</span></span><br><span class="line"></span><br><span class="line">sbit KeyIn1 = P2^<span class="number">4</span>;  </span><br><span class="line">sbit KeyIn2 = P2^<span class="number">5</span>;</span><br><span class="line">sbit KeyIn3 = P2^<span class="number">6</span>;</span><br><span class="line">sbit KeyIn4 = P2^<span class="number">7</span>;</span><br><span class="line">sbit KeyOut1 = P2^<span class="number">3</span>;</span><br><span class="line">sbit KeyOut2 = P2^<span class="number">2</span>;</span><br><span class="line">sbit KeyOut3 = P2^<span class="number">1</span>;</span><br><span class="line">sbit KeyOut4 = P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Driver</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Scan</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>I2C.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_Delay() &#123;_nop_();_nop_();_nop_();_nop_();&#125; <span class="comment">//宏定义延时函数(一个_nop_()的时间就是一个机器周期)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线起始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//首先确保 SDA、SCL 都是高电平</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//当SCL为高电平时，SDA由高变为低</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 产生总线停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//首先确保 SDA、SCL 都是低电平</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;</span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//先拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;  <span class="comment">//当SCL为高电平时，SDA由低变为高</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线写操作，dat-待写入字节，返回值-从机应答位的值 */</span></span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    bit ack; <span class="comment">//用于暂存应答位的值</span></span><br><span class="line">    u8 i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>) <span class="comment">//比较最高位 (如1011 0100 &amp; 1000 0000 --&gt; 1000 0000 最高位等于1 大于0)</span></span><br><span class="line">            I2C_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            I2C_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;           <span class="comment">//左移一位(将次高位移到最高位)</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;         <span class="comment">//为1数据稳定等待下一次传输</span></span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;         <span class="comment">//数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;     <span class="comment">//8 位数据发送完后，主机释放 SDA，以检测从机应答</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;     <span class="comment">//拉高 SCL</span></span><br><span class="line">    ack = I2C_SDA;   <span class="comment">//读取此时的 SDA 值，即为从机的应答值</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;     <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line">    <span class="keyword">return</span> (~ack);   <span class="comment">//应答值取反以符合通常的逻辑：</span></span><br><span class="line">&#125;                  <span class="comment">//0=不存在或忙或写入失败，1=存在且空闲或写入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送非应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位    (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                    receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;      <span class="comment">//则接收到的数据加1             向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                   <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;<span class="comment">//再拉低 SCL，以使从机发送出下一位    为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                                <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">1</span>;   <span class="comment">//8 位数据发送完后，拉高 SDA，发送非应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;   <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;   <span class="comment">//再拉低 SCL 完成非应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C 总线读操作，并发送应答信号，返回值-读到的字节 */</span></span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 receive = <span class="number">0</span>;         <span class="comment">//保存读取的数据</span></span><br><span class="line">    u8 i;</span><br><span class="line">    I2C_SDA = <span class="number">1</span>;            <span class="comment">//首先确保主机释放 SDA</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SCL = <span class="number">0</span>;</span><br><span class="line">        I2C_Delay();</span><br><span class="line">        I2C_SCL = <span class="number">1</span>;      <span class="comment">//SCL为1时数据稳定，可以传输数据</span></span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;    <span class="comment">//将接收到的数据向左移动一位  (假设要传输 1001 1000，则先接收到高位1，则SDA为1，</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == I2C_SDA)  <span class="comment">//如果SDA为1                  receive加1，则receive为 0000 0001，之后将receive</span></span><br><span class="line">            receive++;      <span class="comment">//则接收到的数据加1           向左移动一位，则receive为 0000 0010,接着传输第二位0，</span></span><br><span class="line">        I2C_Delay();                                 <span class="comment">//则SDA为0，不进入if语句，receive接收到0，则receive</span></span><br><span class="line">        I2C_SCL = <span class="number">0</span>;                                 <span class="comment">//为 0000 0010，之后将receive向左移动一位，则receive为</span></span><br><span class="line">    &#125;                                              <span class="comment">//0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)</span></span><br><span class="line">    I2C_SDA = <span class="number">0</span>;  <span class="comment">//8 位数据发送完后，拉低 SDA，发送应答信号</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">1</span>;  <span class="comment">//拉高 SCL</span></span><br><span class="line">    I2C_Delay();</span><br><span class="line">    I2C_SCL = <span class="number">0</span>;  <span class="comment">//再拉低 SCL 完成应答位，并保持住总线</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>I2C.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _I2C_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _I2C_H_</span></span><br><span class="line"></span><br><span class="line">sbit I2C_SCL = P3^<span class="number">7</span>;</span><br><span class="line">sbit I2C_SDA = P3^<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span>;</span><br><span class="line">bit <span class="title function_">I2C_Write</span><span class="params">(u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadNACK</span><span class="params">()</span>;</span><br><span class="line">u8 <span class="title function_">I2C_ReadACK</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>time.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 T0RH = <span class="number">0</span>; <span class="comment">//T0 重载值的高字节</span></span><br><span class="line">u8 T0RL = <span class="number">0</span>; <span class="comment">//T0 重载值的低字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置并启动T0，ms-T0定时时间 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 temp = <span class="number">0</span>; <span class="comment">//临时变量</span></span><br><span class="line">    temp = <span class="number">11059200</span> / <span class="number">12</span>;              <span class="comment">//定时器计数频率</span></span><br><span class="line">    temp = (temp * ms) / <span class="number">1000</span>;         <span class="comment">//计算所需的计数值</span></span><br><span class="line">    temp = <span class="number">65536</span> - temp;               <span class="comment">//计算定时器重载值</span></span><br><span class="line">    temp += <span class="number">18</span>;                        <span class="comment">//补偿中断响应延时造成的误差</span></span><br><span class="line">    T0RH = (<span class="type">unsigned</span> <span class="type">char</span>)(temp &gt;&gt; <span class="number">8</span>); <span class="comment">//定时器重载值拆分为高低字节</span></span><br><span class="line">    T0RL = (<span class="type">unsigned</span> <span class="type">char</span>)temp;</span><br><span class="line">    EA = <span class="number">1</span>;       <span class="comment">//开总中断</span></span><br><span class="line">    TMOD &amp;= <span class="number">0xF0</span>; <span class="comment">//清零T0的控制位</span></span><br><span class="line">    TMOD |= <span class="number">0x01</span>; <span class="comment">//配置T0为模式1</span></span><br><span class="line">    TH0 = T0RH;   <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    ET0 = <span class="number">1</span>;      <span class="comment">//使能T0中断</span></span><br><span class="line">    TR0 = <span class="number">1</span>;      <span class="comment">//启动T0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>time.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TIME_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TIME_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 T0RH; <span class="comment">//由于外部文件用到该变量，所以前面要加 extern</span></span><br><span class="line"><span class="keyword">extern</span> u8 T0RL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Time0_Init</span><span class="params">(u16 ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;AllHead.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDACOut</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Time0_Init(<span class="number">1</span>);  <span class="comment">//T0 定时 1ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Key_Driver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键动作函数，根据键码执行相应的操作，keycode-按键键码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Action</span><span class="params">(u8 keycode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 volt = <span class="number">0</span>; <span class="comment">//输出电压值，隐含了一位十进制小数位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x26</span> == keycode) <span class="comment">//向上键，增加 0.1V 电压值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (volt &lt; <span class="number">25</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            volt++;</span><br><span class="line">            SetDACOut(volt * <span class="number">255</span> / <span class="number">25</span>); <span class="comment">//转换为 AD 输出值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (keycode == <span class="number">0x28</span>) <span class="comment">//向下键，减小 0.1V 电压值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (volt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            volt--;</span><br><span class="line">            SetDACOut(volt * <span class="number">255</span> / <span class="number">25</span>); <span class="comment">//转换为 AD 输出值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 DAC 输出值，val-设定值 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetDACOut</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    <span class="keyword">if</span> (!I2C_Write(<span class="number">0x90</span>)) <span class="comment">//寻址 PCF8591，如未应答，则停止操作并返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        I2C_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_Write(<span class="number">0x40</span>); <span class="comment">//写入控制字节</span></span><br><span class="line">    I2C_Write(val); <span class="comment">//写入 DA 值</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T0 中断服务函数，执行数码管扫描显示 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = T0RH;      <span class="comment">//加载T0重载值</span></span><br><span class="line">    TL0 = T0RL;</span><br><span class="line">    Key_Scan(); <span class="comment">//按键扫描</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AllHead.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ALLHEAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ALLHEAD_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I2C.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/num3.webp" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">开发板介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">新建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%86%85%E9%83%A8%E8%B5%84%E6%BA%90"><span class="toc-number">3.</span> <span class="toc-text">单片机的内部资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">单片机最小系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">电源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%B6%E6%8C%AF"><span class="toc-number">4.2.</span> <span class="toc-text">晶振</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF"><span class="toc-number">4.3.</span> <span class="toc-text">复位电路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">基础知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%9E%81%E7%AE%A1"><span class="toc-number">5.1.</span> <span class="toc-text">三极管</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">三极管的初步认识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">三极管的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">5.2.</span> <span class="toc-text">逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.1.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.2.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E7%AC%A6%E5%8F%B7"><span class="toc-number">5.2.3.</span> <span class="toc-text">逻辑电路符号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">不同数据类型间的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E5%8D%95%E7%89%87%E6%9C%BA-RAM-%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">5.4.</span> <span class="toc-text">51 单片机 RAM 区域的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">5.5.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">5.5.1.</span> <span class="toc-text">指针变量的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">5.5.2.</span> <span class="toc-text">指向数组元素的指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.1.</span> <span class="toc-text">结构体数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.2.</span> <span class="toc-text">共用体数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.3.</span> <span class="toc-text">枚举数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">5.7.</span> <span class="toc-text">转义字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LED%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">LED模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E4%BA%AELED%E7%94%A8%E5%88%B0%E7%9A%84%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">6.1.</span> <span class="toc-text">点亮LED用到的原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74HC245%E8%8A%AF%E7%89%87"><span class="toc-number">6.2.</span> <span class="toc-text">74HC245芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74HC138%E8%8A%AF%E7%89%87"><span class="toc-number">6.3.</span> <span class="toc-text">74HC138芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED%E5%B0%8F%E7%81%AF%E6%95%B4%E4%BD%93%E7%94%B5%E8%B7%AF%E5%9B%BE"><span class="toc-number">6.4.</span> <span class="toc-text">LED小灯整体电路图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">LED程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AALED"><span class="toc-number">6.5.1.</span> <span class="toc-text">点亮一个LED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED%E7%81%AF%E9%97%AA%E7%83%81"><span class="toc-number">6.5.2.</span> <span class="toc-text">LED灯闪烁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED%E5%B7%A6%E5%8F%B3%E6%B5%81%E6%B0%B4"><span class="toc-number">6.5.3.</span> <span class="toc-text">LED左右流水</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86"><span class="toc-number">7.1.</span> <span class="toc-text">定时器的初步认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.2.</span> <span class="toc-text">定时器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">定时器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">定时器的寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-TCON"><span class="toc-number">7.4.1.</span> <span class="toc-text">控制寄存器 TCON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8-TMOD"><span class="toc-number">7.4.2.</span> <span class="toc-text">工作方式寄存器 TMOD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">7.5.</span> <span class="toc-text">定时&#x2F;计数器的工作方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%88%9D%E5%80%BC"><span class="toc-number">7.6.</span> <span class="toc-text">计算定时&#x2F;计数器初值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">7.7.</span> <span class="toc-text">定时器配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.8.</span> <span class="toc-text">定时器程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A80%E6%8E%A7%E5%88%B6LED-0-5-%E7%A7%92%E9%97%AA%E7%83%81%E4%B8%80%E6%AC%A1"><span class="toc-number">7.8.1.</span> <span class="toc-text">定时器0控制LED 0.5 秒闪烁一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B60-5%E7%A7%92%E6%8E%A7%E5%88%B6LED%E6%B5%81%E6%B0%B4%E7%81%AF%E6%B5%81%E5%8A%A8"><span class="toc-number">7.8.2.</span> <span class="toc-text">使用定时器定时0.5秒控制LED流水灯流动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">8.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">中断概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">中断结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">中断相关寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%85%81%E8%AE%B8%E6%8E%A7%E5%88%B6"><span class="toc-number">8.3.1.</span> <span class="toc-text">中断允许控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E6%A0%87%E5%BF%97-TCON"><span class="toc-number">8.3.2.</span> <span class="toc-text">中断请求标志 TCON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.3.3.</span> <span class="toc-text">中断优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-number">8.3.4.</span> <span class="toc-text">中断号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.3.5.</span> <span class="toc-text">中断响应条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE"><span class="toc-number">8.4.</span> <span class="toc-text">外部中断配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">数码管</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">数码管简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E8%A1%A8"><span class="toc-number">9.2.</span> <span class="toc-text">数码表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E9%98%B4%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A0%81%E8%A1%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">共阴数码管码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E9%98%B3%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A0%81%E8%A1%A8"><span class="toc-number">9.2.2.</span> <span class="toc-text">共阳数码管码表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">9.3.</span> <span class="toc-text">数码管原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA"><span class="toc-number">9.4.</span> <span class="toc-text">数码管显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.5.</span> <span class="toc-text">静态数码管程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA0"><span class="toc-number">9.5.1.</span> <span class="toc-text">最右边的数码管显示0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA0-F"><span class="toc-number">9.5.2.</span> <span class="toc-text">最右边的数码管显示0~F</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.6.</span> <span class="toc-text">动态数码管程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E8%AE%A1%E6%95%B0%EF%BC%8C%E4%BB%8E0%E5%88%B0999999"><span class="toc-number">9.6.1.</span> <span class="toc-text">数码管计数，从0到999999</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E6%97%B6%E9%92%9F"><span class="toc-number">9.6.2.</span> <span class="toc-text">使用定时器做一个时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%92%E8%A1%A8"><span class="toc-number">9.6.3.</span> <span class="toc-text">使用定时器做一个秒表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E5%81%9A%E4%B8%80%E4%B8%AA%E7%A7%92%E8%A1%A8%E5%80%92%E8%AE%A1%E6%97%B6"><span class="toc-number">9.6.4.</span> <span class="toc-text">使用定时器做一个秒表倒计时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E6%97%B6%E9%92%9F%EF%BC%8C%E8%AE%BE%E7%BD%AELED%E5%B7%A6%E5%8F%B3%E6%B5%81%E6%B0%B4"><span class="toc-number">9.6.5.</span> <span class="toc-text">数码管显示时钟，设置LED左右流水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E7%BB%BF%E7%81%AF"><span class="toc-number">9.6.6.</span> <span class="toc-text">红绿灯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E9%98%B5"><span class="toc-number">10.</span> <span class="toc-text">点阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LED%E7%82%B9%E9%98%B5%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">10.1.</span> <span class="toc-text">LED点阵原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74HC138%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">10.2.</span> <span class="toc-text">74HC138原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%AD%97%E6%A8%A1%E8%BD%AF%E4%BB%B6"><span class="toc-number">10.3.</span> <span class="toc-text">取字模软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AA%E7%82%B9"><span class="toc-number">10.4.1.</span> <span class="toc-text">点亮一个点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E4%B8%80%E8%A1%8C"><span class="toc-number">10.4.2.</span> <span class="toc-text">点亮一行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E5%85%A8%E9%83%A8"><span class="toc-number">10.4.3.</span> <span class="toc-text">点亮全部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%88%B1%E5%BF%83"><span class="toc-number">10.4.4.</span> <span class="toc-text">显示爱心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E9%98%B5%E7%9A%84%E5%8A%A8%E7%94%BB%E6%98%BE%E7%A4%BA"><span class="toc-number">10.5.</span> <span class="toc-text">点阵的动画显示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E9%98%B5%E7%9A%84%E7%BA%B5%E5%90%91%E7%A7%BB%E5%8A%A8%EF%BC%88%E5%90%91%E4%B8%8A%E7%A7%BB%E5%8A%A8%EF%BC%89"><span class="toc-number">10.5.1.</span> <span class="toc-text">点阵的纵向移动（向上移动）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E7%A7%BB%E5%8A%A8-%E7%BA%B5%E5%90%91"><span class="toc-number">10.5.2.</span> <span class="toc-text">向下移动(纵向)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%B7%A6%E7%A7%BB%E5%8A%A8-%E6%A8%AA%E5%90%91"><span class="toc-number">10.5.3.</span> <span class="toc-text">向左移动(横向)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%8F%B3%E7%A7%BB%E5%8A%A8-%E6%A8%AA%E5%90%91"><span class="toc-number">10.5.4.</span> <span class="toc-text">向右移动(横向)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-9%E7%9A%84%E6%A8%A1"><span class="toc-number">10.6.</span> <span class="toc-text">0~9的模</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E9%94%AE"><span class="toc-number">11.</span> <span class="toc-text">按键</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE"><span class="toc-number">11.1.</span> <span class="toc-text">独立按键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE"><span class="toc-number">11.2.</span> <span class="toc-text">矩阵按键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">11.3.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%95%B0%E7%A0%81%E7%AE%A1%E6%95%B0%E5%80%BC-1%EF%BC%88%E4%BD%BF%E7%94%A8Delay%E5%87%BD%E6%95%B0%E6%B6%88%E6%8A%96%EF%BC%89"><span class="toc-number">11.3.1.</span> <span class="toc-text">按键按一次，数码管数值+1（使用Delay函数消抖）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%95%B0%E7%A0%81%E7%AE%A1%E6%95%B0%E5%80%BC-1%EF%BC%88%E4%BD%BF%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E6%B6%88%E6%8A%96%EF%BC%89"><span class="toc-number">11.3.2.</span> <span class="toc-text">按键按一次，数码管数值+1（使用定时器中断消抖）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E7%9A%84%E6%89%AB%E6%8F%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E6%8C%89%E9%94%AE%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A"><span class="toc-number">11.3.3.</span> <span class="toc-text">矩阵按键的扫描，并且将按键值显示在第一个数码管上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F%E6%89%AB%E6%8F%8F%E6%B3%95-%E2%80%93-%E5%9C%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%AF%B9%E5%BA%94%E9%94%AE%E5%80%BC%EF%BC%8801-16%EF%BC%89"><span class="toc-number">11.3.4.</span> <span class="toc-text">行列式扫描法 – 在数码管上显示对应键值（01 ~ 16）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%BF%BB%E8%BD%AC%E6%89%AB%E6%8F%8F%E6%B3%95-%E5%9C%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%AF%B9%E5%BA%94%E9%94%AE%E5%80%BC%EF%BC%8801-16%EF%BC%89"><span class="toc-number">11.3.5.</span> <span class="toc-text">线翻转扫描法-- 在数码管上显示对应键值（01 ~ 16）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A0%E5%87%8F%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-number">11.3.6.</span> <span class="toc-text">简单加减法计算器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE1%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E7%81%AF%EF%BC%8C%E6%8C%89%E9%94%AE2%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA0%E5%88%B099%EF%BC%8C%E6%8C%89%E9%94%AE3%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E6%97%B6%E9%92%9F"><span class="toc-number">11.3.7.</span> <span class="toc-text">按键1实现流水灯，按键2数码管显示0到99，按键3数码管显示时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E5%9B%9B%E4%B8%AALED%E4%BA%AE%E7%81%AD"><span class="toc-number">11.3.8.</span> <span class="toc-text">四个按键控制四个LED亮灭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E7%A7%92%E8%A1%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%81%9C%E6%AD%A2"><span class="toc-number">11.3.9.</span> <span class="toc-text">使用按键控制秒表的启动与停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%94%AE%E9%95%BF%E6%8C%89%E5%8A%9F%E8%83%BD"><span class="toc-number">11.3.10.</span> <span class="toc-text">实现按键长按功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA"><span class="toc-number">12.</span> <span class="toc-text">步进电机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28BYJ-48-%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">12.2.</span> <span class="toc-text">28BYJ-48 步进电机简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">12.3.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-3"><span class="toc-number">12.4.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%9F%BA%E7%A1%80%E8%BD%AC%E5%8A%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">步进电机基础转动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA"><span class="toc-number">12.4.2.</span> <span class="toc-text">按键控制步进电机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">13.</span> <span class="toc-text">蜂鸣器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE-2"><span class="toc-number">13.1.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-4"><span class="toc-number">13.2.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8%E6%BC%94%E7%A4%BA"><span class="toc-number">13.2.1.</span> <span class="toc-text">蜂鸣器演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E9%93%83"><span class="toc-number">13.2.2.</span> <span class="toc-text">门铃</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PWM"><span class="toc-number">14.</span> <span class="toc-text">PWM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-5"><span class="toc-number">14.1.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-number">14.1.1.</span> <span class="toc-text">呼吸灯</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UART-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">15.</span> <span class="toc-text">UART 串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="toc-number">15.1.</span> <span class="toc-text">串口通信相关术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RS232-%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.2.</span> <span class="toc-text">RS232 通信接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E5%8F%A3%E6%A8%A1%E6%8B%9F-UART-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">15.3.</span> <span class="toc-text">IO 口模拟 UART 串口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-%E5%8F%A3%E6%A8%A1%E6%8B%9F-UART-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1-%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%99%E6%8E%A5%E6%94%B6%E8%AF%A5%E6%95%B0%E6%8D%AE-1"><span class="toc-number">15.3.1.</span> <span class="toc-text">IO 口模拟 UART 串口通信(串口发送数据则接收该数据+1)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USB-%E8%BD%AC%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1"><span class="toc-number">15.4.</span> <span class="toc-text">USB 转串口通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">15.5.</span> <span class="toc-text">串口相关寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-SCON"><span class="toc-number">15.5.1.</span> <span class="toc-text">串口控制寄存器 SCON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-PCON"><span class="toc-number">15.5.2.</span> <span class="toc-text">电源控制寄存器 PCON</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SBUF%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">15.5.3.</span> <span class="toc-text">SBUF寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">15.6.</span> <span class="toc-text">串口初始化步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-6"><span class="toc-number">15.7.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%88%99%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%BA-%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE-1"><span class="toc-number">15.7.1.</span> <span class="toc-text">串口发送数据则接收到的数据为 发送的数据+1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9C%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5"><span class="toc-number">15.7.2.</span> <span class="toc-text">单片机串口调试助手发送的数据，在数码管上显示出来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%88%B0%E4%BB%BB%E6%84%8F%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E5%90%8E%E6%94%B9%E5%8F%98%E6%B5%81%E6%B0%B4%E7%81%AF%E6%B5%81%E6%B0%B4%E7%9A%84%E6%96%B9%E5%90%91%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A"><span class="toc-number">15.7.3.</span> <span class="toc-text">接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%88%B0%E4%BB%BB%E6%84%8F%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E5%90%8E%E6%94%B9%E5%8F%98%E6%B5%81%E6%B0%B4%E7%81%AF%E6%B5%81%E6%B0%B4%E7%9A%84%E6%96%B9%E5%90%91%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%95%B0%E7%A0%81%E7%AE%A1%E4%B8%8A%EF%BC%8C%E5%BD%93%E6%8E%A5%E6%94%B6%E5%88%B0%E5%A4%A7%E5%86%99-%E2%80%9CB%E2%80%9D%EF%BC%8C%E8%9C%82%E9%B8%A3%E5%99%A8%E5%93%8D-%E8%A6%81%E7%94%A8%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E5%8F%91%E9%80%81%E6%89%8D%E6%9C%89%E6%95%88"><span class="toc-number">15.7.4.</span> <span class="toc-text">接到任意字节数据后改变流水灯流水的方向，并且将数据显示在数码管上，当接收到大写 “B”，蜂鸣器响(要用文本模式发送才有效)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E4%B8%8A%E4%BD%8D%E6%9C%BA%E4%B8%8B%E5%8F%91%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%91%BD%E4%BB%A4%E5%80%BC%E5%88%86%E5%88%AB%E6%8A%8A%E4%B8%8D%E5%90%8C%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%9E%E5%8F%91%E7%BB%99%E4%B8%8A%E4%BD%8D%E6%9C%BA"><span class="toc-number">15.7.5.</span> <span class="toc-text">接收上位机下发的命令，根据命令值分别把不同数组的数据回发给上位机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1602%E6%B6%B2%E6%99%B6"><span class="toc-number">16.</span> <span class="toc-text">1602液晶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1602-%E6%B6%B2%E6%99%B6%E5%BC%95%E8%84%9A%E5%8A%9F%E8%83%BD"><span class="toc-number">16.1.</span> <span class="toc-text">1602 液晶引脚功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1602%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">16.2.</span> <span class="toc-text">1602原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1602-%E6%B6%B2%E6%99%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%97%B6%E5%BA%8F"><span class="toc-number">16.3.</span> <span class="toc-text">1602 液晶的读写时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1602-%E6%B6%B2%E6%99%B6%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">16.4.</span> <span class="toc-text">1602 液晶的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">16.5.</span> <span class="toc-text">通信时序解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-7"><span class="toc-number">16.6.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8LCD1602%E4%B8%8A%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">16.6.1.</span> <span class="toc-text">在LCD1602上显示字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E7%A7%BB%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">16.6.2.</span> <span class="toc-text">左移字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">16.6.3.</span> <span class="toc-text">计算器实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8%E4%B8%8ELCD1602%E6%B6%B2%E6%99%B6"><span class="toc-number">16.6.4.</span> <span class="toc-text">串口控制蜂鸣器与LCD1602液晶</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I2C-%E6%80%BB%E7%BA%BF%E4%B8%8E-EEPROM"><span class="toc-number">17.</span> <span class="toc-text">I2C 总线与 EEPROM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C-%E6%97%B6%E5%BA%8F"><span class="toc-number">17.1.</span> <span class="toc-text">I2C 时序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C-%E6%97%B6%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">17.1.1.</span> <span class="toc-text">I2C 时序流程图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EEPROM%E8%8A%AF%E7%89%87"><span class="toc-number">17.2.</span> <span class="toc-text">EEPROM芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EEPROM-%E5%8D%95%E5%AD%97%E8%8A%82%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F"><span class="toc-number">17.2.1.</span> <span class="toc-text">EEPROM 单字节读写操作时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EEPROM-%E5%A4%9A%E5%AD%97%E8%8A%82%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F"><span class="toc-number">17.2.2.</span> <span class="toc-text">EEPROM 多字节读写操作时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EEPROM-%E7%9A%84%E9%A1%B5%E5%86%99%E5%85%A5"><span class="toc-number">17.2.3.</span> <span class="toc-text">EEPROM 的页写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-8"><span class="toc-number">17.3.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-EEPROM-%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">17.3.1.</span> <span class="toc-text">访问 EEPROM 的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-EEPROM-%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B0%86%E8%AF%BB%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%A0-1%EF%BC%8C%E5%86%8D%E5%86%99%E5%88%B0-EEPROM-%E5%9C%B0%E5%9D%80%E4%B8%8A"><span class="toc-number">17.3.2.</span> <span class="toc-text">读取 EEPROM 地址上的一个数据，将读出来的数据加 1，再写到 EEPROM 地址上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EEPROM%E9%A1%B5%E5%86%99%E5%85%A5-%E2%80%93-%E8%AF%BB%E5%8F%96-EEPROM-%E5%9C%B0%E5%9D%80%E4%B8%8A%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B0%86%E8%AF%BB%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%88%AB-1-3-5%C2%B7%C2%B7%C2%B7%EF%BC%8C%E5%86%8D%E5%86%99%E5%88%B0-EEPROM-%E5%9C%B0%E5%9D%80%E4%B8%8A"><span class="toc-number">17.3.3.</span> <span class="toc-text">EEPROM页写入 – 读取 EEPROM 地址上的多个数据，将读出来的数据分别 + 1 3 5···，再写到 EEPROM 地址上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C-%E5%92%8C-EEPROM-%E7%9A%84%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C"><span class="toc-number">17.3.4.</span> <span class="toc-text">I2C 和 EEPROM 的综合实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F-DS1302"><span class="toc-number">18.</span> <span class="toc-text">实时时钟 DS1302</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BCD-%E7%A0%81"><span class="toc-number">18.1.</span> <span class="toc-text">BCD 码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI-%E6%97%B6%E5%BA%8F"><span class="toc-number">18.2.</span> <span class="toc-text">SPI 时序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E6%97%B6%E5%BA%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.2.1.</span> <span class="toc-text">读写数据时序的四种模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87-DS1302"><span class="toc-number">18.3.</span> <span class="toc-text">实时时钟芯片 DS1302</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS1302-%E4%BD%BF%E7%94%A8"><span class="toc-number">18.4.</span> <span class="toc-text">DS1302 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">18.4.1.</span> <span class="toc-text">控制寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%8E%86-%E6%97%B6%E9%92%9F%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">18.4.2.</span> <span class="toc-text">日历&#x2F;时钟寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS1302-%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F"><span class="toc-number">18.5.</span> <span class="toc-text">DS1302 通信时序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS1302-%E7%9A%84-BURST-%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.6.</span> <span class="toc-text">DS1302 的 BURST 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE-3"><span class="toc-number">18.7.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-9"><span class="toc-number">18.8.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-DS1302-%E7%9A%84%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%B6%B2%E6%99%B6%E5%B1%8F%E4%B8%8A"><span class="toc-number">18.8.1.</span> <span class="toc-text">读取 DS1302 的当前时间，并显示在液晶屏上</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E9%80%9A%E4%BF%A1"><span class="toc-number">19.</span> <span class="toc-text">红外通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E5%85%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">19.1.</span> <span class="toc-text">红外光的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">19.2.</span> <span class="toc-text">红外遥控的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NEC%E5%8D%8F%E8%AE%AE%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E5%99%A8"><span class="toc-number">19.3.</span> <span class="toc-text">NEC协议红外遥控器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE-4"><span class="toc-number">19.4.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-10"><span class="toc-number">19.5.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E6%8A%8A%E9%81%A5%E6%8E%A7%E5%99%A8%E7%9A%84%E7%94%A8%E6%88%B7%E7%A0%81%E5%92%8C%E9%94%AE%E7%A0%81%E6%98%BE%E7%A4%BA%E5%87%BA%E6%9D%A5"><span class="toc-number">19.5.1.</span> <span class="toc-text">数码管把遥控器的用户码和键码显示出来</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8-DS18B20"><span class="toc-number">20.</span> <span class="toc-text">温度传感器 DS18B20</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B8%A9%E5%BA%A6%E6%95%B0%E6%8D%AE"><span class="toc-number">20.1.</span> <span class="toc-text">读取温度数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%BA%8F"><span class="toc-number">20.1.1.</span> <span class="toc-text">初始化时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%BA%8F"><span class="toc-number">20.1.2.</span> <span class="toc-text">写时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%97%B6%E5%BA%8F"><span class="toc-number">20.1.3.</span> <span class="toc-text">读时序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%9B%BE-5"><span class="toc-number">20.2.</span> <span class="toc-text">原理图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-11"><span class="toc-number">20.3.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%AF%BB%E5%88%B0%E7%9A%84%E6%B8%A9%E5%BA%A6%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8-1602-%E6%B6%B2%E6%99%B6%E4%B8%8A%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BF%9D%E7%95%99%E4%B8%80%E4%BD%8D%E5%B0%8F%E6%95%B0%E4%BD%8D"><span class="toc-number">20.3.1.</span> <span class="toc-text">将读到的温度值显示在 1602 液晶上，并且保留一位小数位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2-A-D-%E4%B8%8E%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2-D-A"><span class="toc-number">21.</span> <span class="toc-text">模数转换 A&#x2F;D 与数模转换 D&#x2F;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-D-%E5%92%8C-D-A-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">21.1.</span> <span class="toc-text">A&#x2F;D 和 D&#x2F;A 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-D-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8C%87%E6%A0%87"><span class="toc-number">21.2.</span> <span class="toc-text">A&#x2F;D 的主要指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF8591-%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.3.</span> <span class="toc-text">PCF8591 的硬件接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCF8591-%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">21.4.</span> <span class="toc-text">PCF8591 的软件编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F-12"><span class="toc-number">21.5.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AIN0%E3%80%81AIN1%E3%80%81AIN3-%E6%B5%8B%E5%88%B0%E7%9A%84%E7%94%B5%E5%8E%8B%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%B6%B2%E6%99%B6%E4%B8%8A%EF%BC%8C%E8%BD%AC%E5%8A%A8%E7%94%B5%E4%BD%8D%E5%99%A8%E4%BC%9A%E5%8F%91%E7%8E%B0-AIN0-%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-number">21.5.1.</span> <span class="toc-text">AIN0、AIN1、AIN3 测到的电压值显示在液晶上，转动电位器会发现 AIN0 的值发生变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-D-%E5%B7%AE%E5%88%86%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7"><span class="toc-number">21.6.</span> <span class="toc-text">A&#x2F;D 差分输入信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-A-%E8%BE%93%E5%87%BA"><span class="toc-number">21.7.</span> <span class="toc-text">D&#x2F;A 输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#D-A-%E8%BE%93%E5%87%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">21.7.1.</span> <span class="toc-text">D&#x2F;A 输出实验</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 被窝理想家</div><div class="footer_custom_text"><div><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Frame-Hexo-blue.svg" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/butterfly/blog_other/Theme-Butterfly-6513df.svg" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/Hosted-Vercel-brightgreen.svg" title="本站采用多线部署，次线路托管于Vercel" alt="HEXO"></a></div></div><div id="running-time" style="color: #5c5c5c;"><script>setInterval(()=>{let create_time=Math.round(new Date('9/6/2023 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已苟活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.27/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://lib.baomitu.com/KaTeX/latest/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topRight', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://image-1309791158.cos.ap-guangzhou.myqcloud.com/其他/1122star.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '键盘敲烂 月薪过万' // 通知消息内容
        });
    }
</script>    
<script  type="text/javascript" src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://cdn.staticfile.org/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div></body></html>